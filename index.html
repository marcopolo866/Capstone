<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Algorithm Runner Interface</title>
    <link rel="stylesheet" href="style.css">
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>Algorithm Runner Interface</h1>
            <p>Run graph algorithms on your local data (no GitHub Actions required)</p>
        </div>
        
        <div class="config-section">
            <div class="input-group">
                <label>Personal Access Token (not used for local runs)</label>
                <input type="password" id="token" placeholder="(unused locally)">
            </div>
            <button class="btn" onclick="connect()">Connect to Local Runner</button>
        </div>
        
        <div class="content">
            <div class="panel">
                <h2>Select Algorithm</h2>
                <div id="algorithms-list">
                    <div class="algorithm-card" onclick="selectAlgorithm(event, 'dijkstra')">
                        <h3>Dijkstra's Algorithm</h3>
                        <p>Shortest path algorithm for weighted graphs</p>
                        <div class="command">./baselines/dijkstra [input-file]</div>
                    </div>
                    
                    <div class="algorithm-card" onclick="selectAlgorithm(event, 'glasgow')">
                        <h3>Glasgow Subgraph Solver</h3>
                        <p>Subgraph isomorphism solver</p>
                        <div class="command">./build/glasgow_subgraph_solver [pattern] [target]</div>
                    </div>
                    
                    <div class="algorithm-card" onclick="selectAlgorithm(event, 'vf3')">
                        <h3>VF3 Algorithm</h3>
                        <p>Graph matching algorithm</p>
                        <div class="command">./bin/vf3 [subgraph] [graph]</div>
                    </div>
                </div>
            </div>
            
            <div class="panel">
                <h2>Select Input Files</h2>
                <div id="status-message"></div>
                <div id="files-content">
                    <p class="loading">Connect to load local data files</p>
                </div>
            </div>
            
            <div class="panel output-section">
                <h2>Run Algorithm 
                    <span id="status-badge"></span>
                </h2>
                
                <div id="run-info"></div>
                
                <div class="run-controls">
                    <button class="btn btn-primary" id="run-btn" onclick="runAlgorithm()" disabled>
                        Run Algorithm
                    </button>
                    <button class="btn" onclick="clearOutput()">Clear Output</button>
                </div>
                
                <div style="margin-top: 20px;">
                    <h3 style="margin-bottom: 10px;">Output:</h3>
                    <div class="output-content" id="output">
No output yet. Select an algorithm and input files, then click "Run Algorithm".
                    </div>
                </div>
            </div>
        </div>
    </div>
    
    <script>
        let config = {
            selectedAlgorithm: null,
            selectedFiles: []
        };
        
        const algorithmConfigs = {
            dijkstra: {
                name: "Dijkstra's Algorithm",
                requiredFiles: 1,
                fileTypes: ['.txt', '.csv', '.grf'],
                instructions: [
                    'Plain text format: first line is the vertex count, second line is "start,target", remaining lines are "u,v,weight" (commas or spaces).',
                    'CSV format: rows contain "source,target,weight"; vertex labels can be names. Add an optional comment line like "# start=A target=D" to choose the endpoints (defaults to the first source and last target).',
                    'When labels are present the reported path will use those labels in the output window.'
                ]
            },
            glasgow: {
                name: "Glasgow Subgraph Solver",
                requiredFiles: 2,
                fileTypes: ['.grf'],
                fileLabels: ['Pattern File', 'Target File']
            },
            vf3: {
                name: "VF3 Algorithm",
                requiredFiles: 2,
                fileTypes: ['.grf'],
                fileLabels: ['Subgraph File', 'Graph File']
            }
        };
        
        function selectAlgorithm(evt, algoId) {
            config.selectedAlgorithm = algoId;
            config.selectedFiles = [];
            
            document.querySelectorAll('.algorithm-card').forEach(card => {
                card.classList.remove('selected');
            });
            if (evt && evt.currentTarget) {
                evt.currentTarget.classList.add('selected');
            }
            
            updateRunButton();
            updateRunInfo();
            loadDataFiles();
        }
        
        async function connect() {
            showStatus('Connecting to local runner...', 'info');
            try {
                await localRequest('/status');
                showStatus('Connected to local runner.', 'success');
                await loadDataFiles();
            } catch (err) {
                showStatus(err.message || 'Failed to reach local runner. Start it with "node app.js".', 'error');
            }
        }
        
        async function loadDataFiles() {
            const container = document.getElementById('files-content');
            container.innerHTML = '<p class="loading">Loading data files...</p>';
            
            try {
                const resp = await localRequest('/files');
                const files = (resp && resp.files) ? resp.files : [];
                
                let html = '<ul class="file-list">';
                files.forEach(item => {
                    const icon = 'ðŸ“„';
                    html += `
                        <li class="file-item" onclick="toggleFileSelection(event, '${item.path}', '${item.name}')">
                            <span class="file-icon">${icon}</span>
                            <span>${item.name}</span>
                        </li>
                    `;
                });
                
                html += '</ul>';
                container.innerHTML = html;
                
            } catch (error) {
                let hint = 'Make sure the local runner is running: node app.js';
                container.innerHTML = `<div class="error">Error loading files: ${escapeHtml(error.message)}<br>${hint}</div>`;
            }
        }
        
        function toggleFileSelection(evt, path, name) {
            const algo = algorithmConfigs[config.selectedAlgorithm];
            if (!algo) {
                showStatus('Please select an algorithm first', 'error');
                return;
            }
            
            const index = config.selectedFiles.findIndex(f => f.path === path);
            
            if (index > -1) {
                config.selectedFiles.splice(index, 1);
                if (evt && evt.currentTarget) {
                    evt.currentTarget.classList.remove('selected');
                }
            } else {
                if (config.selectedFiles.length >= algo.requiredFiles) {
                    showStatus(`This algorithm requires exactly ${algo.requiredFiles} file(s)`, 'error');
                    return;
                }
                config.selectedFiles.push({ path, name });
                if (evt && evt.currentTarget) {
                    evt.currentTarget.classList.add('selected');
                }
            }
            
            updateRunButton();
            updateRunInfo();
        }
        
        function updateRunButton() {
            const btn = document.getElementById('run-btn');
            const algo = algorithmConfigs[config.selectedAlgorithm];
            
            btn.disabled = !(algo && config.selectedFiles.length === algo.requiredFiles);
        }
        
        function updateRunInfo() {
            const infoDiv = document.getElementById('run-info');
            const algo = algorithmConfigs[config.selectedAlgorithm];
            
            if (!algo) {
                infoDiv.innerHTML = '<div class="info">Select an algorithm above to get started</div>';
                return;
            }
            
            let html = `<div class="info">
                <strong>Algorithm:</strong> ${algo.name}<br>
                <strong>Required files:</strong> ${algo.requiredFiles}
            `;
            
            if (algo.instructions && algo.instructions.length) {
                html += '<div class="instructions"><strong>File format tips:</strong><ul>';
                html += algo.instructions.map(item => `<li>${escapeHtml(item)}</li>`).join('');
                html += '</ul></div>';
            }
            
            if (config.selectedFiles.length > 0) {
                html += '<div class="selected-files"><strong>Selected:</strong> ';
                html += config.selectedFiles.map((f, i) => {
                    const label = algo.fileLabels ? algo.fileLabels[i] : `File ${i+1}`;
                    return `${label}: ${f.name}`;
                }).join(', ');
                html += '</div>';
            }
            
            html += '</div>';
            infoDiv.innerHTML = html;
        }
        
        async function runAlgorithm() {
            const outputDiv = document.getElementById('output');
            const statusBadge = document.getElementById('status-badge');
            const runBtn = document.getElementById('run-btn');
            runBtn.disabled = true;

            const fail = (message) => {
                outputDiv.textContent = `Failure: ${message}`;
                statusBadge.innerHTML = '<span class="status-badge status-error">Failed</span>';
                runBtn.disabled = false;
            };

            if (!config.selectedAlgorithm) {
                fail('No algorithm selected.');
                return;
            }

            const algo = algorithmConfigs[config.selectedAlgorithm];
            if (!algo) {
                fail('Unknown algorithm selected.');
                return;
            }

            if (config.selectedFiles.length !== algo.requiredFiles) {
                fail(`Selected ${config.selectedFiles.length} file(s); expected ${algo.requiredFiles}.`);
                return;
            }

            const inputLines = config.selectedFiles.map((file, index) => {
                const label = algo.fileLabels ? algo.fileLabels[index] : `File ${index + 1}`;
                return `${label}: ${file.path}`;
            });

            const summaryLines = [
                `Algorithm: ${algo.name}`,
                'Inputs:',
                ...inputLines,
                '',
                'Result:',
                'Running locally...'
            ];
            outputDiv.textContent = summaryLines.join('\n');
            statusBadge.innerHTML = '<span class="status-badge status-running">Running...</span>';

            try {
                const result = await localRequest('/run', 'POST', {
                    algorithm: config.selectedAlgorithm,
                    files: config.selectedFiles.map(f => f.path)
                });
                if (!result || result.status !== 'success') {
                    throw new Error((result && result.error) || 'Run failed');
                }

                const finalLines = [
                    `Algorithm: ${algo.name}`,
                    'Inputs:',
                    ...inputLines,
                    '',
                    'Result:',
                    result.output || '(No output)'
                ];
                outputDiv.textContent = finalLines.join('\n');
                statusBadge.innerHTML = '<span class="status-badge status-ready">Success</span>';
            } catch (error) {
                outputDiv.textContent = `Failure: ${error.message || error}`;
                statusBadge.innerHTML = '<span class="status-badge status-error">Failed</span>';
            } finally {
                runBtn.disabled = false;
            }
        }

        function clearOutput() {
            document.getElementById('output').textContent = 'Output cleared.';
            document.getElementById('status-badge').innerHTML = '';
        }
        
        async function localRequest(path, method = 'GET', body = null) {
            const headers = { 'Content-Type': 'application/json' };
            const opts = { method, headers };
            if (body) {
                opts.body = JSON.stringify(body);
            }
            const resp = await fetch(`http://localhost:3000${path}`, opts);
            if (!resp.ok) {
                let detail = '';
                try {
                    detail = await resp.text();
                } catch (e) {}
                throw new Error(`Local API error: ${resp.status} ${resp.statusText}${detail ? ' - ' + detail : ''}`);
            }
            return await resp.json();
        }
        
        function showStatus(message, type) {
            const container = document.getElementById('status-message');
            container.innerHTML = `<div class="${type}">${escapeHtml(message)}</div>`;
            setTimeout(() => {
                container.innerHTML = '';
            }, 5000);
        }
        
        function escapeHtml(text) {
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }
    </script>
</body>
</html>
