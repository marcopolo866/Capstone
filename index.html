<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Algorithm Runner Interface</title>
    <link rel="stylesheet" href="style.css">
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>Algorithm Runner Interface</h1>
            <p>Run graph algorithms on your repository data</p>
        </div>
        
        <div class="config-section">
            <div class="input-group">
                <label>GitHub Username/Org</label>
                <input type="text" id="owner" placeholder="marcopolo866">
            </div>
            <div class="input-group">
                <label>Repository Name</label>
                <input type="text" id="repo" placeholder="Capstone">
            </div>
            <div class="input-group">
                <label>Personal Access Token (Required for running algorithms)</label>
                <input type="password" id="token" placeholder="ghp_xxxxxxxxxxxx">
            </div>
            <div class="input-group">
                <label>Benchmark iterations</label>
                <input type="number" id="iterations" value="5" min="1" max="1000">
            </div>
            <div class="input-group">
                <label>Warmup runs (per test)</label>
                <input type="number" id="warmup" value="1" min="0" max="50">
            </div>
            <button class="btn" onclick="connect()">Connect to Repository</button>
        </div>
        
        <div class="content">
            <div class="panel">
                <h2>Select Algorithm</h2>
                <div id="algorithms-list">
                    <div class="algorithm-card" onclick="selectAlgorithm(event, 'dijkstra')">
                        <h3>Dijkstra's Algorithm</h3>
                        <p>Shortest path algorithm for weighted graphs</p>
                        <div class="command">./baselines/dijkstra [input-file]</div>
                    </div>
                    
                    <div class="algorithm-card" onclick="selectAlgorithm(event, 'glasgow')">
                        <h3>Glasgow Subgraph Solver</h3>
                        <p>Subgraph isomorphism solver</p>
                        <div class="command">./build/glasgow_subgraph_solver [pattern] [target]</div>
                    </div>
                    
                    <div class="algorithm-card" onclick="selectAlgorithm(event, 'vf3')">
                        <h3>VF3 Algorithm</h3>
                        <p>Graph matching algorithm</p>
                        <div class="command">./bin/vf3 [subgraph] [graph]</div>
                    </div>
                </div>
            </div>
            
            <div class="panel">
                <h2>Select Input Files</h2>
                <div id="status-message"></div>
                <div id="files-content">
                    <p class="loading">Connect to repository to browse data files</p>
                </div>
            </div>
            
            <div class="panel output-section">
                <h2>Run Algorithm 
                    <span id="status-badge"></span>
                </h2>
                
                <div id="run-info"></div>
                
                <div class="run-controls">
                    <button class="btn btn-primary" id="run-btn" onclick="runAlgorithm()" disabled>
                        Run Algorithm
                    </button>
                    <button class="btn" onclick="clearOutput()">Clear Output</button>
                </div>

                <div class="progress-wrapper" id="progress-wrapper" hidden>
                    <div class="progress-meta">
                        <div class="progress-phase" id="progress-phase">Preparing...</div>
                        <div class="progress-count" id="progress-count">0/0</div>
                    </div>
                    <div class="progress-bar" id="progress-bar" role="progressbar" aria-valuemin="0" aria-valuemax="100" aria-valuenow="0">
                        <div class="progress-fill" id="progress-fill"></div>
                    </div>
                </div>
                
                <div style="margin-top: 20px;">
                    <h3 style="margin-bottom: 10px;">Output:</h3>
                    <div class="output-content" id="output">
No output yet. Select an algorithm and input files, then click "Run Algorithm".
                    </div>
                </div>
            </div>
        </div>
    </div>
    
    <script>
        let config = {
            owner: '',
            repo: '',
            token: '',
            ref: 'main',
            selectedAlgorithm: null,
            selectedFiles: []
        };
        
        const algorithmConfigs = {
            dijkstra: {
                name: "Dijkstra's Algorithm",
                requiredFiles: 1,
                fileTypes: ['.txt', '.csv', '.grf'],
                instructions: [
                    'Plain text format: first line is the vertex count, second line is "start,target", remaining lines are "u,v,weight" (commas or spaces).',
                    'CSV format: rows contain "source,target,weight"; vertex labels can be names. Add an optional comment line like "# start=A target=D" to choose the endpoints (defaults to the first source and last target).',
                    'When labels are present the reported path will use those labels in the output window.'
                ]
            },
            glasgow: {
                name: "Glasgow Subgraph Solver",
                requiredFiles: 2,
                fileTypes: ['.grf'],
                fileLabels: ['Pattern File', 'Target File']
            },
            vf3: {
                name: "VF3 Algorithm",
                requiredFiles: 2,
                fileTypes: ['.grf'],
                fileLabels: ['Subgraph File', 'Graph File']
            }
        };

        const progressState = {
            requestId: '',
            runSha: '',
            total: 0,
            completed: 0,
            phase: ''
        };

        function getTestsPerIteration(algoId) {
            if (algoId === 'dijkstra') return 2;
            if (algoId === 'glasgow') return 1;
            if (algoId === 'vf3') return 3;
            return 0;
        }

        function getProgressEls() {
            return {
                wrapper: document.getElementById('progress-wrapper'),
                phase: document.getElementById('progress-phase'),
                count: document.getElementById('progress-count'),
                bar: document.getElementById('progress-bar'),
                fill: document.getElementById('progress-fill')
            };
        }

        function setProgressVisible(visible) {
            const els = getProgressEls();
            if (!els.wrapper) return;
            els.wrapper.hidden = !visible;
        }

        function progressReset(algoId, iterations, requestId) {
            const testsPerIter = getTestsPerIteration(algoId);
            progressState.requestId = requestId || '';
            progressState.runSha = '';
            progressState.total = Math.max(0, Number(iterations) || 0) * testsPerIter;
            progressState.completed = 0;
            progressState.phase = '';

            setProgressVisible(true);
            progressSetDeterminate('Queued...', 0, progressState.total);
        }

        function progressClear() {
            progressState.requestId = '';
            progressState.runSha = '';
            progressState.total = 0;
            progressState.completed = 0;
            progressState.phase = '';

            const els = getProgressEls();
            if (els.wrapper) {
                els.wrapper.hidden = true;
            }
            if (els.fill) els.fill.style.width = '0%';
            if (els.bar) els.bar.setAttribute('aria-valuenow', '0');
            if (els.phase) els.phase.textContent = '';
            if (els.count) els.count.textContent = '';
        }

        function progressSetDeterminate(phaseText, completed, total) {
            const els = getProgressEls();

            const prevTotal = Number.isFinite(Number(progressState.total)) ? Number(progressState.total) : 0;
            const prevCompleted = Number.isFinite(Number(progressState.completed)) ? Number(progressState.completed) : 0;

            const safeTotal = Math.max(0, Number(total) || 0);
            const effectiveTotal = safeTotal || prevTotal;
            const requestedCompleted = Math.max(0, Math.min(effectiveTotal || 0, Number(completed) || 0));
            const safeCompleted = Math.max(prevCompleted, requestedCompleted);
            const percent = effectiveTotal ? (safeCompleted / effectiveTotal) * 100 : 0;
            const displayCompleted = Math.floor(safeCompleted);

            progressState.completed = safeCompleted;
            progressState.total = effectiveTotal;
            progressState.phase = phaseText || '';

            if (els.phase) els.phase.textContent = phaseText || 'Running...';
            if (els.count) els.count.textContent = effectiveTotal ? `${displayCompleted}/${effectiveTotal} (${percent.toFixed(1)}%)` : `${displayCompleted}/0`;
            if (els.fill) els.fill.style.width = `${Math.max(0, Math.min(100, percent))}%`;
            if (els.bar) els.bar.setAttribute('aria-valuenow', String(Math.round(percent)));
        }

        function progressUpdateEstimated(attempt, maxAttempts, phaseText) {
            const total = Number.isFinite(Number(progressState.total)) ? Number(progressState.total) : 0;
            if (!total) {
                progressSetDeterminate(phaseText || 'Running...', 0, 0);
                return;
            }

            const denom = Math.max(1, Number(maxAttempts) || 1);
            const step = Math.min(Math.max(1, Number(attempt) || 1), denom);
            const targetPercent = Math.min(95, (step / denom) * 95);
            const currentPercent = (progressState.completed / total) * 100;
            const percent = Math.max(currentPercent, targetPercent);
            const estimatedCompleted = (percent / 100) * total;
            progressSetDeterminate(phaseText || 'Running...', estimatedCompleted, total);
        }

        function encodePathPreservingSlashes(value) {
            return String(value || '').split('/').map(part => encodeURIComponent(part)).join('/');
        }

        async function getBranchHeadSha(branchRef) {
            const ref = String(branchRef || '').trim();
            if (!ref) return '';

            try {
                const data = await apiRequest(`/git/ref/heads/${encodePathPreservingSlashes(ref)}`);
                if (data && data.object && data.object.sha) return data.object.sha;
            } catch (_) {}

            try {
                const data = await apiRequest(`/commits/${encodePathPreservingSlashes(ref)}`);
                if (data && data.sha) return data.sha;
            } catch (_) {}

            return '';
        }

        async function tryUpdateProgressFromChecks(requestId, runSha) {
            if (!requestId || !runSha) return { updated: false, reason: 'missing' };

            const endpoint = `/commits/${runSha}/check-runs?per_page=100&filter=latest`;

            let data = null;
            let authError = null;
            try {
                data = await apiRequest(endpoint);
            } catch (error) {
                authError = error;
            }

            if (!data) {
                const msg = authError && authError.message ? authError.message : '';
                // If a fine-grained token lacks Checks: Read but the repo is public, retry without auth.
                if (config.token && (msg.includes('403') || msg.includes('401'))) {
                    try {
                        data = await apiRequest(endpoint, 'GET', null, { useAuth: false });
                    } catch (fallbackError) {
                        const fallbackMsg = fallbackError && fallbackError.message ? fallbackError.message : '';
                        if (msg.includes('403') || fallbackMsg.includes('403')) {
                            return { updated: false, reason: 'forbidden' };
                        }
                        return { updated: false, reason: 'error' };
                    }
                } else {
                    if (msg.includes('403')) {
                        return { updated: false, reason: 'forbidden' };
                    }
                    return { updated: false, reason: 'error' };
                }
            }

            const checkRuns = (data && Array.isArray(data.check_runs)) ? data.check_runs : [];
            if (!checkRuns.length) return { updated: false, reason: 'no_check_runs' };

            const match = checkRuns.find(cr => typeof cr.name === 'string' && cr.name.includes(requestId)) ||
                          checkRuns.find(cr => cr.output && typeof cr.output.text === 'string' && cr.output.text.includes(requestId));
            if (!match) return { updated: false, reason: 'not_found' };

            let progress = null;
            if (match.output && typeof match.output.text === 'string') {
                try {
                    progress = JSON.parse(match.output.text);
                } catch (_) {
                    progress = null;
                }
            }

            const completed = progress && Number.isFinite(Number(progress.completed)) ? Number(progress.completed) : 0;
            const total = progress && Number.isFinite(Number(progress.total)) ? Number(progress.total) : (progressState.total || 0);
            const phase = progress && typeof progress.phase === 'string' ? progress.phase : '';

            progressSetDeterminate(phase || 'Running...', completed, total);
            return { updated: true, reason: 'ok' };
        }
        
        function selectAlgorithm(evt, algoId) {
            config.selectedAlgorithm = algoId;
            config.selectedFiles = [];
            
            document.querySelectorAll('.algorithm-card').forEach(card => {
                card.classList.remove('selected');
            });
            if (evt && evt.currentTarget) {
                evt.currentTarget.classList.add('selected');
            }
            
            updateRunButton();
            updateRunInfo();
            
            if (config.owner && config.repo) {
                loadDataFiles();
            }
        }
        
        async function connect() {
            const owner = document.getElementById('owner').value.trim();
            const repo = document.getElementById('repo').value.trim();
            const token = document.getElementById('token').value.trim();
            
            if (!owner || !repo) {
                showStatus('Please enter both username/org and repository name', 'error');
                return;
            }
            
            if (!token) {
                showStatus('Personal Access Token is required to run algorithms', 'error');
                return;
            }
            
            config.owner = owner;
            config.repo = repo;
            config.token = token;
            
            try {
                const repoInfo = await apiRequest('');
                if (repoInfo && repoInfo.default_branch) {
                    config.ref = repoInfo.default_branch;
                }
            } catch (e) {
                // default branch fallback already set to 'main'
            }

            showStatus('Connected successfully!', 'success');
            await loadDataFiles();
        }
        
        async function loadDataFiles() {
            const container = document.getElementById('files-content');
            container.innerHTML = '<p class="loading">Loading data files...</p>';
            
            try {
                const ref = config.ref ? `?ref=${encodeURIComponent(config.ref)}` : '';
                let contents;
                try {
                    contents = await apiRequest(`/contents/data${ref}`);
                } catch (error) {
                    const msg = (error && error.message) ? error.message : '';
                    if (config.token && (msg.includes('404') || msg.includes('401') || msg.includes('403'))) {
                        try {
                            contents = await apiRequest(`/contents/data${ref}`, 'GET', null, { useAuth: false });
                        } catch (fallbackError) {
                            throw fallbackError;
                        }
                    } else {
                        throw error;
                    }
                }
                
                let html = '<ul class="file-list">';
                
                const files = Array.isArray(contents) ? contents : [contents];
                
                files.forEach(item => {
                    if (item.type === 'file') {
                        const icon = 'ðŸ“„';
                        html += `
                            <li class="file-item" onclick="toggleFileSelection(event, '${item.path}', '${item.name}')">
                                <span class="file-icon">${icon}</span>
                                <span>${item.name}</span>
                            </li>
                        `;
                    }
                });
                
                html += '</ul>';
                container.innerHTML = html;
                
            } catch (error) {
                    reportDebugError('loadDataFiles', error, {
                        owner: config.owner,
                        repo: config.repo,
                        ref: config.ref
                    });
                    let hint = 'Verify the repo has a top-level "data" folder on the selected branch.';
                    let extra = '';
                    const msg = (error && error.message) ? error.message : '';
                    if (msg.includes('401')) {
                        extra = ' (check that your PAT is valid and has repo/workflow scopes; if the repo is public, retry without auth)';
                    }
                    container.innerHTML = `<div class="error">Error loading files: ${escapeHtml(error.message)}${escapeHtml(extra)}<br>${hint}</div>`;
            }
        }
        
        function toggleFileSelection(evt, path, name) {
            const algo = algorithmConfigs[config.selectedAlgorithm];
            if (!algo) {
                showStatus('Please select an algorithm first', 'error');
                return;
            }
            
            const index = config.selectedFiles.findIndex(f => f.path === path);
            
            if (index > -1) {
                config.selectedFiles.splice(index, 1);
                if (evt && evt.currentTarget) {
                    evt.currentTarget.classList.remove('selected');
                }
            } else {
                if (config.selectedFiles.length >= algo.requiredFiles) {
                    showStatus(`This algorithm requires exactly ${algo.requiredFiles} file(s)`, 'error');
                    return;
                }
                config.selectedFiles.push({ path, name });
                if (evt && evt.currentTarget) {
                    evt.currentTarget.classList.add('selected');
                }
            }
            
            updateRunButton();
            updateRunInfo();
        }
        
        function updateRunButton() {
            const btn = document.getElementById('run-btn');
            const algo = algorithmConfigs[config.selectedAlgorithm];
            
            if (algo && config.selectedFiles.length === algo.requiredFiles && config.token) {
                btn.disabled = false;
            } else {
                btn.disabled = true;
            }
        }
        
        function updateRunInfo() {
            const infoDiv = document.getElementById('run-info');
            const algo = algorithmConfigs[config.selectedAlgorithm];
            
            if (!algo) {
                infoDiv.innerHTML = '<div class="info">Select an algorithm above to get started</div>';
                return;
            }
            
            let html = `<div class="info">
                <strong>Algorithm:</strong> ${algo.name}<br>
                <strong>Required files:</strong> ${algo.requiredFiles}
            `;
            
            if (algo.instructions && algo.instructions.length) {
                html += '<div class="instructions"><strong>File format tips:</strong><ul>';
                html += algo.instructions.map(item => `<li>${escapeHtml(item)}</li>`).join('');
                html += '</ul></div>';
            }
            
            if (config.selectedFiles.length > 0) {
                html += '<div class="selected-files"><strong>Selected:</strong> ';
                html += config.selectedFiles.map((f, i) => {
                    const label = algo.fileLabels ? algo.fileLabels[i] : `File ${i+1}`;
                    return `${label}: ${f.name}`;
                }).join(', ');
                html += '</div>';
            }
            
            html += '</div>';
            infoDiv.innerHTML = html;
        }
        
        async function runAlgorithm() {
            const outputDiv = document.getElementById('output');
            const statusBadge = document.getElementById('status-badge');
            const runBtn = document.getElementById('run-btn');
            runBtn.disabled = true;

            const nowMs = () => (window.performance && typeof window.performance.now === 'function')
                ? window.performance.now()
                : Date.now();
            const formatDurationMs = (ms) => {
                if (!Number.isFinite(ms)) return '';
                const totalSeconds = ms / 1000;
                const minutes = Math.floor(totalSeconds / 60);
                const seconds = totalSeconds - minutes * 60;
                const secondsStr = seconds.toFixed(1).padStart(4, '0');
                return `${minutes}m ${secondsStr}s`;
            };
            const endToEndStartMs = nowMs();

            const fail = (message) => {
                const elapsedMs = nowMs() - endToEndStartMs;
                progressClear();
                outputDiv.textContent = `Failure: ${message}\n\nTotal end-to-end time: ${formatDurationMs(elapsedMs)}`;
                statusBadge.innerHTML = '<span class="status-badge status-error">Failed</span>';
                runBtn.disabled = false;
            };

            if (!config.selectedAlgorithm) {
                fail('No algorithm selected.');
                return;
            }

            const algo = algorithmConfigs[config.selectedAlgorithm];
            if (!algo) {
                fail('Unknown algorithm selected.');
                return;
            }

            if (config.selectedFiles.length !== algo.requiredFiles) {
                fail(`Selected ${config.selectedFiles.length} file(s); expected ${algo.requiredFiles}.`);
                return;
            }

            if (!config.token) {
                fail('Personal Access Token is required to run workflows.');
                return;
            }

            const inputLines = config.selectedFiles.map((file, index) => {
                const label = algo.fileLabels ? algo.fileLabels[index] : `File ${index + 1}`;
                return `${label}: ${file.path}`;
            });

            const summaryLines = [
                `Algorithm: ${algo.name}`,
                'Inputs:',
                ...inputLines,
                '',
                'Result:',
                'Triggering workflow...'
            ];
            outputDiv.textContent = summaryLines.join('\n');
            statusBadge.innerHTML = '<span class="status-badge status-running">Running...</span>';

            const requestId = (crypto && crypto.randomUUID) ? crypto.randomUUID() : `${Date.now()}-${Math.random()}`;
            const iterationsEl = document.getElementById('iterations');
            const warmupEl = document.getElementById('warmup');
            const iterationsRaw = iterationsEl ? String(iterationsEl.value || '').trim() : '';
            const warmupRaw = warmupEl ? String(warmupEl.value || '').trim() : '';
            let iterations = 1;
            if (iterationsRaw) {
                const parsed = parseInt(iterationsRaw, 10);
                if (Number.isFinite(parsed) && parsed >= 1) iterations = parsed;
            }
            if (iterations > 1000) iterations = 1000;

            let warmup = 0;
            if (warmupRaw) {
                const parsed = parseInt(warmupRaw, 10);
                if (Number.isFinite(parsed) && parsed >= 0) warmup = parsed;
            }
            if (warmup > 50) warmup = 50;

            const branchRef = config.ref || 'main';
            progressReset(config.selectedAlgorithm, iterations, requestId);

            let runSha = '';
            try {
                runSha = await getBranchHeadSha(branchRef);
                if (runSha) progressState.runSha = runSha;
            } catch (_) {}

            const workflowData = {
                ref: branchRef,
                inputs: {
                    algorithm: config.selectedAlgorithm,
                    iterations: String(iterations),
                    warmup: String(warmup),
                    input_files: config.selectedFiles.map(f => f.path).join(','),
                    request_id: requestId
                }
            };

            let dispatched = false;
            try {
                await ensureWorkflowDispatch(branchRef);
                await dispatchWorkflow(workflowData);
                dispatched = true;
                progressSetDeterminate('Running...', 0, progressState.total);
                const result = await waitForResult(requestId, branchRef, runSha);
                if (result.status !== 'success') {
                    throw new Error(result.error || 'Workflow reported failure');
                }

                const finalLines = [
                    `Algorithm: ${algo.name}`,
                    'Inputs:',
                    ...inputLines,
                    '',
                    'Result:',
                    result.output || '(No output)'
                ];
                const elapsedMs = nowMs() - endToEndStartMs;
                finalLines.push('', `Total end-to-end time: ${formatDurationMs(elapsedMs)}`);
                outputDiv.textContent = finalLines.join('\n');
                statusBadge.innerHTML = '<span class="status-badge status-ready">Success</span>';
                if (progressState.total > 0) {
                    progressSetDeterminate('Completed', progressState.total, progressState.total);
                }
            } catch (error) {
                const message = error && error.message ? error.message : String(error);
                const elapsedMs = nowMs() - endToEndStartMs;
                outputDiv.textContent = `Failure: ${message}\n\nTotal end-to-end time: ${formatDurationMs(elapsedMs)}`;
                reportDebugError('runAlgorithm', error, {
                    algorithm: config.selectedAlgorithm,
                    files: config.selectedFiles.map(f => f.path).join(','),
                    ref: branchRef
                });
                statusBadge.innerHTML = '<span class="status-badge status-error">Failed</span>';

                if (!dispatched) {
                    progressClear();
                } else {
                    const phaseText = message.length > 120 ? message.slice(0, 117) + '...' : message;
                    progressSetDeterminate(phaseText, progressState.completed, progressState.total);
                }
            } finally {
                runBtn.disabled = false;
            }
        }

        let workflowDispatchEndpointCache = null;
        async function getWorkflowDispatchEndpoint() {
            if (workflowDispatchEndpointCache) return workflowDispatchEndpointCache;
            // Prefer workflow ID to avoid path mismatches; fall back to path if needed.
            try {
                const data = await apiRequest('/actions/workflows');
                if (data && Array.isArray(data.workflows)) {
                    const match = data.workflows.find(wf =>
                        wf.path === '.github/workflows/run-algorithm.yml' ||
                        (wf.name && wf.name.toLowerCase().includes('run algorithm'))
                    );
                    if (match && match.id) {
                        workflowDispatchEndpointCache = `/actions/workflows/${match.id}/dispatches`;
                        return workflowDispatchEndpointCache;
                    }
                }
            } catch (error) {
                // Ignore and fall back
            }
            workflowDispatchEndpointCache = '/actions/workflows/run-algorithm.yml/dispatches';
            return workflowDispatchEndpointCache;
        }

        async function dispatchWorkflow(workflowData) {
            const dispatchEndpoint = await getWorkflowDispatchEndpoint();
            try {
                await apiRequest(dispatchEndpoint, 'POST', workflowData);
            } catch (error) {
                const msg = (error && error.message) ? error.message : '';
                const isMissingTrigger = msg.includes("Workflow does not have 'workflow_dispatch' trigger") || msg.includes('422');
                if (!isMissingTrigger) {
                    throw error;
                }
                // Fallback to repository_dispatch event
                const repoPayload = {
                    event_type: 'run-algorithm',
                    client_payload: {
                        algorithm: workflowData.inputs.algorithm,
                        iterations: workflowData.inputs.iterations,
                        warmup: workflowData.inputs.warmup,
                        input_files: workflowData.inputs.input_files,
                        request_id: workflowData.inputs.request_id || ''
                    }
                };
                await apiRequest('/dispatches', 'POST', repoPayload);
            }
        }

        function delay(ms) {
            return new Promise(resolve => setTimeout(resolve, ms));
        }

        async function ensureWorkflowDispatch(branchRef) {
            const refParam = branchRef ? `?ref=${encodeURIComponent(branchRef)}` : '';
            const path = `/contents/.github/workflows/run-algorithm.yml${refParam}`;
            try {
                const wf = await apiRequest(path);
                if (!wf || !wf.content) return;
                const decoded = atob(wf.content.replace(/\s/g, ''));
                if (!decoded.includes('workflow_dispatch')) {
                    throw new Error('run-algorithm.yml is missing a workflow_dispatch trigger on this branch');
                }
            } catch (error) {
                // Surface a clear error for the common 422 case
                throw new Error(`Workflow unavailable on branch ${branchRef || 'main'}: ${error.message || error}`);
            }
        }

        async function waitForResult(requestId, branchRef, runSha) {
            const waitMs = 5000;
            const maxAttempts = 720; // ~60 minutes at 5s intervals
            let lastError = null;
            let sha = runSha || '';

            for (let attempt = 1; attempt <= maxAttempts; attempt++) {
                if (!sha) {
                    try {
                        sha = await getBranchHeadSha(branchRef || config.ref || 'main');
                        if (sha) progressState.runSha = sha;
                    } catch (_) {}
                }
                let progressUpdated = false;
                let progressReason = '';
                if (sha) {
                    try {
                        const progressRes = await tryUpdateProgressFromChecks(requestId, sha);
                        progressUpdated = !!(progressRes && progressRes.updated);
                        progressReason = progressRes && progressRes.reason ? progressRes.reason : '';
                    } catch (_) {}
                }
                if (!progressUpdated) {
                    const phase = progressReason === 'forbidden'
                        ? 'Running... (enable Checks: Read)'
                        : 'Running...';
                    progressUpdateEstimated(attempt, maxAttempts, phase);
                }
                try {
                    const refParam = branchRef ? `?ref=${encodeURIComponent(branchRef)}` : '';
                    const file = await apiRequest(`/contents/outputs/result.json${refParam}`);
                    if (file && file.content) {
                        const decoded = atob(file.content.replace(/\\s/g, ''));
                        const json = JSON.parse(decoded);
                        if (!requestId || !json.request_id || json.request_id === requestId) {
                            return json;
                        }
                    }
                } catch (error) {
                    lastError = error;
                    if (error && error.message && error.message.includes('404')) {
                        // Not ready yet; continue polling.
                    } else {
                        // Remember the error but keep retrying until timeout.
                    }
                }
                await delay(waitMs);
            }

            if (lastError) {
                throw lastError;
            }
            throw new Error('Timed out waiting for workflow result.');
        }

        function clearOutput() {
            document.getElementById('output').textContent = 'Output cleared.';
            document.getElementById('status-badge').innerHTML = '';
            progressClear();
        }
        
        async function apiRequest(endpoint, method = 'GET', body = null, options = {}) {
            const { useAuth = true } = options;
            const headers = {
                'Accept': 'application/vnd.github.v3+json',
                    'X-GitHub-Api-Version': '2022-11-28'
            };
            
            if (useAuth && config.token) {
                const lower = config.token.toLowerCase();
                const useBearer = lower.startsWith('github_pat_') || lower.startsWith('ghs_') || lower.startsWith('ghu_');
                headers['Authorization'] = useBearer
                    ? `Bearer ${config.token}`
                    : `token ${config.token}`;
            }
            
            const requestOptions = {
                method: method,
                headers: headers
            };
            
            if (body) {
                requestOptions.body = JSON.stringify(body);
            }
            
            const url = `https://api.github.com/repos/${config.owner}/${config.repo}${endpoint}`;
            const response = await fetch(url, requestOptions);
                        
            if (!response.ok) {
                let responseText = '';
                try {
                    responseText = await response.text();
                } catch (_) {}
                throw new Error(`GitHub API error: ${response.status} ${response.statusText} | endpoint=${endpoint} method=${method} ref=${config.ref || 'main'} | body=${responseText}`);
            }
            
            if (method === 'POST' && response.status === 204) {
                return { success: true };
            }
            
            return await response.json();
        }

        function reportDebugError(context, error, meta = {}) {
            const detail = (error && error.message) ? error.message : String(error);
            const metaStr = Object.entries(meta).map(([k,v]) => `${k}=${v}`).join(', ');
            const debugMsg = `[${context}] ${detail}${metaStr ? ' | ' + metaStr : ''}`;
            showStatus(debugMsg, 'error');
            if (console && console.error) {
                console.error(debugMsg, error);
            }
        }
        
        function showStatus(message, type) {
            const container = document.getElementById('status-message');
            container.innerHTML = `<div class="${type}">${escapeHtml(message)}</div>`;
            setTimeout(() => {
                container.innerHTML = '';
            }, 5000);
        }
        
        function escapeHtml(text) {
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }
    </script>
</body>
</html>
