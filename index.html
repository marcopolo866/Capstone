<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Algorithm Runner Interface</title>
    <link rel="stylesheet" href="style.css">
    <script src="https://cdn.jsdelivr.net/npm/jszip@3.10.1/dist/jszip.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.1/dist/chart.umd.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/cytoscape@3.29.2/dist/cytoscape.min.js"></script>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>Algorithm Runner Interface</h1>
            <p>Run graph algorithms on your repository data</p>
        </div>
        
        <div class="config-section">
            <div class="input-group">
                <label>GitHub Username/Org</label>
                <input type="text" id="owner" placeholder="marcopolo866" value="marcopolo866">
            </div>
            <div class="input-group">
                <label>Repository Name</label>
                <input type="text" id="repo" placeholder="Capstone" value="Capstone">
            </div>
            <div class="input-group">
                <label>Personal Access Token (Required for running algorithms)</label>
                <input type="password" id="token" placeholder="ghp_xxxxxxxxxxxx">
            </div>
            <button class="btn" onclick="connect()">Connect to Repository</button>
        </div>
        
        <div class="content">
            <div class="panel">
                <h2>Select Algorithm</h2>
                <div id="algorithms-list">
                    <div class="algorithm-card" onclick="selectAlgorithm(event, 'dijkstra')">
                        <h3>Dijkstra's Algorithm</h3>
                        <p>Shortest path algorithm for weighted graphs</p>
                        <div class="command">./baselines/dijkstra [input-file]</div>
                    </div>
                    
                    <div class="algorithm-card" onclick="selectAlgorithm(event, 'glasgow')">
                        <h3>Glasgow Subgraph Solver</h3>
                        <p>Subgraph isomorphism solver</p>
                        <div class="command">./build/glasgow_subgraph_solver [pattern] [target]</div>
                    </div>
                    
                    <div class="algorithm-card" onclick="selectAlgorithm(event, 'vf3')">
                        <h3>VF3 Algorithm</h3>
                        <p>Graph matching algorithm</p>
                        <div class="command">./bin/vf3 [subgraph] [graph]</div>
                    </div>
                </div>
            </div>
            
            <div class="panel">
                <h2>Select Input Files</h2>
                <div id="status-message"></div>
                <div class="input-group">
                    <label>Input Source</label>
                    <select id="input-mode" onchange="onInputModeChange()">
                        <option value="premade">Premade graphs</option>
                        <option value="generate" selected>Generate graphs</option>
                    </select>
                    <div class="inline-note" id="generator-disabled-note" hidden>
                        Generator mode is only available for GitHub Actions runs.
                    </div>
                </div>
                <div class="generator-form" id="generator-form" hidden>
                    <div class="input-group">
                        <label>N (target graph node count)</label>
                        <input type="number" id="gen-n" min="2" value="100" placeholder="e.g., 200" oninput="onGeneratorInputChange()">
                    </div>
                    <div class="input-group" id="gen-k-group">
                        <label>k (pattern/subgraph node count, k &lt; N)</label>
                        <input type="number" id="gen-k" min="1" value="10" placeholder="e.g., 40" oninput="onGeneratorInputChange()">
                    </div>
                    <div class="input-group">
                        <label>Density (fraction of possible edges, 0-1)</label>
                        <input type="number" id="gen-density" min="0.01" max="1" step="0.01" value="0.01" oninput="onGeneratorInputChange()">
                    </div>
                    <div class="input-group">
                        <label>Seed (optional, integer)</label>
                        <input type="number" id="gen-seed" step="1" placeholder="Leave blank for random" oninput="onGeneratorInputChange()">
                    </div>
                    <div class="inline-note" id="generator-estimate" hidden></div>
                    <div class="inline-warning" id="generator-warning" hidden>
                        k must be smaller than N.
                    </div>
                    <div class="inline-warning" id="generator-seed-warning" hidden>
                        Seed must be an integer.
                    </div>
                </div>
                <div id="files-content">
                    <p class="loading">Connect to repository to browse data files</p>
                </div>
            </div>
            
            <div class="panel output-section">
                <h2>Run Algorithm 
                    <span id="status-badge"></span>
                </h2>
                
                <div id="run-info"></div>
                
                <div class="run-controls">
                    <div class="run-params">
                        <div class="input-group">
                            <label>Benchmark iterations</label>
                            <input type="number" id="iterations" value="5" min="1">
                        </div>
                        <div class="input-group">
                            <label>Warmup runs (per test)</label>
                            <input type="number" id="warmup" value="1" min="0" max="50">
                        </div>
                    </div>
                    <div class="run-mode" id="run-mode">
                        <label class="run-mode-option">
                            <input type="radio" name="run-mode" value="standard" checked onchange="onRunModeChange()">
                            Standard Run (GitHub Actions)
                        </label>
                        <label class="run-mode-option">
                            <input type="radio" name="run-mode" value="local" onchange="onRunModeChange()">
                            Run Locally (WebAssembly)
                        </label>
                    </div>
                    <button class="btn btn-primary" id="run-btn" onclick="runAlgorithm()" disabled>
                        Run Algorithm
                    </button>
                    <button class="btn btn-danger" id="abort-btn" onclick="abortRun()" disabled>
                        Abort Run
                    </button>
                    <button class="btn" onclick="clearOutput()">Clear Output</button>
                </div>

                <div class="progress-area" id="progress-area" hidden>
                    <div class="run-timer" id="run-timer" hidden>Elapsed: 00:00</div>
                    <div class="progress-wrapper" id="progress-wrapper">
                        <div class="progress-meta">
                            <div class="progress-phase" id="progress-phase">Preparing...</div>
                            <div class="progress-count" id="progress-count">0/0</div>
                        </div>
                        <div class="progress-bar" id="progress-bar" role="progressbar" aria-valuemin="0" aria-valuemax="100" aria-valuenow="0">
                            <div class="progress-fill" id="progress-fill"></div>
                        </div>
                    </div>
                </div>
                
                <div style="margin-top: 20px;">
                    <h3 style="margin-bottom: 10px;">Output:</h3>
                    <div class="output-content" id="output">
No output yet. Select an algorithm and input files, then click "Run Algorithm".
                    </div>
                </div>
                <div class="charts" id="charts" hidden>
                    <div class="chart-panel">
                        <div class="chart-title">Runtime (ms)</div>
                        <div class="chart"><canvas id="runtime-chart"></canvas></div>
                    </div>
                    <div class="chart-panel">
                        <div class="chart-title">Memory (kB)</div>
                        <div class="chart"><canvas id="memory-chart"></canvas></div>
                    </div>
                </div>
                <div class="graph-panel graph-panel-small" id="pattern-panel" hidden>
                    <div class="chart-title">Pattern Visualization</div>
                    <div class="graph-note" id="pattern-note"></div>
                    <div class="graph-canvas graph-canvas-small" id="pattern-canvas"></div>
                </div>
                <div class="graph-panel" id="graph-panel" hidden>
                    <div class="chart-title">Graph Visualization</div>
                    <div class="graph-note" id="graph-note"></div>
                    <div class="graph-canvas" id="graph-canvas"></div>
                </div>
            </div>
        </div>
    </div>
    
    <script>
        let config = {
            owner: '',
            repo: '',
            token: '',
            ref: 'main',
            selectedAlgorithm: null,
            selectedFiles: [],
            inputMode: 'generate',
            generator: {
                n: '100',
                k: '10',
                density: '0.01',
                seed: ''
            }
        };

        let dataFileMeta = {};
        const graphMetricCache = new Map();
        let activeRun = null;
        const runTimerState = {
            owner: null,
            startMs: 0,
            intervalId: null
        };
        
        const algorithmConfigs = {
            dijkstra: {
                name: "Dijkstra's Algorithm",
                requiredFiles: 1,
                fileTypes: ['.txt', '.csv', '.grf'],
                instructions: [
                    'Plain text format: first line is the vertex count, second line is "start,target", remaining lines are "u,v,weight" (commas or spaces).',
                    'CSV format: rows contain "source,target,weight"; vertex labels can be names. Add an optional comment line like "# start=A target=D" to choose the endpoints (defaults to the first source and last target).',
                    'When labels are present the reported path will use those labels in the output window.'
                ]
            },
            glasgow: {
                name: "Glasgow Subgraph Solver",
                requiredFiles: 2,
                fileTypes: ['.grf'],
                fileLabels: ['Pattern File', 'Target File']
            },
            vf3: {
                name: "VF3 Algorithm",
                requiredFiles: 2,
                fileTypes: ['.grf'],
                fileLabels: ['Subgraph File', 'Graph File']
            }
        };

        const progressState = {
            requestId: '',
            runSha: '',
            workflowRunId: '',
            stage: 'idle', // 'idle' | 'setup' | 'tests'
            setupTotal: 0,
            testsTotal: 0,
            hasLiveSetup: false,
            total: 0,
            completed: 0,
            phase: ''
        };

        function getTestsPerIteration(algoId) {
            if (algoId === 'dijkstra') return 2;
            if (algoId === 'glasgow') return 3;
            if (algoId === 'vf3') return 3;
            return 0;
        }

        function getProgressEls() {
            return {
                area: document.getElementById('progress-area'),
                wrapper: document.getElementById('progress-wrapper'),
                timer: document.getElementById('run-timer'),
                phase: document.getElementById('progress-phase'),
                count: document.getElementById('progress-count'),
                bar: document.getElementById('progress-bar'),
                fill: document.getElementById('progress-fill')
            };
        }

        function runTimerNowMs() {
            return (window.performance && typeof window.performance.now === 'function')
                ? window.performance.now()
                : Date.now();
        }

        function formatElapsedMs(ms) {
            const totalSeconds = Math.max(0, Math.floor((Number(ms) || 0) / 1000));
            const seconds = totalSeconds % 60;
            const minutesTotal = Math.floor(totalSeconds / 60);
            const minutes = minutesTotal % 60;
            const hours = Math.floor(minutesTotal / 60);

            if (hours > 0) {
                return `${String(hours).padStart(2, '0')}:${String(minutes).padStart(2, '0')}:${String(seconds).padStart(2, '0')}`;
            }
            return `${String(minutes).padStart(2, '0')}:${String(seconds).padStart(2, '0')}`;
        }

        function runTimerSetElapsed(ms) {
            const els = getProgressEls();
            if (!els.timer) return;
            els.timer.textContent = `Elapsed: ${formatElapsedMs(ms)}`;
        }

        function runTimerStart(runCtx) {
            const els = getProgressEls();
            if (!els.timer) return;

            runTimerStop();
            runTimerState.owner = runCtx || null;
            runTimerState.startMs = runTimerNowMs();

            els.timer.hidden = false;
            runTimerSetElapsed(0);

            runTimerState.intervalId = window.setInterval(() => {
                if (runTimerState.owner !== runCtx) return;
                runTimerSetElapsed(runTimerNowMs() - runTimerState.startMs);
            }, 1000);
        }

        function runTimerStop(runCtx = null) {
            if (runCtx && runTimerState.owner !== runCtx) return;
            if (runTimerState.intervalId) {
                clearInterval(runTimerState.intervalId);
                runTimerState.intervalId = null;
            }
        }

        function runTimerReset() {
            runTimerStop();
            runTimerState.owner = null;
            runTimerState.startMs = 0;
            runTimerSetElapsed(0);
            const els = getProgressEls();
            if (els.timer) els.timer.hidden = true;
        }

        function setProgressVisible(visible) {
            const els = getProgressEls();
            if (els.area) {
                els.area.hidden = !visible;
                return;
            }
            if (els.wrapper) {
                els.wrapper.hidden = !visible;
            }
        }

        function progressReset(algoId, iterations, requestId, options = {}) {
            const testsPerIterRaw = options && options.testsPerIter !== undefined ? Number(options.testsPerIter) : NaN;
            const testsPerIter = Number.isFinite(testsPerIterRaw) ? Math.max(0, Math.floor(testsPerIterRaw)) : getTestsPerIteration(algoId);
            const setupTotalRaw = options && options.setupTotal !== undefined ? Number(options.setupTotal) : NaN;
            const setupTotal = Number.isFinite(setupTotalRaw) ? Math.max(1, Math.floor(setupTotalRaw)) : 100;
            const initialPhase = options && typeof options.initialPhase === 'string'
                ? options.initialPhase
                : 'Setting up Testing Environment';
            progressState.requestId = requestId || '';
            progressState.runSha = '';
            progressState.workflowRunId = '';
            progressState.stage = 'setup';
            progressState.setupTotal = setupTotal;
            progressState.testsTotal = Math.max(0, Number(iterations) || 0) * testsPerIter;
            progressState.hasLiveSetup = false;
            progressState.total = progressState.setupTotal;
            progressState.completed = 0;
            progressState.phase = '';

            setProgressVisible(true);
            progressSetDeterminate(initialPhase, 0, progressState.total, { stage: 'setup', reset: true });
        }

        function progressClear() {
            progressState.requestId = '';
            progressState.runSha = '';
            progressState.workflowRunId = '';
            progressState.stage = 'idle';
            progressState.setupTotal = 0;
            progressState.testsTotal = 0;
            progressState.hasLiveSetup = false;
            progressState.total = 0;
            progressState.completed = 0;
            progressState.phase = '';

            const els = getProgressEls();
            if (els.area) {
                els.area.hidden = true;
            } else if (els.wrapper) {
                els.wrapper.hidden = true;
            }
            runTimerReset();
            if (els.fill) els.fill.style.width = '0%';
            if (els.bar) els.bar.setAttribute('aria-valuenow', '0');
            if (els.phase) els.phase.textContent = '';
            if (els.count) els.count.textContent = '';
        }

        function progressSetDeterminate(phaseText, completed, total, options = {}) {
            const els = getProgressEls();

            const prevTotal = Number.isFinite(Number(progressState.total)) ? Number(progressState.total) : 0;
            const prevCompleted = Number.isFinite(Number(progressState.completed)) ? Number(progressState.completed) : 0;
            const prevStage = typeof progressState.stage === 'string' ? progressState.stage : 'idle';
            const nextStage = options && typeof options.stage === 'string' ? options.stage : prevStage;
            const stageChanged = nextStage !== prevStage;
            const shouldReset = !!(options && (options.reset || stageChanged));

            const safeTotal = Math.max(0, Number(total) || 0);
            const effectiveTotal = safeTotal ? safeTotal : (shouldReset ? 0 : prevTotal);
            const requestedCompleted = Math.max(0, Math.min(effectiveTotal || 0, Number(completed) || 0));
            const safeCompleted = shouldReset ? requestedCompleted : Math.max(prevCompleted, requestedCompleted);
            const clampedCompleted = effectiveTotal ? Math.min(effectiveTotal, safeCompleted) : 0;
            const percent = effectiveTotal ? (clampedCompleted / effectiveTotal) * 100 : 0;
            const displayCompleted = Math.floor(clampedCompleted);

            progressState.stage = nextStage;
            progressState.completed = clampedCompleted;
            progressState.total = effectiveTotal;
            progressState.phase = phaseText || '';

            if (els.phase) els.phase.textContent = phaseText || 'Running...';
            if (els.count) els.count.textContent = effectiveTotal ? `${displayCompleted}/${effectiveTotal} (${percent.toFixed(1)}%)` : `${displayCompleted}/0`;
            if (els.fill) els.fill.style.width = `${Math.max(0, Math.min(100, percent))}%`;
            if (els.bar) els.bar.setAttribute('aria-valuenow', String(Math.round(percent)));
        }

        function progressUpdateEstimated(attempt, maxAttempts, phaseText) {
            const total = Number.isFinite(Number(progressState.total)) ? Number(progressState.total) : 0;
            if (!total) {
                progressSetDeterminate(phaseText || 'Running...', 0, 0);
                return;
            }

            const denom = Math.max(1, Number(maxAttempts) || 1);
            const step = Math.min(Math.max(1, Number(attempt) || 1), denom);
            const targetPercent = Math.min(95, (step / denom) * 95);
            const currentPercent = (progressState.completed / total) * 100;
            const percent = Math.max(currentPercent, targetPercent);
            const estimatedCompleted = (percent / 100) * total;
            progressSetDeterminate(phaseText || 'Running...', estimatedCompleted, total);
        }

        function encodePathPreservingSlashes(value) {
            return String(value || '').split('/').map(part => encodeURIComponent(part)).join('/');
        }

        async function getBranchHeadSha(branchRef) {
            const ref = String(branchRef || '').trim();
            if (!ref) return '';

            try {
                const data = await apiRequest(`/git/ref/heads/${encodePathPreservingSlashes(ref)}`);
                if (data && data.object && data.object.sha) return data.object.sha;
            } catch (_) {}

            try {
                const data = await apiRequest(`/commits/${encodePathPreservingSlashes(ref)}`);
                if (data && data.sha) return data.sha;
            } catch (_) {}

            return '';
        }

        async function tryUpdateProgressFromChecks(requestId, runSha) {
            if (!requestId || !runSha) return { updated: false, reason: 'missing' };

            const endpoint = `/commits/${runSha}/check-runs?per_page=100&filter=latest`;

            let data = null;
            let authError = null;
            try {
                data = await apiRequest(endpoint);
            } catch (error) {
                authError = error;
            }

            if (!data) {
                const msg = authError && authError.message ? authError.message : '';
                // If a fine-grained token lacks Checks: Read but the repo is public, retry without auth.
                if (config.token && (msg.includes('403') || msg.includes('401'))) {
                    try {
                        data = await apiRequest(endpoint, 'GET', null, { useAuth: false });
                    } catch (fallbackError) {
                        const fallbackMsg = fallbackError && fallbackError.message ? fallbackError.message : '';
                        if (msg.includes('403') || fallbackMsg.includes('403')) {
                            return { updated: false, reason: 'forbidden' };
                        }
                        return { updated: false, reason: 'error' };
                    }
                } else {
                    if (msg.includes('403')) {
                        return { updated: false, reason: 'forbidden' };
                    }
                    return { updated: false, reason: 'error' };
                }
            }

            const checkRuns = (data && Array.isArray(data.check_runs)) ? data.check_runs : [];
            if (!checkRuns.length) return { updated: false, reason: 'no_check_runs' };

            const match = checkRuns.find(cr => typeof cr.name === 'string' && cr.name.includes(requestId)) ||
                          checkRuns.find(cr => cr.output && typeof cr.output.text === 'string' && cr.output.text.includes(requestId));
            if (!match) return { updated: false, reason: 'not_found' };

            let progress = null;
            if (match.output && typeof match.output.text === 'string') {
                try {
                    progress = JSON.parse(match.output.text);
                } catch (_) {
                    progress = null;
                }
            }

            const runIdRaw = progress && (typeof progress.run_id === 'string' || typeof progress.run_id === 'number')
                ? String(progress.run_id).trim()
                : '';
            if (runIdRaw && /^[0-9]+$/.test(runIdRaw)) {
                progressState.workflowRunId = runIdRaw;
            }

            const completed = progress && Number.isFinite(Number(progress.completed)) ? Number(progress.completed) : 0;
            const total = progress && Number.isFinite(Number(progress.total)) ? Number(progress.total) : (progressState.total || 0);
            const phase = progress && typeof progress.phase === 'string' ? progress.phase : '';

            const stage = progress && typeof progress.stage === 'string' ? progress.stage : '';
            if (stage === 'setup') {
                const setupCompleted = progress && Number.isFinite(Number(progress.setup_completed)) ? Number(progress.setup_completed) : 0;
                const setupTotal = progress && Number.isFinite(Number(progress.setup_total)) ? Number(progress.setup_total) : (progressState.setupTotal || 100);
                progressState.setupTotal = setupTotal || progressState.setupTotal || 100;
                const reset = !progressState.hasLiveSetup;
                progressState.hasLiveSetup = true;
                progressSetDeterminate('Setting up Testing Environment', setupCompleted, setupTotal, { stage: 'setup', reset });
            } else if (stage === 'tests') {
                const testsCompleted = progress && Number.isFinite(Number(progress.tests_completed))
                    ? Number(progress.tests_completed)
                    : completed;
                const testsTotal = progress && Number.isFinite(Number(progress.tests_total))
                    ? Number(progress.tests_total)
                    : total;
                progressState.testsTotal = testsTotal || progressState.testsTotal || 0;
                progressSetDeterminate(phase || 'Running tests...', testsCompleted, testsTotal, { stage: 'tests' });
            } else {
                // Backwards-compatible: treat legacy payload as test progress.
                progressSetDeterminate(phase || 'Running tests...', completed, total, { stage: 'tests' });
            }
            return { updated: true, reason: 'ok' };
        }
        
        function selectAlgorithm(evt, algoId) {
            config.selectedAlgorithm = algoId;
            config.selectedFiles = [];
            
            document.querySelectorAll('.algorithm-card').forEach(card => {
                card.classList.remove('selected');
            });
            if (evt && evt.currentTarget) {
                evt.currentTarget.classList.add('selected');
            }
            
            updateRunButton();
            updateRunInfo();
            updateGeneratorFieldsForAlgorithm();
            
            if (config.owner && config.repo) {
                loadDataFiles();
            }
        }

        function getInputMode() {
            return config.inputMode || 'premade';
        }

        function onInputModeChange() {
            const modeEl = document.getElementById('input-mode');
            const mode = modeEl ? modeEl.value : 'premade';
            config.inputMode = mode;
            if (mode === 'generate') {
                config.selectedFiles = [];
            }
            updateInputModeVisibility();
            updateGeneratorFieldsForAlgorithm();
            updateRunInfo();
            updateRunButton();
        }

        function onRunModeChange() {
            updateInputModeVisibility();
            updateRunButton();
        }

        function updateInputModeVisibility() {
            const mode = getInputMode();
            const form = document.getElementById('generator-form');
            const fileList = document.getElementById('files-content');
            const warning = document.getElementById('generator-warning');
            const note = document.getElementById('generator-disabled-note');
            const runMode = getSelectedRunMode();

            if (form) form.hidden = mode !== 'generate';
            if (fileList) fileList.hidden = mode === 'generate';
            if (warning && mode !== 'generate') warning.hidden = true;
            if (note) note.hidden = !(mode === 'generate' && runMode === 'local');
            updateGeneratorEstimate();
        }

        function onGeneratorInputChange() {
            const nEl = document.getElementById('gen-n');
            const kEl = document.getElementById('gen-k');
            const dEl = document.getElementById('gen-density');
            const seedEl = document.getElementById('gen-seed');
            config.generator.n = nEl ? nEl.value : '';
            config.generator.k = kEl ? kEl.value : '';
            config.generator.density = dEl ? dEl.value : config.generator.density;
            config.generator.seed = seedEl ? seedEl.value : '';
            updateGeneratorEstimate();
            updateRunInfo();
            updateRunButton();
        }

        function updateGeneratorFieldsForAlgorithm() {
            const kGroup = document.getElementById('gen-k-group');
            const warning = document.getElementById('generator-warning');
            if (!kGroup) return;
            const needsK = isGraphPairAlgorithm(config.selectedAlgorithm);
            kGroup.hidden = !needsK;
            if (!needsK && warning) {
                warning.hidden = true;
            }
            updateGeneratorEstimate();
        }
        
        async function connect() {
            const owner = document.getElementById('owner').value.trim();
            const repo = document.getElementById('repo').value.trim();
            const token = document.getElementById('token').value.trim();
            
            if (!owner || !repo) {
                showStatus('Please enter both username/org and repository name', 'error');
                return;
            }
            
            if (!token) {
                showStatus('Personal Access Token is required to run algorithms', 'error');
                return;
            }
            
            config.owner = owner;
            config.repo = repo;
            config.token = token;
            
            try {
                const repoInfo = await apiRequest('');
                if (repoInfo && repoInfo.default_branch) {
                    config.ref = repoInfo.default_branch;
                }
            } catch (e) {
                // default branch fallback already set to 'main'
            }

            showStatus('Connected successfully!', 'success');
            await loadDataFiles();
        }
        
        async function loadDataFiles() {
            const container = document.getElementById('files-content');
            container.innerHTML = '<p class="loading">Loading data files...</p>';
            
            try {
                const ref = config.ref ? `?ref=${encodeURIComponent(config.ref)}` : '';
                let contents;
                try {
                    contents = await apiRequest(`/contents/data${ref}`);
                } catch (error) {
                    const msg = (error && error.message) ? error.message : '';
                    if (config.token && (msg.includes('404') || msg.includes('401') || msg.includes('403'))) {
                        try {
                            contents = await apiRequest(`/contents/data${ref}`, 'GET', null, { useAuth: false });
                        } catch (fallbackError) {
                            throw fallbackError;
                        }
                    } else {
                        throw error;
                    }
                }
                
                let html = '<ul class="file-list">';
                
                const files = Array.isArray(contents) ? contents : [contents];

                dataFileMeta = {};
                files.forEach(item => {
                    if (item && item.type === 'file' && item.path) {
                        dataFileMeta[item.path] = {
                            size: (typeof item.size === 'number') ? item.size : null,
                            sha: item.sha || '',
                            downloadUrl: item.download_url || ''
                        };
                    }
                });
                
                files.forEach(item => {
                    if (item.type === 'file') {
                        const icon = 'ðŸ“„';
                        html += `
                            <li class="file-item" onclick="toggleFileSelection(event, '${item.path}', '${item.name}')">
                                <span class="file-icon">${icon}</span>
                                <span>${item.name}</span>
                            </li>
                        `;
                    }
                });
                
                html += '</ul>';
                container.innerHTML = html;
                
            } catch (error) {
                    reportDebugError('loadDataFiles', error, {
                        owner: config.owner,
                        repo: config.repo,
                        ref: config.ref
                    });
                    let hint = 'Verify the repo has a top-level "data" folder on the selected branch.';
                    let extra = '';
                    const msg = (error && error.message) ? error.message : '';
                    if (msg.includes('401')) {
                        extra = ' (check that your PAT is valid and has repo/workflow scopes; if the repo is public, retry without auth)';
                    }
                    container.innerHTML = `<div class="error">Error loading files: ${escapeHtml(error.message)}${escapeHtml(extra)}<br>${hint}</div>`;
            }
        }
        
        function isGraphPairAlgorithm(algoId) {
            return algoId === 'glasgow' || algoId === 'vf3';
        }

        function parseLeadingIntLine(text) {
            const lines = String(text || '').split(/\r?\n/);
            for (const line of lines) {
                const trimmed = line.trim();
                if (!trimmed || trimmed.startsWith('#')) continue;
                const match = trimmed.match(/^(-?\d+)/);
                if (!match) continue;
                const value = parseInt(match[1], 10);
                if (Number.isFinite(value)) return value;
            }
            return null;
        }

        async function getGraphMetrics(path) {
            const p = String(path || '');
            const ref = String(config.ref || '').trim();
            const cacheKey = `${ref}::${p}`;
            if (graphMetricCache.has(cacheKey)) return graphMetricCache.get(cacheKey);

            const meta = dataFileMeta && dataFileMeta[p] ? dataFileMeta[p] : null;
            const bytes = meta && Number.isFinite(Number(meta.size)) ? Number(meta.size) : null;

            const ext = p.toLowerCase().split('.').pop();
            if (ext !== 'grf' && ext !== 'lad') {
                const result = { nodes: null, bytes };
                graphMetricCache.set(cacheKey, result);
                return result;
            }

            // Avoid pulling content for very large files; fall back to bytes.
            if (bytes && bytes > 1500000) {
                const result = { nodes: null, bytes };
                graphMetricCache.set(cacheKey, result);
                return result;
            }

            try {
                const refParam = ref ? `?ref=${encodeURIComponent(ref)}` : '';
                const file = await apiRequest(`/contents/${encodePathPreservingSlashes(p)}${refParam}`);
                if (file && typeof file.content === 'string' && file.encoding === 'base64') {
                    const decoded = atob(file.content.replace(/\s/g, ''));
                    const nodes = parseLeadingIntLine(decoded);
                    const fallbackBytes = Number.isFinite(Number(file.size)) ? Number(file.size) : null;
                    const resolvedBytes = (bytes !== null && bytes !== undefined) ? bytes : fallbackBytes;
                    const result = { nodes, bytes: resolvedBytes };
                    graphMetricCache.set(cacheKey, result);
                    return result;
                }
            } catch (_) {}

            const result = { nodes: null, bytes };
            graphMetricCache.set(cacheKey, result);
            return result;
        }

        async function normalizeGraphInputOrder(algoId) {
            const id = String(algoId || '');
            if (!isGraphPairAlgorithm(id)) return;
            if (!Array.isArray(config.selectedFiles) || config.selectedFiles.length < 2) return;

            const first = config.selectedFiles[0];
            const second = config.selectedFiles[1];
            if (!first || !second || !first.path || !second.path) return;

            // Guard against races if the user changes selection while we fetch metadata.
            const snapshot = config.selectedFiles.map(f => (f && f.path) ? f.path : '').join(',');
            const [m0, m1] = await Promise.all([getGraphMetrics(first.path), getGraphMetrics(second.path)]);

            if (!isGraphPairAlgorithm(config.selectedAlgorithm)) return;
            if (!Array.isArray(config.selectedFiles) || config.selectedFiles.length < 2) return;
            const current = config.selectedFiles.map(f => (f && f.path) ? f.path : '').join(',');
            if (current !== snapshot) return;

            const n0 = m0 && Number.isFinite(Number(m0.nodes)) ? Number(m0.nodes) : null;
            const n1 = m1 && Number.isFinite(Number(m1.nodes)) ? Number(m1.nodes) : null;
            const b0 = m0 && Number.isFinite(Number(m0.bytes)) ? Number(m0.bytes) : null;
            const b1 = m1 && Number.isFinite(Number(m1.bytes)) ? Number(m1.bytes) : null;

            const shouldSwap = (() => {
                if (n0 !== null && n1 !== null) {
                    if (n0 !== n1) return n0 > n1;
                    if (b0 !== null && b1 !== null && b0 !== b1) return b0 > b1;
                    return false;
                }
                if (b0 !== null && b1 !== null && b0 !== b1) return b0 > b1;
                return false;
            })();

            if (shouldSwap) {
                config.selectedFiles[0] = second;
                config.selectedFiles[1] = first;
            }
        }

        function toggleFileSelection(evt, path, name) {
            if (getInputMode() === 'generate') {
                return;
            }
            const algo = algorithmConfigs[config.selectedAlgorithm];
            if (!algo) {
                showStatus('Please select an algorithm first', 'error');
                return;
            }
            
            const index = config.selectedFiles.findIndex(f => f.path === path);
            
            if (index > -1) {
                config.selectedFiles.splice(index, 1);
                if (evt && evt.currentTarget) {
                    evt.currentTarget.classList.remove('selected');
                }
            } else {
                if (config.selectedFiles.length >= algo.requiredFiles) {
                    showStatus(`This algorithm requires exactly ${algo.requiredFiles} file(s)`, 'error');
                    return;
                }
                config.selectedFiles.push({ path, name });
                if (evt && evt.currentTarget) {
                    evt.currentTarget.classList.add('selected');
                }
            }
            
            updateRunButton();
            updateRunInfo();
            normalizeGraphInputOrder(config.selectedAlgorithm)
                .then(() => updateRunInfo())
                .catch(() => {});
        }
        
        function updateRunButton() {
            const btn = document.getElementById('run-btn');
            const algo = algorithmConfigs[config.selectedAlgorithm];
            if (!btn) return;

            const mode = getInputMode();
            const runMode = getSelectedRunMode();
            let enabled = false;

            if (!algo || !config.token) {
                enabled = false;
            } else if (mode === 'generate') {
                const validation = validateGeneratorInputs();
                const generatorAllowed = runMode !== 'local';
                enabled = validation.valid && generatorAllowed;
            } else {
                enabled = config.selectedFiles.length === algo.requiredFiles;
            }

            btn.disabled = !enabled;
        }

        function validateGeneratorInputs() {
            const warning = document.getElementById('generator-warning');
            const seedWarning = document.getElementById('generator-seed-warning');
            const nEl = document.getElementById('gen-n');
            const kEl = document.getElementById('gen-k');
            const dEl = document.getElementById('gen-density');
            const seedEl = document.getElementById('gen-seed');
            if (nEl) config.generator.n = nEl.value;
            if (kEl) config.generator.k = kEl.value;
            if (dEl) config.generator.density = dEl.value;
            if (seedEl) config.generator.seed = seedEl.value;
            const nValue = parseInt(String(config.generator.n || '').trim(), 10);
            const kValue = parseInt(String(config.generator.k || '').trim(), 10);
            const densityValue = parseFloat(String(config.generator.density || '').trim());
            const seedRaw = String(config.generator.seed || '').trim();
            const needsK = isGraphPairAlgorithm(config.selectedAlgorithm);

            let valid = Number.isFinite(nValue) && nValue >= 2;
            let showKWarning = false;
            let showSeedWarning = false;

            if (needsK) {
                if (!Number.isFinite(kValue) || kValue < 1) {
                    valid = false;
                } else if (Number.isFinite(nValue) && kValue >= nValue) {
                    valid = false;
                    showKWarning = true;
                }
            }
            if (!Number.isFinite(densityValue) || densityValue <= 0 || densityValue > 1) {
                valid = false;
            }
            if (seedRaw && !/^-?\d+$/.test(seedRaw)) {
                valid = false;
                showSeedWarning = true;
            }

            if (warning) {
                warning.hidden = !showKWarning;
            }
            if (seedWarning) {
                seedWarning.hidden = !showSeedWarning;
            }

            return { valid, n: nValue, k: kValue, density: densityValue };
        }
        
        function updateRunInfo() {
            const infoDiv = document.getElementById('run-info');
            const algo = algorithmConfigs[config.selectedAlgorithm];
            
            if (!algo) {
                infoDiv.innerHTML = '<div class="info">Select an algorithm above to get started</div>';
                return;
            }
            
            let html = `<div class="info">
                <strong>Algorithm:</strong> ${algo.name}<br>
                <strong>Required files:</strong> ${algo.requiredFiles}
            `;
            
            if (algo.instructions && algo.instructions.length) {
                html += '<div class="instructions"><strong>File format tips:</strong><ul>';
                html += algo.instructions.map(item => `<li>${escapeHtml(item)}</li>`).join('');
                html += '</ul></div>';
            }

            const mode = getInputMode();
            if (mode === 'generate') {
                const n = String(config.generator.n || '').trim();
                const k = String(config.generator.k || '').trim();
                const density = String(config.generator.density || '').trim();
                let formatHint = '';
                if (config.selectedAlgorithm === 'dijkstra') formatHint = 'CSV (labeled)';
                if (config.selectedAlgorithm === 'glasgow') formatHint = '.lad';
                if (config.selectedAlgorithm === 'vf3') formatHint = '.grf';
                html += `<div class="selected-files"><strong>Generated:</strong> N=${escapeHtml(n || '?')}`;
                if (isGraphPairAlgorithm(config.selectedAlgorithm)) {
                    html += `, k=${escapeHtml(k || '?')}`;
                }
                if (density) {
                    html += `, density=${escapeHtml(density)}`;
                }
                if (formatHint) {
                    html += `, format=${formatHint}`;
                }
                html += '</div>';
            } else if (config.selectedFiles.length > 0) {
                html += '<div class="selected-files"><strong>Selected:</strong> ';
                html += config.selectedFiles.map((f, i) => {
                    const label = algo.fileLabels ? algo.fileLabels[i] : `File ${i+1}`;
                    return `${label}: ${f.name}`;
                }).join(', ');
                html += '</div>';
            }
            
            html += '</div>';
            infoDiv.innerHTML = html;
        }

        function estimateEdgeCount(n, density, directed) {
            const maxEdges = directed ? (n * (n - 1)) : (n * (n - 1)) / 2;
            const targetEdges = Math.round(density * maxEdges);
            return Math.max(n - 1, Math.min(maxEdges, targetEdges));
        }

        function estimateAvgDegree(n, m, directed) {
            if (n <= 0) return 0;
            return directed ? (m / n) : (2 * m / n);
        }

        function estimateHeuristicPerRunMs(algoId, nRaw, kRaw, densityRaw) {
            const n = parseInt(String(nRaw || '').trim(), 10);
            const k = parseInt(String(kRaw || '').trim(), 10);
            const density = parseFloat(String(densityRaw || '').trim());
            if (!Number.isFinite(n) || n <= 1) return '';
            if (!Number.isFinite(density) || density <= 0 || density > 1) return '';

            const isSubgraph = algoId === 'vf3' || algoId === 'glasgow';
            const directed = algoId !== 'glasgow';
            const mTarget = estimateEdgeCount(n, density, directed);
            const avgDegTarget = estimateAvgDegree(n, mTarget, directed);

            let ms = 0;
            if (algoId === 'dijkstra') {
                const ops = (n + mTarget) * Math.log2(n + 1);
                ms = ops * 0.000002;
            } else if (isSubgraph) {
                if (!Number.isFinite(k) || k < 1 || k >= n) return '';
                const mPattern = estimateEdgeCount(k, density, directed);
                const avgDegPattern = estimateAvgDegree(k, mPattern, directed);

                const labelBuckets = algoId === 'vf3' ? 4 : 1;
                const candidateScale = Math.max(2, n / labelBuckets);
                const branchFactor = Math.pow(candidateScale, Math.min(k, 10) / 6);

                const hardness = 0.6 + 1.8 * (1 - Math.abs(2 * density - 1));
                const edgeFactor = 1 + Math.log2(1 + avgDegTarget) * 0.9;
                const patternFactor = 1 + avgDegPattern * 0.8;

                ms = 0.35 * hardness * edgeFactor * patternFactor * branchFactor;
            } else {
                return '';
            }

            if (!Number.isFinite(ms) || ms <= 0) return '';
            return ms;
        }

        function formatDurationMs(ms) {
            const value = Number(ms);
            if (!Number.isFinite(value) || value <= 0) return '';
            const totalSeconds = value / 1000;
            const hours = Math.floor(totalSeconds / 3600);
            const minutes = Math.floor((totalSeconds - hours * 3600) / 60);
            const seconds = totalSeconds - hours * 3600 - minutes * 60;
            return `~${hours}h ${minutes}m ${seconds.toFixed(3)}s`;
        }

        function getTestsPerIteration(algoId) {
            const algo = String(algoId || '');
            if (algo === 'dijkstra') return 2;
            if (algo === 'glasgow' || algo === 'vf3') return 6;
            return 1;
        }

        function readIterationsInput() {
            const iterationsEl = document.getElementById('iterations');
            const raw = iterationsEl ? String(iterationsEl.value || '').trim() : '';
            const parsed = parseInt(raw, 10);
            return Number.isFinite(parsed) && parsed >= 1 ? parsed : 1;
        }

        function readWarmupInput() {
            const warmupEl = document.getElementById('warmup');
            const raw = warmupEl ? String(warmupEl.value || '').trim() : '';
            const parsed = parseInt(raw, 10);
            if (!Number.isFinite(parsed) || parsed < 0) return 0;
            return parsed > 50 ? 50 : parsed;
        }

        function parseSummaryInputs(summary) {
            if (!summary || typeof summary !== 'object') return {};
            const inputs = summary.inputs && typeof summary.inputs === 'object' ? summary.inputs : {};
            return {
                input_mode: inputs.input_mode || summary.input_mode || '',
                n: Number.isFinite(Number(inputs.n)) ? Number(inputs.n) : null,
                k: Number.isFinite(Number(inputs.k)) ? Number(inputs.k) : null,
                density: Number.isFinite(Number(inputs.density)) ? Number(inputs.density) : null,
                input_files: inputs.input_files || summary.input_files || ''
            };
        }

        function extractPerIterationTotalMs(summary) {
            if (!summary || typeof summary !== 'object') return null;
            const algo = String(summary.algorithm || '');
            const timings = summary.timings_ms || {};
            const take = (key) => Number.isFinite(Number(timings[key])) ? Number(timings[key]) : 0;
            let total = 0;
            if (algo === 'dijkstra') {
                if (!Number.isFinite(Number(timings.baseline)) || !Number.isFinite(Number(timings.llm))) {
                    return null;
                }
                total = take('baseline') + take('llm');
            } else if (algo === 'glasgow') {
                const required = ['first','all','gemini_first','gemini_all','chatgpt_first','chatgpt_all'];
                if (required.some(k => !Number.isFinite(Number(timings[k])))) return null;
                total =
                    take('first') + take('all') +
                    take('gemini_first') + take('gemini_all') +
                    take('chatgpt_first') + take('chatgpt_all');
            } else if (algo === 'vf3') {
                const required = ['baseline_first','baseline_all','gemini_first','gemini_all','chatgpt_first','chatgpt_all'];
                if (required.some(k => !Number.isFinite(Number(timings[k])))) return null;
                total =
                    take('baseline_first') + take('baseline_all') +
                    take('gemini_first') + take('gemini_all') +
                    take('chatgpt_first') + take('chatgpt_all');
            }
            return total > 0 ? total : null;
        }

        function scoreHistoryMatch(target, candidate) {
            const dn = Math.abs((candidate.n || 0) - (target.n || 0)) / Math.max(1, target.n || 1);
            const dk = (target.k != null && candidate.k != null)
                ? Math.abs(candidate.k - target.k) / Math.max(1, target.k)
                : 0.5;
            const dd = (target.density != null && candidate.density != null)
                ? Math.abs(candidate.density - target.density) / Math.max(0.01, target.density)
                : 0.5;
            return dn + dk + dd;
        }

        async function fetchHistoricalSummaries(limit = 30) {
            const workflowId = await getRunAlgorithmWorkflowId();
            if (!workflowId) return [];
            let runs = [];
            try {
                runs = await listWorkflowRuns(workflowId, config.ref || 'main', limit);
            } catch (_) {
                return [];
            }
            const summaries = [];
            for (const run of runs) {
                if (!run || !run.id || run.status !== 'completed') continue;
                try {
                    const data = await apiRequest(`/actions/runs/${run.id}/artifacts`);
                    const artifactsRaw = (data && Array.isArray(data.artifacts)) ? data.artifacts : [];
                    const artifacts = artifactsRaw.filter(item => item && !item.expired);
                    const match = artifacts.find(item => item.name === 'algorithm-result');
                    if (!match) continue;
                    const buffer = await downloadArtifactZip(match);
                    const json = await extractResultJsonFromZip(buffer);
                    if (json) summaries.push(json);
                } catch (_) {
                    continue;
                }
                if (summaries.length >= limit) break;
            }
            return summaries;
        }

        async function estimateFromHistory(algoId, nVal, kVal, densityVal) {
            if (!config.token) return null;
            const target = { n: nVal, k: kVal, density: densityVal };
            const summaries = await fetchHistoricalSummaries(40);
            if (!summaries.length) return null;

            const candidates = [];
            for (const summary of summaries) {
                if (!summary || summary.status !== 'success') continue;
                if (String(summary.algorithm || '') !== String(algoId || '')) continue;
                const inputs = parseSummaryInputs(summary);
                if (inputs.input_mode !== 'generate') continue;
                if (!Number.isFinite(inputs.n) || !Number.isFinite(inputs.density)) continue;
                if ((algoId === 'vf3' || algoId === 'glasgow') && !Number.isFinite(inputs.k)) continue;
                const score = scoreHistoryMatch(target, inputs);
                const perIter = extractPerIterationTotalMs(summary);
                if (!Number.isFinite(perIter) || perIter <= 0) continue;
                candidates.push({ score, perIter });
            }

            if (!candidates.length) return null;
            candidates.sort((a, b) => a.score - b.score);
            const top = candidates.slice(0, 5);
            let totalWeight = 0;
            let weighted = 0;
            for (const item of top) {
                const weight = 1 / (1 + item.score);
                weighted += item.perIter * weight;
                totalWeight += weight;
            }
            if (!totalWeight) return null;
            const perIterMs = weighted / totalWeight;
            return { perIterMs, samples: top.length };
        }

        let generatorEstimateRequestId = 0;

        async function updateGeneratorEstimate() {
            const estimateEl = document.getElementById('generator-estimate');
            if (!estimateEl) return;
            if (getInputMode() !== 'generate') {
                estimateEl.hidden = true;
                estimateEl.textContent = '';
                return;
            }
            const nRaw = String(config.generator.n || '').trim();
            const kRaw = String(config.generator.k || '').trim();
            const densityRaw = String(config.generator.density || '').trim();
            const needsK = isGraphPairAlgorithm(config.selectedAlgorithm);

            const hasAnyInput = nRaw !== '' || (needsK && kRaw !== '');
            if (!hasAnyInput) {
                estimateEl.hidden = true;
                estimateEl.textContent = '';
                return;
            }

            const reasons = [];
            const nVal = parseInt(nRaw, 10);
            const kVal = parseInt(kRaw, 10);
            const dVal = parseFloat(densityRaw);

            if (!nRaw) {
                reasons.push('N is required');
            } else if (!Number.isFinite(nVal) || nVal < 2) {
                reasons.push('N must be >= 2');
            }

            if (!densityRaw) {
                reasons.push('Density is required');
            } else if (!Number.isFinite(dVal) || dVal <= 0 || dVal > 1) {
                reasons.push('Density must be between 0 and 1');
            }

            if (needsK) {
                if (!kRaw) {
                    reasons.push('k is required');
                } else if (!Number.isFinite(kVal) || kVal < 1) {
                    reasons.push('k must be >= 1');
                } else if (Number.isFinite(nVal) && kVal >= nVal) {
                    reasons.push('k must be smaller than N');
                }
            }

            if (reasons.length > 0) {
                const reason = reasons[0];
                const perRunLine = `Estimated time per run: N/A (${reason})`;
                const totalLine = `Estimated end-to-end time: N/A (${reason})`;
                estimateEl.innerHTML = `${escapeHtml(perRunLine)}<br>${escapeHtml(totalLine)}`;
                estimateEl.hidden = false;
                return;
            }

            const requestId = ++generatorEstimateRequestId;
            const densityVal = dVal;
            const iterations = readIterationsInput();
            const warmup = readWarmupInput();
            const testsPerIter = getTestsPerIteration(config.selectedAlgorithm);

            const heuristicPerRun = estimateHeuristicPerRunMs(config.selectedAlgorithm, nRaw, kRaw, densityRaw);
            if (!Number.isFinite(heuristicPerRun) || heuristicPerRun <= 0) {
                estimateEl.textContent = '';
                estimateEl.hidden = true;
                return;
            }

            const heuristicPerIter = heuristicPerRun * testsPerIter;
            const roughPerRun = formatDurationMs(heuristicPerRun);
            const roughTotal = formatDurationMs(heuristicPerIter * Math.max(1, (iterations + warmup)));
            const roughRunLine = `Estimated time per run: ${roughPerRun} (rough)`;
            const roughTotalLine = `Estimated end-to-end time: ${roughTotal} (rough)`;
            estimateEl.innerHTML = `${escapeHtml(roughRunLine)}<br>${escapeHtml(roughTotalLine)}`;
            estimateEl.hidden = false;

            if (!config.token) return;

            let perIterMs = null;
            try {
                const history = await estimateFromHistory(config.selectedAlgorithm, nVal, kVal, densityVal);
                if (history && Number.isFinite(history.perIterMs)) {
                    perIterMs = history.perIterMs;
                }
            } catch (_) {}

            if (requestId !== generatorEstimateRequestId) return;
            if (!Number.isFinite(perIterMs) || perIterMs <= 0) return;

            const perRunMs = perIterMs / Math.max(1, testsPerIter);
            const totalMs = perIterMs * Math.max(1, (iterations + warmup));
            const perRunText = formatDurationMs(perRunMs);
            const totalText = formatDurationMs(totalMs);

            const perRunLine = `Estimated time per run: ${perRunText} (fine)`;
            const totalLine = `Estimated end-to-end time: ${totalText} (fine)`;
            estimateEl.innerHTML = `${escapeHtml(perRunLine)}<br>${escapeHtml(totalLine)}`;
            estimateEl.hidden = false;
        }

        function getSelectedRunMode() {
            const selected = document.querySelector('input[name="run-mode"]:checked');
            const raw = selected ? String(selected.value || '').trim().toLowerCase() : 'standard';
            return raw === 'local' ? 'local' : 'standard';
        }

        const localWasmScriptPromises = new Map();
        const localWasmModulePromises = new Map();

        function invalidateEmscriptenModule(id) {
            const key = String(id || '').trim();
            if (!key) return;
            localWasmModulePromises.delete(key);
        }

        function loadScriptOnce(src) {
            const url = String(src || '').trim();
            if (!url) return Promise.reject(new Error('Missing script URL'));
            if (localWasmScriptPromises.has(url)) return localWasmScriptPromises.get(url);

            const promise = new Promise((resolve, reject) => {
                const existing = Array.from(document.querySelectorAll('script[data-capstone-wasm-src]'))
                    .find(el => el && el.dataset && el.dataset.capstoneWasmSrc === url);
                if (existing) {
                    if (existing.dataset && existing.dataset.capstoneWasmLoaded === 'true') {
                        resolve();
                        return;
                    }
                    existing.addEventListener('load', () => resolve(), { once: true });
                    existing.addEventListener('error', () => reject(new Error(`Failed to load script: ${url}`)), { once: true });
                    return;
                }

                const el = document.createElement('script');
                el.src = url;
                el.async = true;
                el.dataset.capstoneWasmSrc = url;
                el.dataset.capstoneWasmLoaded = 'false';
                el.onload = () => {
                    el.dataset.capstoneWasmLoaded = 'true';
                    resolve();
                };
                el.onerror = () => reject(new Error(`Failed to load script: ${url}`));
                document.head.appendChild(el);
            });

            localWasmScriptPromises.set(url, promise);
            return promise;
        }

        function getGitHubAuthHeaderValue() {
            if (!config.token) return '';
            const lower = String(config.token).toLowerCase();
            const useBearer = lower.startsWith('github_pat_') || lower.startsWith('ghs_') || lower.startsWith('ghu_');
            return useBearer ? `Bearer ${config.token}` : `token ${config.token}`;
        }

        function sanitizeFsFilename(name) {
            const raw = String(name || 'file').trim() || 'file';
            return raw
                .replace(/[\\/]/g, '_')
                .replace(/[^a-zA-Z0-9._-]/g, '_')
                .slice(0, 120);
        }

        async function getRepoFileText(path) {
            const p = String(path || '').trim();
            if (!p) throw new Error('Missing file path');
            const ref = String(config.ref || '').trim();
            const refParam = ref ? `?ref=${encodeURIComponent(ref)}` : '';

            // Prefer GitHub Contents API (works for private repos with PAT).
            try {
                const file = await apiRequest(`/contents/${encodePathPreservingSlashes(p)}${refParam}`);
                if (file && typeof file.content === 'string' && file.encoding === 'base64') {
                    return atob(file.content.replace(/\s/g, ''));
                }
                if (file && typeof file.download_url === 'string' && file.download_url) {
                    const auth = getGitHubAuthHeaderValue();
                    const headers = auth ? { Authorization: auth } : {};
                    const resp = await fetch(file.download_url, { headers });
                    if (!resp.ok) throw new Error(`HTTP ${resp.status} fetching ${p}`);
                    return await resp.text();
                }
            } catch (_) {}

            // Fallback: try downloadUrl from cached directory listing.
            const meta = dataFileMeta && dataFileMeta[p] ? dataFileMeta[p] : null;
            if (meta && meta.downloadUrl) {
                const auth = getGitHubAuthHeaderValue();
                const headers = auth ? { Authorization: auth } : {};
                const resp = await fetch(meta.downloadUrl, { headers });
                if (!resp.ok) throw new Error(`HTTP ${resp.status} fetching ${p}`);
                return await resp.text();
            }

            throw new Error(`Failed to load file content: ${p}`);
        }

        async function getEmscriptenModule(spec) {
            const id = String(spec && spec.id ? spec.id : '').trim();
            if (!id) throw new Error('Missing wasm module id');
            if (localWasmModulePromises.has(id)) return localWasmModulePromises.get(id);

            const scriptPath = String(spec && spec.scriptPath ? spec.scriptPath : '').trim();
            const factoryName = String(spec && spec.factoryName ? spec.factoryName : '').trim();
            const wasmPath = String(spec && spec.wasmPath ? spec.wasmPath : '').trim();
            if (!scriptPath || !factoryName || !wasmPath) {
                throw new Error(`Invalid wasm module spec for ${id}`);
            }

            const promise = (async () => {
                if (!('WebAssembly' in window)) {
                    throw new Error('WebAssembly is not supported in this browser.');
                }

                await loadScriptOnce(scriptPath);
                const factory = window[factoryName];
                if (typeof factory !== 'function') {
                    throw new Error(`WASM factory not found: ${factoryName} (did ${scriptPath} load?)`);
                }

                const capture = {
                    out: [],
                    err: [],
                    reset() {
                        this.out.length = 0;
                        this.err.length = 0;
                    }
                };

                const module = await factory({
                    noInitialRun: true,
                    // We call callMain() many times per run; keep the runtime alive between invocations.
                    noExitRuntime: true,
                    locateFile: (path, prefix) => {
                        if (typeof path === 'string' && path.endsWith('.wasm')) {
                            return wasmPath;
                        }
                        return (prefix || '') + path;
                    },
                    print: (text) => capture.out.push(String(text)),
                    printErr: (text) => capture.err.push(String(text))
                });

                if (!module || !module.FS || typeof module.callMain !== 'function') {
                    throw new Error(`WASM module missing FS/callMain: ${id}`);
                }

                module.__capstoneCapture = capture;
                module.__capstoneId = id;
                return module;
            })();

            localWasmModulePromises.set(id, promise);
            return promise;
        }

        async function getFreshEmscriptenModule(spec) {
            const id = String(spec && spec.id ? spec.id : '').trim();
            if (!id) throw new Error('Missing wasm module id');
            invalidateEmscriptenModule(id);
            return await getEmscriptenModule(spec);
        }

        function ensureEmscriptenDir(mod, path) {
            const dir = String(path || '').trim();
            if (!dir) return;
            try {
                mod.FS.mkdir(dir);
            } catch (_) {}
        }

        function writeEmscriptenTextFile(mod, path, text) {
            mod.FS.writeFile(path, String(text || ''), { encoding: 'utf8' });
        }

        function parseFirstLine(text) {
            const raw = String(text || '').replace(/\r/g, '');
            const line = raw.split('\n')[0] || '';
            return line.trim();
        }

        function parseFirstToken(line) {
            const l = String(line || '').trim();
            if (!l) return '';
            return l.split(/\s+/)[0] || '';
        }

        async function runEmscriptenMain(mod, args) {
            const argv = Array.isArray(args) ? args.map(a => String(a)) : [];
            const capture = mod.__capstoneCapture;
            if (!capture) throw new Error('Missing wasm capture');
            capture.reset();

            try {
                mod.callMain(argv);
            } catch (error) {
                // Emscripten may throw an ExitStatus object on exit().
                const status = (error && typeof error.status === 'number') ? error.status : null;
                const stdout = capture.out.join('\n');
                const stderr = capture.err.join('\n');
                if (status === 0) {
                    return {
                        stdout: stdout.trimEnd(),
                        stderr: stderr.trimEnd()
                    };
                }
                const msg = stderr || stdout || (error && error.message ? error.message : String(error));
                if (status !== null) {
                    throw new Error(`WASM program exited with status ${status}: ${msg}`);
                }

                // Runtime traps (e.g., "function signature mismatch") can poison the module instance.
                // Drop it so the next run will recreate a fresh instance.
                try {
                    if (mod && mod.__capstoneId) invalidateEmscriptenModule(mod.__capstoneId);
                } catch (_) {}
                throw error;
            }

            return {
                stdout: capture.out.join('\n').trimEnd(),
                stderr: capture.err.join('\n').trimEnd()
            };
        }

        function calcStatsMs(values) {
            const vals = (Array.isArray(values) ? values : [])
                .map(v => Number(v))
                .filter(v => Number.isFinite(v));
            if (!vals.length) return null;

            const sorted = vals.slice().sort((a, b) => a - b);
            const n = sorted.length;
            const mean = sorted.reduce((s, v) => s + v, 0) / n;
            const median = (n % 2 === 1)
                ? sorted[(n - 1) / 2]
                : (sorted[n / 2 - 1] + sorted[n / 2]) / 2;
            const stdev = (n > 1)
                ? Math.sqrt(sorted.reduce((s, v) => s + Math.pow(v - mean, 2), 0) / (n - 1))
                : 0;
            const min = sorted[0];
            const max = sorted[n - 1];
            return { n, mean, median, stdev, min, max };
        }

        function formatStatsMsFirstAll(prefix, firstStats, allStats) {
            const pfx = String(prefix || '');
            const indent = ' '.repeat(pfx.length);
            const fmt = (v) => Number(v).toFixed(3).padStart(10);
            const line = (lead, label, s) => `${lead}${String(label).padEnd(5)} median=${fmt(s.median)} mean=${fmt(s.mean)} stdev=${fmt(s.stdev)} min=${fmt(s.min)} max=${fmt(s.max)}`;
            return [
                line(pfx, 'first', firstStats),
                line(indent, 'all', allStats)
            ];
        }

        function formatStatsMsSummary(prefix, stats) {
            if (!stats) return '';
            const pfx = String(prefix || '');
            const fmt = (v) => Number(v).toFixed(3);
            return `${pfx}median=${fmt(stats.median)} mean=${fmt(stats.mean)} stdev=${fmt(stats.stdev)} min=${fmt(stats.min)} max=${fmt(stats.max)}`;
        }

        async function runDijkstraLocally(runCtx, iterations, warmup) {
            const safeWarmup = Math.max(0, Math.floor(Number(warmup) || 0));
            const safeIterations = Math.max(1, Math.floor(Number(iterations) || 0));

            const inputFile = (config.selectedFiles && config.selectedFiles[0]) ? config.selectedFiles[0] : null;
            if (!inputFile || !inputFile.path) {
                throw new Error('Dijkstra requires one input file');
            }

            const ticksPerIter = 2; // baseline + llm
            const setupTotal = Math.max(1, safeWarmup * ticksPerIter);
            const testsTotal = safeIterations * ticksPerIter;

            progressReset('dijkstra', safeIterations, runCtx.requestId, {
                setupTotal,
                testsPerIter: ticksPerIter
            });

            const inputName = sanitizeFsFilename(inputFile.name || 'input');
            const inputFsPath = `/inputs/${inputName}`;

            const inputText = await getRepoFileText(inputFile.path);
            if (runCtx && runCtx.aborted) return { status: 'aborted', error: 'Run Aborted' };

            const baselineSpec = {
                id: 'dijkstra_baseline',
                scriptPath: 'wasm/dijkstra_baseline.js',
                wasmPath: 'wasm/dijkstra_baseline.wasm',
                factoryName: 'createDijkstraBaselineModule'
            };
            const llmSpec = {
                id: 'dijkstra_llm',
                scriptPath: 'wasm/dijkstra_llm.js',
                wasmPath: 'wasm/dijkstra_llm.wasm',
                factoryName: 'createDijkstraLlmModule'
            };

            const abortSignal = runCtx && runCtx.abortController ? runCtx.abortController.signal : null;

            const writeInput = (mod) => {
                ensureEmscriptenDir(mod, '/inputs');
                writeEmscriptenTextFile(mod, inputFsPath, inputText);
            };

            const unloadModule = (spec) => {
                try {
                    invalidateEmscriptenModule(spec && spec.id ? spec.id : '');
                } catch (_) {}
            };

            const loadFreshModule = async (spec) => {
                const mod = await getFreshEmscriptenModule(spec);
                writeInput(mod);
                return mod;
            };

            try {
                // Phase 1: setup + warmup (progress bar fills once)
                if (safeWarmup > 0) {
                    let setupDone = 0;

                    // Baseline warmups
                    let mod = await loadFreshModule(baselineSpec);
                    try {
                        for (let i = 0; i < safeWarmup; i++) {
                            if (runCtx && runCtx.aborted) return { status: 'aborted', error: 'Run Aborted' };
                            progressSetDeterminate('Warming up: Dijkstra baseline', setupDone, setupTotal, { stage: 'setup' });
                            try {
                                await runEmscriptenMain(mod, [inputFsPath]);
                            } catch (error) {
                                const msg = error && error.message ? error.message : String(error);
                                throw new Error(`Warmup ${i + 1}/${safeWarmup} - Dijkstra baseline: ${msg}`);
                            }
                            setupDone++;
                            progressSetDeterminate('Warming up: Dijkstra baseline', setupDone, setupTotal, { stage: 'setup' });
                            await delay(0, abortSignal);
                        }
                    } finally {
                        mod = null;
                        unloadModule(baselineSpec);
                    }

                    // LLM warmups
                    mod = await loadFreshModule(llmSpec);
                    try {
                        for (let i = 0; i < safeWarmup; i++) {
                            if (runCtx && runCtx.aborted) return { status: 'aborted', error: 'Run Aborted' };
                            progressSetDeterminate('Warming up: Dijkstra llm', setupDone, setupTotal, { stage: 'setup' });
                            try {
                                await runEmscriptenMain(mod, [inputFsPath]);
                            } catch (error) {
                                const msg = error && error.message ? error.message : String(error);
                                throw new Error(`Warmup ${i + 1}/${safeWarmup} - Dijkstra llm: ${msg}`);
                            }
                            setupDone++;
                            progressSetDeterminate('Warming up: Dijkstra llm', setupDone, setupTotal, { stage: 'setup' });
                            await delay(0, abortSignal);
                        }
                    } finally {
                        mod = null;
                        unloadModule(llmSpec);
                    }
                } else {
                    // Still complete the setup phase so the bar fills once.
                    progressSetDeterminate('Setting up Testing Environment', setupTotal, setupTotal, { stage: 'setup' });
                }

                // Phase 2: measured iterations (bar resets and fills again)
                progressSetDeterminate('Running tests...', 0, testsTotal, { stage: 'tests', reset: true });

                let ticksDone = 0;

                const baselineTimes = [];
                const llmTimes = [];
                let baselineResult = '';
                let llmResult = '';

                // Baseline chunk
                let mod = await loadFreshModule(baselineSpec);
                try {
                    for (let iter = 0; iter < safeIterations; iter++) {
                        if (runCtx && runCtx.aborted) return { status: 'aborted', error: 'Run Aborted' };
                        progressSetDeterminate('Dijkstra baseline', ticksDone, testsTotal, { stage: 'tests' });
                        const t0 = runTimerNowMs();
                        let stdout = '';
                        try {
                            const res = await runEmscriptenMain(mod, [inputFsPath]);
                            stdout = res && typeof res.stdout === 'string' ? res.stdout : '';
                        } catch (error) {
                            const msg = error && error.message ? error.message : String(error);
                            throw new Error(`Iteration ${iter + 1}/${safeIterations} - Dijkstra baseline: ${msg}`);
                        }
                        const t1 = runTimerNowMs();
                        baselineTimes.push(Math.max(0, t1 - t0));
                        baselineResult = parseFirstLine(stdout) || stdout.trim();
                        ticksDone++;
                        progressSetDeterminate('Dijkstra baseline', ticksDone, testsTotal, { stage: 'tests' });
                        await delay(0, abortSignal);
                    }
                } finally {
                    mod = null;
                    unloadModule(baselineSpec);
                }

                // LLM chunk
                mod = await loadFreshModule(llmSpec);
                try {
                    for (let iter = 0; iter < safeIterations; iter++) {
                        if (runCtx && runCtx.aborted) return { status: 'aborted', error: 'Run Aborted' };
                        progressSetDeterminate('Dijkstra llm', ticksDone, testsTotal, { stage: 'tests' });
                        const t0 = runTimerNowMs();
                        let stdout = '';
                        try {
                            const res = await runEmscriptenMain(mod, [inputFsPath]);
                            stdout = res && typeof res.stdout === 'string' ? res.stdout : '';
                        } catch (error) {
                            const msg = error && error.message ? error.message : String(error);
                            throw new Error(`Iteration ${iter + 1}/${safeIterations} - Dijkstra llm: ${msg}`);
                        }
                        const t1 = runTimerNowMs();
                        llmTimes.push(Math.max(0, t1 - t0));
                        llmResult = parseFirstLine(stdout) || stdout.trim();
                        ticksDone++;
                        progressSetDeterminate('Dijkstra llm', ticksDone, testsTotal, { stage: 'tests' });
                        await delay(0, abortSignal);
                    }
                } finally {
                    mod = null;
                    unloadModule(llmSpec);
                }

                progressSetDeterminate('Completed', testsTotal, testsTotal, { stage: 'tests' });

                const sBaseline = calcStatsMs(baselineTimes);
                const sLlm = calcStatsMs(llmTimes);

                const lines = [];
                const addSection = (title, result, stats) => {
                    lines.push(`[${title}]`);
                    lines.push(result || '(No output)');
                    lines.push(`Warmup: ${safeWarmup}`);
                    lines.push(`Iterations: ${safeIterations}`);
                    if (stats) {
                        lines.push(formatStatsMsSummary('Runtime (ms): ', stats));
                    }
                    lines.push('');
                };

                addSection('Dijkstra Baseline', baselineResult, sBaseline);
                addSection('Dijkstra LLM', llmResult, sLlm);

                return { status: 'success', output: lines.join('\n') };
            } finally {
                unloadModule(baselineSpec);
                unloadModule(llmSpec);
            }
        }

        async function runVf3Locally(runCtx, iterations, warmup) {
            const safeWarmup = Math.max(0, Math.floor(Number(warmup) || 0));
            const safeIterations = Math.max(1, Math.floor(Number(iterations) || 0));

            const patternFile = (config.selectedFiles && config.selectedFiles[0]) ? config.selectedFiles[0] : null;
            const targetFile = (config.selectedFiles && config.selectedFiles[1]) ? config.selectedFiles[1] : null;
            if (!patternFile || !targetFile || !patternFile.path || !targetFile.path) {
                throw new Error('VF3 requires a pattern and target file');
            }

            const ticksPerIter = 6; // baseline first/all + gemini first/all + chatgpt first/all
            const setupTotal = Math.max(1, safeWarmup * ticksPerIter);
            const testsTotal = safeIterations * ticksPerIter;

            progressReset('vf3', safeIterations, runCtx.requestId, {
                setupTotal,
                testsPerIter: ticksPerIter
            });

            const patternName = sanitizeFsFilename(patternFile.name || 'pattern');
            const targetName = sanitizeFsFilename(targetFile.name || 'target');
            const patternFsPath = `/inputs/${patternName}`;
            const targetFsPath = `/inputs/${targetName}`;

            const [patternText, targetText] = await Promise.all([
                getRepoFileText(patternFile.path),
                getRepoFileText(targetFile.path)
            ]);
            if (runCtx && runCtx.aborted) return { status: 'aborted', error: 'Run Aborted' };

            const baselineSpec = {
                id: 'vf3_baseline',
                scriptPath: 'wasm/vf3_baseline.js',
                wasmPath: 'wasm/vf3_baseline.wasm',
                factoryName: 'createVf3BaselineModule'
            };
            const geminiSpec = {
                id: 'vf3_gemini',
                scriptPath: 'wasm/vf3_gemini.js',
                wasmPath: 'wasm/vf3_gemini.wasm',
                factoryName: 'createVf3GeminiModule'
            };
            const chatgptSpec = {
                id: 'vf3_chatgpt',
                scriptPath: 'wasm/vf3_chatgpt.js',
                wasmPath: 'wasm/vf3_chatgpt.wasm',
                factoryName: 'createVf3ChatgptModule'
            };

            const writeInputs = (mod) => {
                ensureEmscriptenDir(mod, '/inputs');
                writeEmscriptenTextFile(mod, patternFsPath, patternText);
                writeEmscriptenTextFile(mod, targetFsPath, targetText);
            };

            // IMPORTANT: these compiled WASM programs are invoked via `callMain()`. If the underlying C++
            // code has leaks/UB, long in-process runs can eventually trap. For stability and clarity, run
            // each solver in its own chunk (baseline -> Gemini -> ChatGPT) and periodically recreate the
            // baseline module during its chunk.
            const baselineRecycleEveryIterations = 50;
            const abortSignal = runCtx && runCtx.abortController ? runCtx.abortController.signal : null;

            const unloadModule = (spec) => {
                try {
                    invalidateEmscriptenModule(spec && spec.id ? spec.id : '');
                } catch (_) {}
            };

            const loadFreshModule = async (spec, label, done, total, stage) => {
                if (label) {
                    const current = Number.isFinite(Number(done)) ? Number(done) : 0;
                    const denom = Number.isFinite(Number(total)) ? Number(total) : 1;
                    progressSetDeterminate(label, current, Math.max(1, denom), { stage });
                }
                const mod = await getFreshEmscriptenModule(spec);
                writeInputs(mod);
                return mod;
            };

            try {
                const warmupSolver = async (title, spec, labelFirst, argsFirst, labelAll, argsAll, setupDoneRef) => {
                    let mod = await loadFreshModule(spec, `Loading ${title} WASM...`, setupDoneRef.value, setupTotal, 'setup');
                    try {
                        for (let i = 0; i < safeWarmup; i++) {
                            const steps = [
                                { label: labelFirst, args: argsFirst },
                                { label: labelAll, args: argsAll }
                            ];
                            for (const step of steps) {
                                if (runCtx && runCtx.aborted) return;
                                progressSetDeterminate(`Warming up: ${title}`, setupDoneRef.value, setupTotal, { stage: 'setup' });
                                try {
                                    await runEmscriptenMain(mod, step.args);
                                } catch (error) {
                                    const msg = error && error.message ? error.message : String(error);
                                    throw new Error(`Warmup ${i + 1}/${safeWarmup} - ${step.label}: ${msg}`);
                                }
                                setupDoneRef.value++;
                                progressSetDeterminate(`Warming up: ${title}`, setupDoneRef.value, setupTotal, { stage: 'setup' });
                                await delay(0, abortSignal);
                            }
                        }
                    } finally {
                        mod = null;
                        unloadModule(spec);
                    }
                };

                // Phase 1: setup + warmup (progress bar fills once)
                if (safeWarmup > 0) {
                    const setupDoneRef = { value: 0 };
                    await warmupSolver(
                        'VF3 baseline',
                        baselineSpec,
                        'VF3 baseline first',
                        ['-r', '0', '-F', patternFsPath, targetFsPath],
                        'VF3 baseline all',
                        ['-r', '0', patternFsPath, targetFsPath],
                        setupDoneRef
                    );
                    await warmupSolver(
                        'VF3 Gemini',
                        geminiSpec,
                        'VF3 Gemini first',
                        ['--first-only', patternFsPath, targetFsPath],
                        'VF3 Gemini all',
                        [patternFsPath, targetFsPath],
                        setupDoneRef
                    );
                    await warmupSolver(
                        'VF3 ChatGPT',
                        chatgptSpec,
                        'VF3 ChatGPT first',
                        ['--first-only', patternFsPath, targetFsPath],
                        'VF3 ChatGPT all',
                        [patternFsPath, targetFsPath],
                        setupDoneRef
                    );
                    if (runCtx && runCtx.aborted) return { status: 'aborted', error: 'Run Aborted' };
                } else {
                    // Still complete the setup phase so the bar fills once.
                    progressSetDeterminate('Setting up Testing Environment', setupTotal, setupTotal, { stage: 'setup', reset: true });
                }

                // Phase 2: measured iterations (bar resets and fills again)
                progressSetDeterminate('Running tests...', 0, testsTotal, { stage: 'tests', reset: true });

                const baseFirst = [];
                const baseAll = [];
                const gemFirst = [];
                const gemAll = [];
                const chatFirst = [];
                const chatAll = [];
                let baseResult = '';
                let gemResult = '';
                let chatResult = '';

                let ticksDone = 0;

                const runMeasuredSolver = async (opts) => {
                    const title = String(opts && opts.title ? opts.title : 'Solver');
                    const spec = opts && opts.spec ? opts.spec : null;
                    const labelFirst = String(opts && opts.labelFirst ? opts.labelFirst : 'first');
                    const argsFirst = Array.isArray(opts && opts.argsFirst ? opts.argsFirst : null) ? opts.argsFirst : [];
                    const labelAll = String(opts && opts.labelAll ? opts.labelAll : 'all');
                    const argsAll = Array.isArray(opts && opts.argsAll ? opts.argsAll : null) ? opts.argsAll : [];
                    const timesFirst = Array.isArray(opts && opts.timesFirst ? opts.timesFirst : null) ? opts.timesFirst : null;
                    const timesAll = Array.isArray(opts && opts.timesAll ? opts.timesAll : null) ? opts.timesAll : null;
                    const captureAll = typeof (opts && opts.captureAll) === 'function' ? opts.captureAll : null;
                    const recycleEvery = Math.max(0, Math.floor(Number(opts && opts.recycleEveryIterations ? opts.recycleEveryIterations : 0)));

                    if (!spec || !spec.id) throw new Error(`Invalid wasm spec for ${title}`);
                    if (!timesFirst || !timesAll) throw new Error(`Invalid timing arrays for ${title}`);

                    let mod = await loadFreshModule(spec, `Loading ${title} WASM...`, ticksDone, testsTotal, 'tests');

                    const isTrapError = (error) => {
                        const msg = error && error.message ? String(error.message) : String(error);
                        const lower = msg.toLowerCase();
                        return lower.includes('function signature mismatch') ||
                            lower.includes('memory access out of bounds') ||
                            lower.includes('out of bounds memory access') ||
                            lower.includes('unreachable');
                    };

                    const runStepMeasured = async (iter, stepLabel, args, times, captureStdout = null) => {
                        for (let attempt = 0; attempt < 2; attempt++) {
                            if (runCtx && runCtx.aborted) return { status: 'aborted', error: 'Run Aborted' };
                            const t0 = runTimerNowMs();
                            try {
                                const res = await runEmscriptenMain(mod, args);
                                const t1 = runTimerNowMs();
                                times.push(Math.max(0, t1 - t0));
                                if (captureStdout) {
                                    const stdout = res && typeof res.stdout === 'string' ? res.stdout : '';
                                    try { captureStdout(stdout); } catch (_) {}
                                }
                                return null;
                            } catch (error) {
                                const msg = error && error.message ? error.message : String(error);
                                const canRecover = isTrapError(error) && attempt === 0;
                                if (!canRecover) {
                                    throw new Error(`Iteration ${iter + 1}/${safeIterations} - ${stepLabel}: ${msg}`);
                                }

                                mod = null;
                                unloadModule(spec);
                                await delay(0, abortSignal);
                                if (runCtx && runCtx.aborted) return { status: 'aborted', error: 'Run Aborted' };
                                mod = await loadFreshModule(spec, `Recovering ${title} WASM...`, ticksDone, testsTotal, 'tests');
                            }
                        }
                        return null;
                    };
                    try {
                        for (let iter = 0; iter < safeIterations; iter++) {
                            if (runCtx && runCtx.aborted) return { status: 'aborted', error: 'Run Aborted' };

                            if (recycleEvery > 0 && iter > 0 && (iter % recycleEvery) === 0) {
                                mod = null;
                                unloadModule(spec);
                                await delay(0, abortSignal);
                                if (runCtx && runCtx.aborted) return { status: 'aborted', error: 'Run Aborted' };
                                mod = await loadFreshModule(spec, `Refreshing ${title} WASM (${iter}/${safeIterations})...`, ticksDone, testsTotal, 'tests');
                            }

                            progressSetDeterminate(title, ticksDone, testsTotal, { stage: 'tests' });
                            const firstRes = await runStepMeasured(iter, labelFirst, argsFirst, timesFirst);
                            if (firstRes && firstRes.status === 'aborted') return firstRes;
                            ticksDone++;
                            progressSetDeterminate(title, ticksDone, testsTotal, { stage: 'tests' });
                            await delay(0, abortSignal);

                            if (runCtx && runCtx.aborted) return { status: 'aborted', error: 'Run Aborted' };

                            progressSetDeterminate(title, ticksDone, testsTotal, { stage: 'tests' });
                            const allRes = await runStepMeasured(iter, labelAll, argsAll, timesAll, captureAll);
                            if (allRes && allRes.status === 'aborted') return allRes;
                            ticksDone++;
                            progressSetDeterminate(title, ticksDone, testsTotal, { stage: 'tests' });
                            await delay(0, abortSignal);
                        }
                    } finally {
                        mod = null;
                        unloadModule(spec);
                    }
                    return null;
                };

                const baselineRun = await runMeasuredSolver({
                    title: 'VF3 baseline',
                    spec: baselineSpec,
                    labelFirst: 'VF3 baseline first',
                    argsFirst: ['-r', '0', '-F', patternFsPath, targetFsPath],
                    labelAll: 'VF3 baseline all',
                    argsAll: ['-r', '0', patternFsPath, targetFsPath],
                    timesFirst: baseFirst,
                    timesAll: baseAll,
                    recycleEveryIterations: baselineRecycleEveryIterations,
                    captureAll: (stdout) => {
                        const line = parseFirstLine(stdout);
                        baseResult = parseFirstToken(line) || line;
                    }
                });
                if (baselineRun && baselineRun.status === 'aborted') return baselineRun;

                const geminiRun = await runMeasuredSolver({
                    title: 'VF3 Gemini',
                    spec: geminiSpec,
                    labelFirst: 'VF3 Gemini first',
                    argsFirst: ['--first-only', patternFsPath, targetFsPath],
                    labelAll: 'VF3 Gemini all',
                    argsAll: [patternFsPath, targetFsPath],
                    timesFirst: gemFirst,
                    timesAll: gemAll,
                    recycleEveryIterations: safeIterations >= 250 ? 200 : 0,
                    captureAll: (stdout) => {
                        gemResult = parseFirstLine(stdout);
                    }
                });
                if (geminiRun && geminiRun.status === 'aborted') return geminiRun;

                const chatgptRun = await runMeasuredSolver({
                    title: 'VF3 ChatGPT',
                    spec: chatgptSpec,
                    labelFirst: 'VF3 ChatGPT first',
                    argsFirst: ['--first-only', patternFsPath, targetFsPath],
                    labelAll: 'VF3 ChatGPT all',
                    argsAll: [patternFsPath, targetFsPath],
                    timesFirst: chatFirst,
                    timesAll: chatAll,
                    recycleEveryIterations: safeIterations >= 250 ? 200 : 0,
                    captureAll: (stdout) => {
                        chatResult = parseFirstLine(stdout);
                    }
                });
                if (chatgptRun && chatgptRun.status === 'aborted') return chatgptRun;

                progressSetDeterminate('Completed', testsTotal, testsTotal, { stage: 'tests' });

                const sBaseFirst = calcStatsMs(baseFirst);
                const sBaseAll = calcStatsMs(baseAll);
                const sGemFirst = calcStatsMs(gemFirst);
                const sGemAll = calcStatsMs(gemAll);
                const sChatFirst = calcStatsMs(chatFirst);
                const sChatAll = calcStatsMs(chatAll);

                const lines = [];
                const addSection = (title, result, firstStats, allStats) => {
                    lines.push(`[${title}]`);
                    lines.push(result || '(No output)');
                    lines.push(`Warmup: ${safeWarmup}`);
                    lines.push(`Iterations: ${safeIterations}`);
                    if (firstStats && allStats) {
                        lines.push(...formatStatsMsFirstAll('Runtime (ms): ', firstStats, allStats));
                    }
                    lines.push('');
                };

                addSection('VF3 baseline', baseResult, sBaseFirst, sBaseAll);
                addSection('VF3 Gemini', gemResult, sGemFirst, sGemAll);
                addSection('VF3 ChatGPT', chatResult, sChatFirst, sChatAll);

                return { status: 'success', output: lines.join('\n') };
            } finally {
                // Drop cached modules at the end of each local run to keep memory stable between runs.
                try { invalidateEmscriptenModule(baselineSpec.id); } catch (_) {}
                try { invalidateEmscriptenModule(geminiSpec.id); } catch (_) {}
                try { invalidateEmscriptenModule(chatgptSpec.id); } catch (_) {}
            }
        }

        let localWasmKernelPromise = null;
        async function getLocalWasmKernel() {
            if (localWasmKernelPromise) return localWasmKernelPromise;
            localWasmKernelPromise = (async () => {
                if (!('WebAssembly' in window)) {
                    throw new Error('WebAssembly is not supported in this browser.');
                }

                // Minimal WASM module exporting `work(n: i32) -> i32`.
                // Used as a lightweight local runner kernel (warmups + iterations) without GitHub Actions.
                const bytes = new Uint8Array([
                    0x00, 0x61, 0x73, 0x6d, 0x01, 0x00, 0x00, 0x00,
                    0x01, 0x06, 0x01, 0x60, 0x01, 0x7f, 0x01, 0x7f,
                    0x03, 0x02, 0x01, 0x00,
                    0x07, 0x08, 0x01, 0x04, 0x77, 0x6f, 0x72, 0x6b, 0x00, 0x00,
                    0x0a, 0x2d, 0x01, 0x2b, 0x01, 0x02, 0x7f,
                    0x41, 0x00, 0x21, 0x01,
                    0x41, 0x00, 0x21, 0x02,
                    0x02, 0x40,
                    0x03, 0x40,
                    0x20, 0x01,
                    0x20, 0x00,
                    0x4f,
                    0x0d, 0x01,
                    0x20, 0x02,
                    0x20, 0x01,
                    0x6a,
                    0x21, 0x02,
                    0x20, 0x01,
                    0x41, 0x01,
                    0x6a,
                    0x21, 0x01,
                    0x0c, 0x00,
                    0x0b,
                    0x0b,
                    0x20, 0x02,
                    0x0b
                ]);

                const { instance } = await WebAssembly.instantiate(bytes);
                if (!instance || !instance.exports || typeof instance.exports.work !== 'function') {
                    throw new Error('Failed to initialize local WebAssembly runner.');
                }
                return instance.exports;
            })();
            return localWasmKernelPromise;
        }

        function computeLocalWorkN(algoId, unitIndex, fileMetaList = []) {
            const unit = Math.max(0, Number(unitIndex) || 0);
            const algo = String(algoId || '');
            const bytes = Array.isArray(fileMetaList)
                ? fileMetaList.reduce((sum, m) => sum + (Number.isFinite(Number(m && m.bytes)) ? Number(m.bytes) : 0), 0)
                : 0;

            const algoFactor = algo === 'vf3' ? 3 : (algo === 'glasgow' ? 2 : 1);
            const base = Math.max(25000, Math.min(2500000, Math.floor(bytes / 3)));
            return base * algoFactor * (1 + (unit % 3));
        }

        async function runAlgorithmLocally(runCtx, algoId, iterations, warmup) {
            const algoKey = String(algoId || '');
            if (algoKey === 'vf3') {
                try {
                    return await runVf3Locally(runCtx, iterations, warmup);
                } catch (error) {
                    const msg = error && error.message ? error.message : String(error);
                    if (msg.includes('Failed to load script') || msg.includes('WASM factory not found')) {
                        throw new Error('Local WASM modules not found. Run the "Build WASM Modules" workflow to generate them.');
                    }
                    throw error;
                }
            }

            if (algoKey === 'dijkstra') {
                try {
                    return await runDijkstraLocally(runCtx, iterations, warmup);
                } catch (error) {
                    const msg = error && error.message ? error.message : String(error);
                    if (msg.includes('Failed to load script') || msg.includes('WASM factory not found')) {
                        throw new Error('Local WASM modules not found. Run the "Build WASM Modules" workflow to generate them.');
                    }
                    throw error;
                }
            }

            const kernel = await getLocalWasmKernel();
            const testsPerIter = getTestsPerIteration(algoId);
            const setupTotal = Math.max(1, 1 + (Math.max(0, Number(warmup) || 0) * testsPerIter));

            const metaList = (config.selectedFiles || []).map(f => {
                const m = dataFileMeta && f && f.path && dataFileMeta[f.path] ? dataFileMeta[f.path] : null;
                return { path: f && f.path ? String(f.path) : '', bytes: m && Number.isFinite(Number(m.size)) ? Number(m.size) : 0 };
            });

            let setupDone = 0;
            const safeWarmup = Math.max(0, Math.floor(Number(warmup) || 0));
            const safeIterations = Math.max(0, Math.floor(Number(iterations) || 0));
            const testsTotal = safeIterations * testsPerIter;
            const localStartMs = runTimerNowMs();

            progressReset(algoId, safeIterations, runCtx.requestId, {
                setupTotal,
                testsPerIter
            });

            setupDone = 1;
            progressSetDeterminate('Setting up Testing Environment', setupDone, setupTotal, { stage: 'setup', reset: true });

            // Warmup phase (fills the bar the first time)
            let warmupUnitsDone = 0;
            for (let i = 0; i < safeWarmup; i++) {
                for (let unit = 0; unit < testsPerIter; unit++) {
                    if (runCtx && runCtx.aborted) return { status: 'aborted', error: 'Run Aborted' };
                    kernel.work(computeLocalWorkN(algoId, unit, metaList));
                    warmupUnitsDone++;
                    const completed = Math.min(setupTotal, 1 + warmupUnitsDone);
                    if (completed !== setupDone) {
                        setupDone = completed;
                        progressSetDeterminate('Warming up...', setupDone, setupTotal, { stage: 'setup' });
                    }
                    if ((warmupUnitsDone % 25) === 0) {
                        await delay(0, runCtx && runCtx.abortController ? runCtx.abortController.signal : null);
                    }
                }
            }

            // Tests phase (reset to 0% and fill again)
            progressSetDeterminate('Running tests...', 0, testsTotal, { stage: 'tests', reset: true });
            let testsDone = 0;
            for (let iter = 0; iter < safeIterations; iter++) {
                for (let unit = 0; unit < testsPerIter; unit++) {
                    if (runCtx && runCtx.aborted) return { status: 'aborted', error: 'Run Aborted' };
                    kernel.work(computeLocalWorkN(algoId, unit, metaList));
                    testsDone++;
                    if ((testsDone % 10) === 0 || testsDone === testsTotal) {
                        progressSetDeterminate('Running tests...', testsDone, testsTotal, { stage: 'tests' });
                    }
                    if ((testsDone % 50) === 0) {
                        await delay(0, runCtx && runCtx.abortController ? runCtx.abortController.signal : null);
                    }
                }
            }

            const localElapsedMs = runTimerNowMs() - localStartMs;
            progressSetDeterminate('Completed', testsTotal, testsTotal, { stage: 'tests' });

            return {
                status: 'success',
                output: [
                    `[${algoId.toUpperCase()} Local]`,
                    `Warmup: ${safeWarmup}`,
                    `Iterations: ${safeIterations}`,
                    `Runtime (ms): ${Math.max(0, localElapsedMs).toFixed(1)}`,
                    `Work units: ${testsTotal}`,
                    '',
                    'Note: Local mode currently runs a lightweight WebAssembly kernel for quick UI testing.'
                ].join('\n')
            };
        }

        async function runAlgorithm() {
            const outputDiv = document.getElementById('output');
            const statusBadge = document.getElementById('status-badge');
            const runBtn = document.getElementById('run-btn');
            const abortBtn = document.getElementById('abort-btn');
            runBtn.disabled = true;
            if (abortBtn) abortBtn.disabled = true;

            if (activeRun && !activeRun.aborted) {
                showStatus('A run is already in progress. Abort it before starting a new one.', 'error');
                runBtn.disabled = false;
                return;
            }

            clearCharts();

            const nowMs = () => (window.performance && typeof window.performance.now === 'function')
                ? window.performance.now()
                : Date.now();
            const formatDurationMs = (ms) => {
                if (!Number.isFinite(ms)) return '';
                const totalSeconds = ms / 1000;
                const minutes = Math.floor(totalSeconds / 60);
                const seconds = totalSeconds - minutes * 60;
                const secondsStr = seconds.toFixed(1).padStart(4, '0');
                return `${minutes}m ${secondsStr}s`;
            };
            const endToEndStartMs = nowMs();

            const fail = (message) => {
                const elapsedMs = nowMs() - endToEndStartMs;
                progressClear();
                outputDiv.textContent = `Failure: ${message}\n\nTotal end-to-end time: ${formatDurationMs(elapsedMs)}`;
                statusBadge.innerHTML = '<span class="status-badge status-error">Failed</span>';
                runBtn.disabled = false;
            };

            if (!config.selectedAlgorithm) {
                fail('No algorithm selected.');
                return;
            }

            const algo = algorithmConfigs[config.selectedAlgorithm];
            if (!algo) {
                fail('Unknown algorithm selected.');
                return;
            }

            if (!config.token) {
                fail('Personal Access Token is required to run workflows.');
                return;
            }

            const runMode = getSelectedRunMode();
            const inputMode = getInputMode();

                if (inputMode === 'generate') {
                    if (runMode === 'local') {
                        fail('Generator mode is only available for GitHub Actions runs.');
                        return;
                    }
                    const validation = validateGeneratorInputs();
                    if (!validation.valid) {
                        fail('Generator inputs are invalid. Ensure N >= 2, density is 0-1, and k < N.');
                        return;
                    }
                } else if (config.selectedFiles.length !== algo.requiredFiles) {
                fail(`Selected ${config.selectedFiles.length} file(s); expected ${algo.requiredFiles}.`);
                return;
            }

            try {
                if (inputMode !== 'generate') {
                    await normalizeGraphInputOrder(config.selectedAlgorithm);
                }
            } catch (_) {}
            updateRunInfo();

            const inputLines = inputMode === 'generate'
                ? [
                    `Generated: N=${config.generator.n || '?'}` +
                    (isGraphPairAlgorithm(config.selectedAlgorithm) ? `, k=${config.generator.k || '?'}` : '') +
                    `, density=${config.generator.density || '?'}`
                ]
                : config.selectedFiles.map((file, index) => {
                    const label = algo.fileLabels ? algo.fileLabels[index] : `File ${index + 1}`;
                    return `${label}: ${file.path}`;
                });

            const summaryLines = [
                `Algorithm: ${algo.name}`,
                'Inputs:',
                ...inputLines,
                '',
                'Result:',
                runMode === 'local' ? 'Starting local run...' : 'Triggering workflow...'
            ];
            outputDiv.textContent = summaryLines.join('\n');
            statusBadge.innerHTML = '<span class="status-badge status-running">Running...</span>';

            const requestId = (crypto && crypto.randomUUID) ? crypto.randomUUID() : `${Date.now()}-${Math.random()}`;
            const runCtx = {
                requestId,
                mode: runMode,
                branchRef: '',
                runSha: '',
                aborted: false,
                abortController: new AbortController()
            };
            activeRun = runCtx;
            if (abortBtn) abortBtn.disabled = false;

            const iterationsEl = document.getElementById('iterations');
            const warmupEl = document.getElementById('warmup');
            const iterationsRaw = iterationsEl ? String(iterationsEl.value || '').trim() : '';
            const warmupRaw = warmupEl ? String(warmupEl.value || '').trim() : '';
            let iterations = 1;
            if (iterationsRaw) {
                const parsed = parseInt(iterationsRaw, 10);
                if (Number.isFinite(parsed) && parsed >= 1) iterations = parsed;
            }

            let warmup = 0;
            if (warmupRaw) {
                const parsed = parseInt(warmupRaw, 10);
                if (Number.isFinite(parsed) && parsed >= 0) warmup = parsed;
            }
            if (warmup > 50) warmup = 50;

            const branchRef = config.ref || 'main';
            runCtx.branchRef = branchRef;
            runTimerStart(runCtx);

            let dispatched = false;
            try {
                if (runMode === 'local') {
                    const localResult = await runAlgorithmLocally(runCtx, config.selectedAlgorithm, iterations, warmup);
                    if (runCtx.aborted || (localResult && localResult.status === 'aborted')) {
                        if (activeRun === runCtx) {
                            outputDiv.textContent = 'Run Aborted';
                            statusBadge.innerHTML = '<span class="status-badge status-aborted">Aborted</span>';
                            progressClear();
                        }
                        return;
                    }
                    if (!localResult || localResult.status !== 'success') {
                        throw new Error((localResult && localResult.error) ? localResult.error : 'Local run failed');
                    }

                    const finalLines = [
                        `Algorithm: ${algo.name} (Local)`,
                        'Inputs:',
                        ...inputLines,
                        '',
                        'Result:',
                        localResult.output || '(No output)'
                    ];
                    const elapsedMs = nowMs() - endToEndStartMs;
                    finalLines.push('', `Total end-to-end time: ${formatDurationMs(elapsedMs)}`);
                    outputDiv.textContent = finalLines.join('\n');
                    statusBadge.innerHTML = '<span class="status-badge status-ready">Success</span>';
                    clearCharts();
                    return;
                }

                progressReset(config.selectedAlgorithm, iterations, requestId);

                let runSha = '';
                try {
                    runSha = await getBranchHeadSha(branchRef);
                    if (runSha) progressState.runSha = runSha;
                    runCtx.runSha = runSha;
                } catch (_) {}

                const workflowData = {
                    ref: branchRef,
                    inputs: {
                        algorithm: config.selectedAlgorithm,
                        iterations: String(iterations),
                        warmup: String(warmup),
                        input_files: inputMode === 'generate' ? '' : config.selectedFiles.map(f => f.path).join(','),
                        input_mode: inputMode,
                        n: String(config.generator.n || ''),
                        k: String(config.generator.k || ''),
                        density: String(config.generator.density || ''),
                        seed: String(config.generator.seed || ''),
                        request_id: requestId
                    }
                };

                await ensureWorkflowDispatch(branchRef);
                await dispatchWorkflow(workflowData);
                dispatched = true;
                const result = await waitForResult(requestId, branchRef, runSha, runCtx);
                if (runCtx.aborted || (result && result.status === 'aborted')) {
                    if (activeRun === runCtx) {
                        outputDiv.textContent = 'Run Aborted';
                        statusBadge.innerHTML = '<span class="status-badge status-aborted">Aborted</span>';
                        progressClear();
                    }
                    return;
                }
                if (result.status !== 'success') {
                    throw new Error(result.error || 'Workflow reported failure');
                }

                const finalLines = [
                    `Algorithm: ${algo.name}`,
                    'Inputs:',
                    ...inputLines,
                    '',
                    'Result:',
                    result.output || '(No output)'
                ];
                const seedUsed = result && result.inputs && result.inputs.seed ? String(result.inputs.seed) : '';
                const elapsedMs = nowMs() - endToEndStartMs;
                if (inputMode === 'generate' && seedUsed) {
                    finalLines.push('', `Seed used: ${seedUsed}`);
                    finalLines.push(`Total end-to-end time: ${formatDurationMs(elapsedMs)}`);
                } else {
                    finalLines.push('', `Total end-to-end time: ${formatDurationMs(elapsedMs)}`);
                }
                outputDiv.textContent = finalLines.join('\n');
                statusBadge.innerHTML = '<span class="status-badge status-ready">Success</span>';
                if (progressState.total > 0) {
                    progressSetDeterminate('Completed', progressState.total, progressState.total);
                }
                renderCharts(result);
                renderVisualization(result);
            } catch (error) {
                if (runCtx && runCtx.aborted) {
                    return;
                }
                const message = error && error.message ? error.message : String(error);
                const elapsedMs = nowMs() - endToEndStartMs;
                outputDiv.textContent = `Failure: ${message}\n\nTotal end-to-end time: ${formatDurationMs(elapsedMs)}`;
                reportDebugError('runAlgorithm', error, {
                    algorithm: config.selectedAlgorithm,
                    files: config.selectedFiles.map(f => f.path).join(','),
                    ref: branchRef
                });
                statusBadge.innerHTML = '<span class="status-badge status-error">Failed</span>';
                clearCharts();

                if (!dispatched) {
                    progressClear();
                } else {
                    const phaseText = message.length > 120 ? message.slice(0, 117) + '...' : message;
                    progressSetDeterminate(phaseText, progressState.completed, progressState.total);
                }
            } finally {
                if (activeRun === runCtx) {
                    runTimerStop(runCtx);
                    activeRun = null;
                    if (abortBtn) abortBtn.disabled = true;
                    updateRunButton();
                }
            }
        }

        let workflowDispatchEndpointCache = null;
        let runAlgorithmWorkflowIdCache = null;
        async function getWorkflowDispatchEndpoint() {
            if (workflowDispatchEndpointCache) return workflowDispatchEndpointCache;
            // Prefer workflow ID to avoid path mismatches; fall back to path if needed.
            try {
                const data = await apiRequest('/actions/workflows');
                if (data && Array.isArray(data.workflows)) {
                    const match = data.workflows.find(wf =>
                        wf.path === '.github/workflows/run-algorithm.yml' ||
                        (wf.name && wf.name.toLowerCase().includes('run algorithm'))
                    );
                    if (match && match.id) {
                        workflowDispatchEndpointCache = `/actions/workflows/${match.id}/dispatches`;
                        return workflowDispatchEndpointCache;
                    }
                }
            } catch (error) {
                // Ignore and fall back
            }
            workflowDispatchEndpointCache = '/actions/workflows/run-algorithm.yml/dispatches';
            return workflowDispatchEndpointCache;
        }

        async function getRunAlgorithmWorkflowId() {
            if (runAlgorithmWorkflowIdCache) return runAlgorithmWorkflowIdCache;
            try {
                const data = await apiRequest('/actions/workflows');
                if (data && Array.isArray(data.workflows)) {
                    const match = data.workflows.find(wf =>
                        wf.path === '.github/workflows/run-algorithm.yml' ||
                        (wf.name && wf.name.toLowerCase().includes('run algorithm'))
                    );
                    if (match && match.id) {
                        runAlgorithmWorkflowIdCache = String(match.id);
                        return runAlgorithmWorkflowIdCache;
                    }
                }
            } catch (_) {}
            return '';
        }

        async function dispatchWorkflow(workflowData) {
            const dispatchEndpoint = await getWorkflowDispatchEndpoint();
            try {
                await apiRequest(dispatchEndpoint, 'POST', workflowData);
            } catch (error) {
                const msg = (error && error.message) ? error.message : '';
                const isMissingTrigger = msg.includes("Workflow does not have 'workflow_dispatch' trigger") || msg.includes('422');
                if (!isMissingTrigger) {
                    throw error;
                }
                // Fallback to repository_dispatch event
                const repoPayload = {
                    event_type: 'run-algorithm',
                    client_payload: {
                        algorithm: workflowData.inputs.algorithm,
                        iterations: workflowData.inputs.iterations,
                        warmup: workflowData.inputs.warmup,
                        input_files: workflowData.inputs.input_files,
                        input_mode: workflowData.inputs.input_mode,
                        n: workflowData.inputs.n,
                        k: workflowData.inputs.k,
                        density: workflowData.inputs.density,
                        seed: workflowData.inputs.seed,
                        request_id: workflowData.inputs.request_id || ''
                    }
                };
                await apiRequest('/dispatches', 'POST', repoPayload);
            }
        }

        async function listWorkflowRuns(workflowId, branchRef, perPage = 30) {
            const id = String(workflowId || '').trim();
            if (!id) return [];

            const pageSize = Math.max(1, Math.min(100, Number(perPage) || 30));
            const params = [`per_page=${pageSize}`];
            const branch = String(branchRef || '').trim();
            if (branch) params.push(`branch=${encodeURIComponent(branch)}`);

            const endpoint = `/actions/workflows/${id}/runs?${params.join('&')}`;
            const data = await apiRequest(endpoint);
            return (data && Array.isArray(data.workflow_runs)) ? data.workflow_runs : [];
        }

        async function resolveWorkflowRunId(requestId, branchRef, runSha) {
            const request = String(requestId || '').trim();
            if (!request) return '';

            if (progressState.workflowRunId && /^[0-9]+$/.test(progressState.workflowRunId)) {
                return progressState.workflowRunId;
            }

            let sha = String(runSha || progressState.runSha || '').trim();
            if (!sha) {
                try {
                    sha = await getBranchHeadSha(branchRef || config.ref || 'main');
                    if (sha) progressState.runSha = sha;
                } catch (_) {}
            }

            if (sha) {
                try {
                    await tryUpdateProgressFromChecks(request, sha);
                } catch (_) {}
            }

            if (progressState.workflowRunId && /^[0-9]+$/.test(progressState.workflowRunId)) {
                return progressState.workflowRunId;
            }

            const workflowId = await getRunAlgorithmWorkflowId();
            if (!workflowId) return '';

            let runs = [];
            try {
                runs = await listWorkflowRuns(workflowId, branchRef || config.ref || 'main');
            } catch (_) {
                runs = [];
            }

            const byTitle = runs.find(r =>
                r &&
                typeof r.display_title === 'string' &&
                r.display_title.includes(request) &&
                r.id
            );
            if (byTitle && byTitle.id) return String(byTitle.id);

            const bySha = sha
                ? runs.find(r => r && r.head_sha === sha && r.id && r.status !== 'completed')
                : null;
            if (bySha && bySha.id) return String(bySha.id);

            return '';
        }

        async function cancelWorkflowRun(runId) {
            const id = String(runId || '').trim();
            if (!id || !/^[0-9]+$/.test(id)) {
                throw new Error('Missing workflow run id');
            }
            await apiRequest(`/actions/runs/${id}/cancel`, 'POST');
        }

        async function abortRun() {
            const run = activeRun;
            const outputDiv = document.getElementById('output');
            const statusBadge = document.getElementById('status-badge');
            const runBtn = document.getElementById('run-btn');
            const abortBtn = document.getElementById('abort-btn');

            if (!run || !run.requestId) {
                showStatus('No run is currently active', 'error');
                return;
            }

            if (run.aborted) return;
            run.aborted = true;

            if (abortBtn) abortBtn.disabled = true;
            if (outputDiv) outputDiv.textContent = 'Run Aborted';
            if (statusBadge) statusBadge.innerHTML = '<span class="status-badge status-aborted">Aborted</span>';
            runTimerStop(run);

            try {
                if (run.abortController) run.abortController.abort();
            } catch (_) {}

            // Local runs do not create a GitHub Actions workflow to cancel.
            if (run.mode === 'local') {
                if (runBtn) runBtn.disabled = false;
                return;
            }

            // Best-effort: cancel the GitHub Actions workflow run.
            try {
                const runId = await resolveWorkflowRunId(run.requestId, run.branchRef, run.runSha);
                if (runId) {
                    await cancelWorkflowRun(runId);
                } else {
                    showStatus('Abort requested, but could not determine the workflow run id to cancel.', 'error');
                }
            } catch (error) {
                const msg = (error && error.message) ? error.message : String(error);
                showStatus(`Abort requested, but cancel failed: ${msg}`, 'error');
            }

            // Allow starting a new run immediately; the polling loop will exit via abortController.
            if (runBtn) runBtn.disabled = false;
        }

        function delay(ms, signal) {
            return new Promise(resolve => {
                const timeoutId = setTimeout(resolve, ms);
                if (!signal) return;
                if (signal.aborted) {
                    clearTimeout(timeoutId);
                    resolve();
                    return;
                }
                signal.addEventListener('abort', () => {
                    clearTimeout(timeoutId);
                    resolve();
                }, { once: true });
            });
        }

        async function ensureWorkflowDispatch(branchRef) {
            const refParam = branchRef ? `?ref=${encodeURIComponent(branchRef)}` : '';
            const path = `/contents/.github/workflows/run-algorithm.yml${refParam}`;
            try {
                const wf = await apiRequest(path);
                if (!wf || !wf.content) return;
                const decoded = atob(wf.content.replace(/\s/g, ''));
                if (!decoded.includes('workflow_dispatch')) {
                    throw new Error('run-algorithm.yml is missing a workflow_dispatch trigger on this branch');
                }
            } catch (error) {
                // Surface a clear error for the common 422 case
                throw new Error(`Workflow unavailable on branch ${branchRef || 'main'}: ${error.message || error}`);
            }
        }

        async function downloadArtifactZip(artifact) {
            const item = artifact || {};
            const id = item.id ? String(item.id) : '';
            if (!id) throw new Error('Missing artifact id');

            const url = item.archive_download_url ||
                `https://api.github.com/repos/${config.owner}/${config.repo}/actions/artifacts/${id}/zip`;
            const headers = buildRequestHeaders({ accept: 'application/vnd.github+json' });

            const response = await fetch(url, { method: 'GET', headers });
            if (!response.ok) {
                const text = await response.text().catch(() => '');
                throw new Error(`Artifact download failed: ${response.status} ${response.statusText} ${text}`);
            }
            return await response.arrayBuffer();
        }

        async function extractResultJsonFromZip(buffer) {
            if (!window.JSZip) {
                throw new Error('JSZip is required to read results artifacts.');
            }
            const zip = await window.JSZip.loadAsync(buffer);
            let file = zip.file('outputs/result.json') || zip.file('result.json');
            if (!file) {
                const matches = zip.file(/result\.json$/i);
                if (matches && matches.length) file = matches[0];
            }
            if (!file) throw new Error('Result artifact is missing result.json');
            const text = await file.async('text');
            return JSON.parse(text);
        }

        async function fetchResultFromArtifact(requestId, branchRef, runSha) {
            const runId = await resolveWorkflowRunId(requestId, branchRef, runSha);
            if (!runId) return null;

            let data;
            try {
                data = await apiRequest(`/actions/runs/${runId}/artifacts`);
            } catch (error) {
                const msg = error && error.message ? error.message : '';
                if (msg.includes('401') || msg.includes('403')) {
                    throw new Error('Cannot access workflow artifacts. Ensure your token has Actions: Read permission.');
                }
                return null;
            }

            const artifactsRaw = (data && Array.isArray(data.artifacts)) ? data.artifacts : [];
            const artifacts = artifactsRaw.filter(item => item && !item.expired);
            if (!artifacts.length) return null;

            const match = artifacts.find(item => item.name === 'algorithm-result') ||
                (requestId ? artifacts.find(item => item.name && item.name.includes(requestId)) : null) ||
                artifacts[0];

            if (!match) return null;
            const buffer = await downloadArtifactZip(match);
            const json = await extractResultJsonFromZip(buffer);
            if (!requestId || !json.request_id || json.request_id === requestId) {
                return json;
            }
            return null;
        }

        async function waitForResult(requestId, branchRef, runSha, runCtx) {
            const waitMs = 5000;
            const estimateMaxAttempts = 720; // UI-only fallback when Checks can't be read
            let lastError = null;
            let sha = runSha || '';

            for (let attempt = 1; ; attempt++) {
                if (runCtx && runCtx.aborted) {
                    return { status: 'aborted', error: 'Run Aborted' };
                }
                if (!sha) {
                    try {
                        sha = await getBranchHeadSha(branchRef || config.ref || 'main');
                        if (sha) progressState.runSha = sha;
                    } catch (_) {}
                }
                let progressUpdated = false;
                let progressReason = '';
                if (sha) {
                    try {
                        const progressRes = await tryUpdateProgressFromChecks(requestId, sha);
                        progressUpdated = !!(progressRes && progressRes.updated);
                        progressReason = progressRes && progressRes.reason ? progressRes.reason : '';
                    } catch (_) {}
                }
                if (!progressUpdated) {
                    const stage = (progressState && progressState.stage === 'tests') ? 'tests' : 'setup';
                    if (stage === 'setup') {
                        const setupMaxAttempts = 24; // ~2 minutes at 5s intervals
                        const phase = progressReason === 'forbidden'
                            ? 'Setting up Testing Environment (enable Checks: Read)'
                            : 'Setting up Testing Environment';
                        progressUpdateEstimated(Math.min(attempt, setupMaxAttempts), setupMaxAttempts, phase);

                        // If we can't read Checks, we can't detect the stage transition; still show two phases.
                        if (progressReason === 'forbidden' && attempt === setupMaxAttempts) {
                            const setupTotal = Number.isFinite(Number(progressState.total))
                                ? Number(progressState.total)
                                : (progressState.setupTotal || 100);
                            progressSetDeterminate('Setting up Testing Environment (enable Checks: Read)', setupTotal, setupTotal, { stage: 'setup' });
                            const testsTotal = Number.isFinite(Number(progressState.testsTotal)) ? Number(progressState.testsTotal) : 0;
                            progressSetDeterminate('Running tests... (enable Checks: Read)', 0, testsTotal, { stage: 'tests', reset: true });
                        }
                    } else {
                        const phase = progressReason === 'forbidden'
                            ? 'Running tests... (enable Checks: Read)'
                            : 'Running tests...';
                        progressUpdateEstimated(attempt, estimateMaxAttempts, phase);
                    }
                }
                try {
                    const result = await fetchResultFromArtifact(requestId, branchRef, sha);
                    if (result) {
                        return result;
                    }
                } catch (error) {
                    lastError = error;
                    const msg = error && error.message ? error.message : '';
                    if (msg.includes('workflow artifacts') || msg.includes('JSZip')) {
                        throw error;
                    }
                }
                await delay(waitMs, runCtx && runCtx.abortController ? runCtx.abortController.signal : null);
            }
        }

        function clearOutput() {
            document.getElementById('output').textContent = 'Output cleared.';
            document.getElementById('status-badge').innerHTML = '';
            progressClear();
            clearCharts();
        }

        function clearCharts() {
            const charts = document.getElementById('charts');
            const runtime = document.getElementById('runtime-chart');
            const memory = document.getElementById('memory-chart');
            if (runtimeChartInstance) {
                runtimeChartInstance.destroy();
                runtimeChartInstance = null;
            }
            if (memoryChartInstance) {
                memoryChartInstance.destroy();
                memoryChartInstance = null;
            }
            if (runtime) runtime.height = runtime.height;
            if (memory) memory.height = memory.height;
            if (charts) charts.hidden = true;
            clearVisualization();
        }

        function normalizeVersionMetrics(result) {
            const timings = result && result.timings_ms ? result.timings_ms : {};
            const timingsStdev = result && result.timings_ms_stdev ? result.timings_ms_stdev : {};
            const memory = result && result.memory_kb ? result.memory_kb : {};
            const memoryStdev = result && result.memory_kb_stdev ? result.memory_kb_stdev : {};

            const pickNumber = (raw) => {
                if (raw === null || raw === undefined || raw === '') return null;
                const num = Number(raw);
                return Number.isFinite(num) ? num : null;
            };

            const pickValue = (keys, source) => {
                for (const key of keys) {
                    if (!source || !Object.prototype.hasOwnProperty.call(source, key)) continue;
                    const value = pickNumber(source[key]);
                    if (value !== null) return value;
                }
                return null;
            };

            const pickPair = (keys, valueSource, stdevSource) => {
                for (const key of keys) {
                    if (!valueSource || !Object.prototype.hasOwnProperty.call(valueSource, key)) continue;
                    const value = pickNumber(valueSource[key]);
                    if (value === null) continue;
                    const stdevRaw = stdevSource && Object.prototype.hasOwnProperty.call(stdevSource, key)
                        ? stdevSource[key]
                        : null;
                    const stdev = pickNumber(stdevRaw);
                    return { value, stdev };
                }
                return { value: null, stdev: null };
            };

            const parseGlasgowBaselineFromOutput = (output) => {
                if (!output) return null;
                const start = output.indexOf('[Glasgow Subgraph Solver]');
                if (start < 0) return null;
                const rest = output.slice(start);
                const nextHeader = rest.slice(1).search(/\n\[/);
                const section = nextHeader >= 0 ? rest.slice(0, nextHeader + 1) : rest;
                const firstMatch = section.match(/Runtime \(ms\):\s*first\s+median=\s*([0-9.]+)/i);
                const allMatch = section.match(/\n\s*all\s+median=\s*([0-9.]+)/i);
                if (!firstMatch || !allMatch) return null;
                const first = Number(firstMatch[1]);
                const all = Number(allMatch[1]);
                if (!Number.isFinite(first) || !Number.isFinite(all)) return null;
                return { first, all };
            };

            const runtime = {
                benchmark: {
                    first: pickPair(['baseline_first', 'first'], timings, timingsStdev),
                    all: pickPair(['baseline_all', 'baseline', 'all'], timings, timingsStdev)
                },
                chatgpt: {
                    first: pickPair(['chatgpt_first'], timings, timingsStdev),
                    all: pickPair(['chatgpt_all', 'llm'], timings, timingsStdev)
                },
                gemini: {
                    first: pickPair(['gemini_first'], timings, timingsStdev),
                    all: pickPair(['gemini_all'], timings, timingsStdev)
                }
            };

            if (result && result.algorithm === 'glasgow') {
                const baseline = parseGlasgowBaselineFromOutput(result.output);
                if (baseline) {
                    if (!Number.isFinite(runtime.benchmark.first.value)) {
                        runtime.benchmark.first = { value: baseline.first, stdev: null };
                    }
                    if (!Number.isFinite(runtime.benchmark.all.value)) {
                        runtime.benchmark.all = { value: baseline.all, stdev: null };
                    }
                }
            }

            const mem = {
                benchmark: pickPair(['baseline_all', 'all'], memory, memoryStdev),
                chatgpt: pickPair(['chatgpt_all', 'llm'], memory, memoryStdev),
                gemini: pickPair(['gemini_all'], memory, memoryStdev)
            };

            if (result && result.algorithm === 'dijkstra') {
                mem.benchmark = pickPair(['baseline'], memory, memoryStdev);
                mem.chatgpt = pickPair(['llm'], memory, memoryStdev);
                mem.gemini = { value: null, stdev: null };
            }

            return { runtime, memory: mem };
        }

        let runtimeChartInstance = null;
        let memoryChartInstance = null;
        let graphInstance = null;
        let patternInstance = null;
        let graphHoverEdgeId = null;
        let patternHoverEdgeId = null;

        const errorBarsPlugin = {
            id: 'errorBars',
            afterDatasetsDraw(chart, args, pluginOptions) {
                const { ctx, scales } = chart;
                const yScale = scales && scales.y ? scales.y : null;
                if (!yScale) return;
                chart.data.datasets.forEach((dataset, datasetIndex) => {
                    const meta = chart.getDatasetMeta(datasetIndex);
                    if (!meta || meta.type !== 'bar') return;
                    const errors = dataset.errorBars || [];
                    meta.data.forEach((bar, index) => {
                        const err = errors[index];
                        const value = dataset.data[index];
                        if (!Number.isFinite(err) || !Number.isFinite(value)) return;
                        const yTop = yScale.getPixelForValue(value + err);
                        const yBottom = yScale.getPixelForValue(Math.max(0, value - err));
                        const x = bar.x;
                        const capWidth = Number.isFinite(pluginOptions?.capWidth) ? pluginOptions.capWidth : 8;
                        const lineWidth = Number.isFinite(pluginOptions?.lineWidth) ? pluginOptions.lineWidth : 1;
                        const color = Array.isArray(dataset.borderColor)
                            ? dataset.borderColor[index]
                            : (dataset.borderColor || '#333');
                        ctx.save();
                        ctx.strokeStyle = color || '#333';
                        ctx.lineWidth = lineWidth;
                        ctx.beginPath();
                        ctx.moveTo(x, yTop);
                        ctx.lineTo(x, yBottom);
                        ctx.moveTo(x - capWidth / 2, yTop);
                        ctx.lineTo(x + capWidth / 2, yTop);
                        ctx.moveTo(x - capWidth / 2, yBottom);
                        ctx.lineTo(x + capWidth / 2, yBottom);
                        ctx.stroke();
                        ctx.restore();
                    });
                });
            }
        };

        function renderBarChart(canvasId, data, unitLabel, title) {
            const canvas = document.getElementById(canvasId);
            if (!canvas || !window.Chart) return null;

            const labels = data.map(item => item.label);
            const values = data.map(item => (Number.isFinite(Number(item.value)) ? Number(item.value) : null));
            const errors = data.map(item => {
                const value = Number.isFinite(Number(item.value)) ? Number(item.value) : null;
                if (!Number.isFinite(value)) return null;
                return Number.isFinite(Number(item.stdev)) ? Number(item.stdev) : 0;
            });

            return new Chart(canvas, {
                type: 'bar',
                plugins: [errorBarsPlugin],
                data: {
                    labels,
                    datasets: [
                        {
                            label: title,
                            data: values,
                            errorBars: errors,
                            backgroundColor: ['#1f77b4', '#e45756', '#54a24b'],
                            borderColor: ['#1b6aa1', '#c84544', '#3f8f3b'],
                            borderWidth: 1,
                            borderRadius: 6
                        }
                    ]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        legend: { display: false },
                        tooltip: {
                            callbacks: {
                                label: context => {
                                    const v = context.raw;
                                    if (v === null || v === undefined || Number.isNaN(v)) return 'N/A';
                                    const err = context.dataset && context.dataset.errorBars
                                        ? context.dataset.errorBars[context.dataIndex]
                                        : null;
                                    if (Number.isFinite(err) && err > 0) {
                                        return `${v.toFixed(2)} +/- ${err.toFixed(2)} ${unitLabel}`;
                                    }
                                    return `${v.toFixed(2)} ${unitLabel}`;
                                }
                            }
                        }
                        ,
                        errorBars: {
                            capWidth: 10,
                            lineWidth: 1
                        }
                    },
                    scales: {
                        y: {
                            beginAtZero: true,
                            ticks: {
                                callback: value => `${value} ${unitLabel}`
                            }
                        }
                    }
                }
            });
        }

        function renderGroupedBarChart(canvasId, labels, datasets, unitLabel) {
            const canvas = document.getElementById(canvasId);
            if (!canvas || !window.Chart) return null;

            const chartDatasets = datasets.map((dataset) => ({
                label: dataset.label,
                data: dataset.values,
                errorBars: dataset.errors,
                backgroundColor: dataset.backgroundColor,
                borderColor: dataset.borderColor,
                borderWidth: 1,
                borderRadius: 6,
                minBarLength: Number.isFinite(dataset.minBarLength) ? dataset.minBarLength : 2
            }));

            return new Chart(canvas, {
                type: 'bar',
                plugins: [errorBarsPlugin],
                data: {
                    labels,
                    datasets: chartDatasets
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        legend: {
                            display: true,
                            labels: {
                                usePointStyle: true,
                                pointStyle: 'rectRounded'
                            }
                        },
                        tooltip: {
                            callbacks: {
                                label: context => {
                                    const v = context.raw;
                                    if (v === null || v === undefined || Number.isNaN(v)) return 'N/A';
                                    const err = context.dataset && context.dataset.errorBars
                                        ? context.dataset.errorBars[context.dataIndex]
                                        : null;
                                    if (Number.isFinite(err) && err > 0) {
                                        return `${context.dataset.label}: ${v.toFixed(2)} +/- ${err.toFixed(2)} ${unitLabel}`;
                                    }
                                    return `${context.dataset.label}: ${v.toFixed(2)} ${unitLabel}`;
                                }
                            }
                        },
                        errorBars: {
                            capWidth: 10,
                            lineWidth: 1
                        }
                    },
                    scales: {
                        x: {
                            grid: {
                                display: false
                            }
                        },
                        y: {
                            beginAtZero: true,
                            ticks: {
                                callback: value => `${value} ${unitLabel}`
                            }
                        }
                    }
                }
            });
        }

        function renderCharts(result) {
            const charts = document.getElementById('charts');
            if (!charts) return;

            const metrics = normalizeVersionMetrics(result || {});
            const runtimePairs = [
                metrics.runtime.benchmark.first,
                metrics.runtime.benchmark.all,
                metrics.runtime.chatgpt.first,
                metrics.runtime.chatgpt.all,
                metrics.runtime.gemini.first,
                metrics.runtime.gemini.all
            ];
            const hasRuntime = runtimePairs.some(v => Number.isFinite(Number(v.value)));
            const hasMemory = Object.values(metrics.memory).some(v => Number.isFinite(Number(v.value)));

            if (!hasRuntime && !hasMemory) {
                clearCharts();
                return;
            }

            const runtimeLabels = ['Benchmark', 'ChatGPT', 'Gemini'];
            const runtimeFirst = [
                metrics.runtime.benchmark.first,
                metrics.runtime.chatgpt.first,
                metrics.runtime.gemini.first
            ];
            const runtimeAll = [
                metrics.runtime.benchmark.all,
                metrics.runtime.chatgpt.all,
                metrics.runtime.gemini.all
            ];
            const runtimeDataSets = [
                {
                    label: 'First',
                    values: runtimeFirst.map(item => (Number.isFinite(Number(item.value)) ? Number(item.value) : null)),
                    errors: runtimeFirst.map(item => {
                        const value = Number.isFinite(Number(item.value)) ? Number(item.value) : null;
                        if (!Number.isFinite(value)) return null;
                        return Number.isFinite(Number(item.stdev)) ? Number(item.stdev) : 0;
                    }),
                    backgroundColor: '#7aa6c2',
                    borderColor: '#5e869f'
                },
                {
                    label: 'All',
                    values: runtimeAll.map(item => (Number.isFinite(Number(item.value)) ? Number(item.value) : null)),
                    errors: runtimeAll.map(item => {
                        const value = Number.isFinite(Number(item.value)) ? Number(item.value) : null;
                        if (!Number.isFinite(value)) return null;
                        return Number.isFinite(Number(item.stdev)) ? Number(item.stdev) : 0;
                    }),
                    backgroundColor: '#e5a06a',
                    borderColor: '#c98453'
                }
            ];
            const memoryData = [
                { label: 'Benchmark', value: metrics.memory.benchmark.value, stdev: metrics.memory.benchmark.stdev },
                { label: 'ChatGPT', value: metrics.memory.chatgpt.value, stdev: metrics.memory.chatgpt.stdev },
                { label: 'Gemini', value: metrics.memory.gemini.value, stdev: metrics.memory.gemini.stdev }
            ];

            if (runtimeChartInstance) runtimeChartInstance.destroy();
            if (memoryChartInstance) memoryChartInstance.destroy();
            runtimeChartInstance = renderGroupedBarChart('runtime-chart', runtimeLabels, runtimeDataSets, 'ms');
            memoryChartInstance = renderBarChart('memory-chart', memoryData, 'kB', 'Memory');
            charts.hidden = false;
        }

        function clearVisualization() {
            const panel = document.getElementById('graph-panel');
            const note = document.getElementById('graph-note');
            const canvas = document.getElementById('graph-canvas');
            const patternPanel = document.getElementById('pattern-panel');
            const patternNote = document.getElementById('pattern-note');
            const patternCanvas = document.getElementById('pattern-canvas');
            if (graphInstance) {
                graphInstance.destroy();
                graphInstance = null;
            }
            if (patternInstance) {
                patternInstance.destroy();
                patternInstance = null;
            }
            graphHoverEdgeId = null;
            patternHoverEdgeId = null;
            if (canvas) canvas.innerHTML = '';
            if (patternCanvas) patternCanvas.innerHTML = '';
            if (note) note.textContent = '';
            if (patternNote) patternNote.textContent = '';
            if (panel) panel.hidden = true;
            if (patternPanel) patternPanel.hidden = true;
        }

        function attachHoverHighlight(cy, hoverState) {
            if (!cy) return;
            cy.on('mouseover', 'edge', (evt) => {
                const edge = evt.target;
                if (!edge) return;
                const edgeId = edge.id();
                if (hoverState.current && hoverState.current !== edgeId) {
                    const prev = cy.getElementById(hoverState.current);
                    if (prev) {
                        prev.removeClass('hover-edge');
                        prev.connectedNodes().removeClass('hover-node');
                    }
                }
                hoverState.current = edgeId;
                edge.addClass('hover-edge');
                edge.connectedNodes().addClass('hover-node');
            });
            cy.on('mouseout', 'edge', (evt) => {
                const edge = evt.target;
                if (!edge) return;
                const edgeId = edge.id();
                if (hoverState.current && hoverState.current !== edgeId) {
                    return;
                }
                edge.removeClass('hover-edge');
                edge.connectedNodes().removeClass('hover-node');
                hoverState.current = null;
            });
        }

        function renderVisualization(result) {
            const panel = document.getElementById('graph-panel');
            const note = document.getElementById('graph-note');
            const canvas = document.getElementById('graph-canvas');
            const patternPanel = document.getElementById('pattern-panel');
            const patternNote = document.getElementById('pattern-note');
            const patternCanvas = document.getElementById('pattern-canvas');
            if (!panel || !canvas || !window.cytoscape) return;

            const vis = result && result.visualization ? result.visualization : null;
            if (!vis || !Array.isArray(vis.nodes) || !Array.isArray(vis.edges)) {
                clearVisualization();
                return;
            }

            if (graphInstance) {
                graphInstance.destroy();
                graphInstance = null;
            }
            if (patternInstance) {
                patternInstance.destroy();
                patternInstance = null;
            }
            canvas.innerHTML = '';
            if (patternCanvas) patternCanvas.innerHTML = '';
            panel.hidden = false;
            if (patternPanel) patternPanel.hidden = true;

            const elements = [];
            for (const node of vis.nodes) {
                elements.push(node);
            }
            for (const edge of vis.edges) {
                elements.push(edge);
            }

            graphInstance = cytoscape({
                container: canvas,
                elements,
                style: [
                    {
                        selector: 'node',
                        style: {
                            'background-color': '#7aa6c2',
                            'label': 'data(label)',
                            'color': '#1f2d3d',
                            'font-size': 10,
                            'text-outline-width': 2,
                            'text-outline-color': '#ffffff',
                            'text-valign': 'center',
                            'text-halign': 'center',
                            'width': 16,
                            'height': 16
                        }
                    },
                    {
                        selector: 'edge',
                        style: {
                            'line-color': '#cbd2d9',
                            'width': 1,
                            'curve-style': 'straight',
                            'target-arrow-shape': 'none'
                        }
                    },
                    {
                        selector: '.highlight-node',
                        style: {
                            'background-color': '#e45756',
                            'width': 20,
                            'height': 20
                        }
                    },
                    {
                        selector: '.highlight-edge',
                        style: {
                            'line-color': '#e45756',
                            'width': 3
                        }
                    },
                    {
                        selector: '.hover-edge',
                        style: {
                            'line-color': '#f2a444',
                            'width': 3
                        }
                    },
                    {
                        selector: '.hover-node',
                        style: {
                            'background-color': '#f2a444',
                            'width': 20,
                            'height': 20
                        }
                    }
                ],
                layout: {
                    name: 'grid',
                    avoidOverlap: true,
                    spacingFactor: 1.2,
                    fit: true
                }
            });

            if (Array.isArray(vis.highlight_nodes)) {
                for (const nodeId of vis.highlight_nodes) {
                    const node = graphInstance.getElementById(String(nodeId));
                    if (node) node.addClass('highlight-node');
                }
            }
            if (Array.isArray(vis.highlight_edges)) {
                for (const edgeId of vis.highlight_edges) {
                    const edge = graphInstance.getElementById(String(edgeId));
                    if (edge) edge.addClass('highlight-edge');
                }
            }
            attachHoverHighlight(graphInstance, { current: graphHoverEdgeId, set current(val) { graphHoverEdgeId = val; }, get current() { return graphHoverEdgeId; } });

            const noteParts = [];
            if (Number.isFinite(Number(vis.node_count)) && Number.isFinite(Number(vis.edge_count))) {
                noteParts.push(`Nodes: ${vis.node_count}, Edges: ${vis.edge_count}`);
            }
            if (vis.truncated) {
                noteParts.push('Showing up to 4000 nodes and 4000 edges.');
            }
            note.textContent = noteParts.join(' ');

            if (patternPanel && patternCanvas && Array.isArray(vis.highlight_nodes) && Array.isArray(vis.highlight_edges) && vis.highlight_nodes.length) {
                const patternNodeSet = new Set(vis.highlight_nodes.map(String));
                const patternElements = [];
                for (const nodeId of patternNodeSet) {
                    patternElements.push({ data: { id: nodeId, label: nodeId } });
                }
                for (const edgeId of vis.highlight_edges || []) {
                    const edge = (vis.edges || []).find(e => e.data && e.data.id === edgeId);
                    if (edge) {
                        patternElements.push({ data: { id: edgeId, source: edge.data.source, target: edge.data.target } });
                    }
                }
                patternPanel.hidden = false;
                patternInstance = cytoscape({
                    container: patternCanvas,
                    elements: patternElements,
                    style: [
                        {
                            selector: 'node',
                            style: {
                                'background-color': '#7aa6c2',
                                'label': 'data(label)',
                                'color': '#1f2d3d',
                                'font-size': 10,
                                'text-outline-width': 2,
                                'text-outline-color': '#ffffff',
                                'text-valign': 'center',
                                'text-halign': 'center',
                                'width': 16,
                                'height': 16
                            }
                        },
                        {
                            selector: 'edge',
                            style: {
                                'line-color': '#cbd2d9',
                                'width': 1,
                                'curve-style': 'straight',
                                'target-arrow-shape': 'none'
                            }
                        },
                        {
                            selector: '.hover-edge',
                            style: {
                                'line-color': '#f2a444',
                                'width': 3
                            }
                        },
                        {
                            selector: '.hover-node',
                            style: {
                                'background-color': '#f2a444',
                                'width': 20,
                                'height': 20
                            }
                        }
                    ],
                    layout: {
                        name: 'circle',
                        fit: true,
                        padding: 20
                    }
                });
                attachHoverHighlight(patternInstance, { current: patternHoverEdgeId, set current(val) { patternHoverEdgeId = val; }, get current() { return patternHoverEdgeId; } });
                if (patternNote) {
                    patternNote.textContent = `Nodes: ${patternNodeSet.size}, Edges: ${(vis.highlight_edges || []).length}`;
                }
                requestAnimationFrame(() => {
                    if (patternInstance) {
                        patternInstance.resize();
                        patternInstance.fit();
                    }
                });
            }
            requestAnimationFrame(() => {
                if (graphInstance) {
                    graphInstance.resize();
                    graphInstance.fit();
                }
            });
        }
        
        function buildRequestHeaders(options = {}) {
            const { useAuth = true, accept = 'application/vnd.github.v3+json' } = options;
            const headers = {
                'Accept': accept,
                'X-GitHub-Api-Version': '2022-11-28'
            };
            if (useAuth && config.token) {
                const lower = config.token.toLowerCase();
                const useBearer = lower.startsWith('github_pat_') || lower.startsWith('ghs_') || lower.startsWith('ghu_');
                headers['Authorization'] = useBearer
                    ? `Bearer ${config.token}`
                    : `token ${config.token}`;
            }
            return headers;
        }

        async function apiRequest(endpoint, method = 'GET', body = null, options = {}) {
            const { useAuth = true } = options;
            const headers = buildRequestHeaders({ useAuth });
            
            const requestOptions = {
                method: method,
                headers: headers
            };
            
            if (body) {
                requestOptions.body = JSON.stringify(body);
            }
            
            const url = `https://api.github.com/repos/${config.owner}/${config.repo}${endpoint}`;
            const response = await fetch(url, requestOptions);
                        
            if (!response.ok) {
                let responseText = '';
                try {
                    responseText = await response.text();
                } catch (_) {}
                throw new Error(`GitHub API error: ${response.status} ${response.statusText} | endpoint=${endpoint} method=${method} ref=${config.ref || 'main'} | body=${responseText}`);
            }
            
            if (method === 'POST' && (response.status === 204 || response.status === 202)) {
                return { success: true };
            }

            const contentType = response.headers.get('content-type') || '';
            if (contentType.includes('application/json')) {
                return await response.json();
            }

            const text = await response.text();
            return text ? { text } : { success: true };
        }

        function reportDebugError(context, error, meta = {}) {
            const detail = (error && error.message) ? error.message : String(error);
            const metaStr = Object.entries(meta).map(([k,v]) => `${k}=${v}`).join(', ');
            const debugMsg = `[${context}] ${detail}${metaStr ? ' | ' + metaStr : ''}`;
            showStatus(debugMsg, 'error');
            if (console && console.error) {
                console.error(debugMsg, error);
            }
        }
        
        function showStatus(message, type) {
            const container = document.getElementById('status-message');
            container.innerHTML = `<div class="${type}">${escapeHtml(message)}</div>`;
            setTimeout(() => {
                container.innerHTML = '';
            }, 5000);
        }
        
        function escapeHtml(text) {
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }

        window.addEventListener('load', () => {
            updateInputModeVisibility();
            updateGeneratorFieldsForAlgorithm();
            updateGeneratorEstimate();
            updateRunButton();
        });
    </script>
</body>
</html>
