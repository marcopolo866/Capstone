<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Algorithm Runner Interface</title>
    <link rel="stylesheet" href="style.css">
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>Algorithm Runner Interface</h1>
            <p>Run graph algorithms on your repository data</p>
        </div>
        
        <div class="config-section">
            <button class="btn" onclick="connect()">Connect to Repository</button>
        </div>
        
        <div class="content">
            <div class="panel">
                <h2>Select Algorithm</h2>
                <div id="algorithms-list">
                    <div class="algorithm-card" onclick="selectAlgorithm(event, 'dijkstra')">
                        <h3>Dijkstra's Algorithm</h3>
                        <p>Shortest path algorithm for weighted graphs</p>
                        <div class="command">./baselines/dijkstra [input-file]</div>
                    </div>
                    
                    <div class="algorithm-card" onclick="selectAlgorithm(event, 'glasgow')">
                        <h3>Glasgow Subgraph Solver</h3>
                        <p>Subgraph isomorphism solver</p>
                        <div class="command">./build/glasgow_subgraph_solver [pattern] [target]</div>
                    </div>
                    
                    <div class="algorithm-card" onclick="selectAlgorithm(event, 'vf3')">
                        <h3>VF3 Algorithm</h3>
                        <p>Graph matching algorithm</p>
                        <div class="command">./bin/vf3 [subgraph] [graph]</div>
                    </div>
                </div>
            </div>
            
            <div class="panel">
                <h2>Select Input Files</h2>
                <div id="status-message"></div>
                <div id="files-content">
                    <p class="loading">Connect to repository to browse data files</p>
                </div>
            </div>
            
            <div class="panel output-section">
                <h2>Run Algorithm 
                    <span id="status-badge"></span>
                </h2>
                
                <div id="run-info"></div>
                
                <div class="run-controls">
                    <button class="btn btn-primary" id="run-btn" onclick="runAlgorithm()" disabled>
                        Run Algorithm
                    </button>
                    <button class="btn" onclick="clearOutput()">Clear Output</button>
                </div>
                
                <div style="margin-top: 20px;">
                    <h3 style="margin-bottom: 10px;">Output:</h3>
                    <div class="output-content" id="output">
No output yet. Select an algorithm and input files, then click "Run Algorithm".
                    </div>
                </div>
            </div>
        </div>
    </div>
    
    <script>
        const DEFAULT_GITHUB_OWNER = 'marcopolo866';
        const DEFAULT_GITHUB_REPO = 'Capstone';
        const DEFAULT_GITHUB_TOKEN = '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';

        let config = {
            owner: DEFAULT_GITHUB_OWNER,
            repo: DEFAULT_GITHUB_REPO,
            token: DEFAULT_GITHUB_TOKEN,
            ref: 'main',
            selectedAlgorithm: null,
            selectedFiles: []
        };
        
        const algorithmConfigs = {
            dijkstra: {
                name: "Dijkstra's Algorithm",
                requiredFiles: 1,
                fileTypes: ['.txt', '.csv', '.grf'],
                instructions: [
                    'Plain text format: first line is the vertex count, second line is "start,target", remaining lines are "u,v,weight" (commas or spaces).',
                    'CSV format: rows contain "source,target,weight"; vertex labels can be names. Add an optional comment line like "# start=A target=D" to choose the endpoints (defaults to the first source and last target).',
                    'When labels are present the reported path will use those labels in the output window.'
                ]
            },
            glasgow: {
                name: "Glasgow Subgraph Solver",
                requiredFiles: 2,
                fileTypes: ['.grf'],
                fileLabels: ['Pattern File', 'Target File']
            },
            vf3: {
                name: "VF3 Algorithm",
                requiredFiles: 2,
                fileTypes: ['.grf'],
                fileLabels: ['Subgraph File', 'Graph File']
            }
        };
        
        function selectAlgorithm(evt, algoId) {
            config.selectedAlgorithm = algoId;
            config.selectedFiles = [];
            
            document.querySelectorAll('.algorithm-card').forEach(card => {
                card.classList.remove('selected');
            });
            if (evt && evt.currentTarget) {
                evt.currentTarget.classList.add('selected');
            }
            
            updateRunButton();
            updateRunInfo();
            
            if (config.owner && config.repo) {
                loadDataFiles();
            }
        }
        
        async function connect() {
            const owner = (DEFAULT_GITHUB_OWNER || '').trim();
            const repo = (DEFAULT_GITHUB_REPO || '').trim();
            const token = (DEFAULT_GITHUB_TOKEN || '').trim();
            
            if (!owner || !repo) {
                showStatus('Repository credentials are not configured.', 'error');
                return;
            }
            
            if (!token) {
                showStatus('Personal Access Token is not configured.', 'error');
                return;
            }
            
            config.owner = owner;
            config.repo = repo;
            config.token = token;
            
            try {
                const repoInfo = await apiRequest('');
                if (repoInfo && repoInfo.default_branch) {
                    config.ref = repoInfo.default_branch;
                }
            } catch (e) {
                // default branch fallback already set to 'main'
            }

            showStatus('Connected successfully!', 'success');
            await loadDataFiles();
        }
        
        async function loadDataFiles() {
            const container = document.getElementById('files-content');
            container.innerHTML = '<p class="loading">Loading data files...</p>';
            
            try {
                const ref = config.ref ? `?ref=${encodeURIComponent(config.ref)}` : '';
                let contents;
                try {
                    contents = await apiRequest(`/contents/data${ref}`);
                } catch (error) {
                    if (config.token && error.message.includes('404')) {
                        try {
                            contents = await apiRequest(`/contents/data${ref}`, 'GET', null, { useAuth: false });
                        } catch (fallbackError) {
                            throw fallbackError;
                        }
                    } else {
                        throw error;
                    }
                }
                
                let html = '<ul class="file-list">';
                
                const files = Array.isArray(contents) ? contents : [contents];
                
                files.forEach(item => {
                    if (item.type === 'file') {
                        const icon = 'ðŸ“„';
                        html += `
                            <li class="file-item" onclick="toggleFileSelection(event, '${item.path}', '${item.name}')">
                                <span class="file-icon">${icon}</span>
                                <span>${item.name}</span>
                            </li>
                        `;
                    }
                });
                
                html += '</ul>';
                container.innerHTML = html;
                
            } catch (error) {
                    let hint = 'Verify the repo has a top-level "data" folder on the selected branch.';
                    container.innerHTML = `<div class="error">Error loading files: ${escapeHtml(error.message)}<br>${hint}</div>`;
            }
        }
        
        function toggleFileSelection(evt, path, name) {
            const algo = algorithmConfigs[config.selectedAlgorithm];
            if (!algo) {
                showStatus('Please select an algorithm first', 'error');
                return;
            }
            
            const index = config.selectedFiles.findIndex(f => f.path === path);
            
            if (index > -1) {
                config.selectedFiles.splice(index, 1);
                if (evt && evt.currentTarget) {
                    evt.currentTarget.classList.remove('selected');
                }
            } else {
                if (config.selectedFiles.length >= algo.requiredFiles) {
                    showStatus(`This algorithm requires exactly ${algo.requiredFiles} file(s)`, 'error');
                    return;
                }
                config.selectedFiles.push({ path, name });
                if (evt && evt.currentTarget) {
                    evt.currentTarget.classList.add('selected');
                }
            }
            
            updateRunButton();
            updateRunInfo();
        }
        
        function updateRunButton() {
            const btn = document.getElementById('run-btn');
            const algo = algorithmConfigs[config.selectedAlgorithm];
            
            if (algo && config.selectedFiles.length === algo.requiredFiles && config.token) {
                btn.disabled = false;
            } else {
                btn.disabled = true;
            }
        }
        
        function updateRunInfo() {
            const infoDiv = document.getElementById('run-info');
            const algo = algorithmConfigs[config.selectedAlgorithm];
            
            if (!algo) {
                infoDiv.innerHTML = '<div class="info">Select an algorithm above to get started</div>';
                return;
            }
            
            let html = `<div class="info">
                <strong>Algorithm:</strong> ${algo.name}<br>
                <strong>Required files:</strong> ${algo.requiredFiles}
            `;
            
            if (algo.instructions && algo.instructions.length) {
                html += '<div class="instructions"><strong>File format tips:</strong><ul>';
                html += algo.instructions.map(item => `<li>${escapeHtml(item)}</li>`).join('');
                html += '</ul></div>';
            }
            
            if (config.selectedFiles.length > 0) {
                html += '<div class="selected-files"><strong>Selected:</strong> ';
                html += config.selectedFiles.map((f, i) => {
                    const label = algo.fileLabels ? algo.fileLabels[i] : `File ${i+1}`;
                    return `${label}: ${f.name}`;
                }).join(', ');
                html += '</div>';
            }
            
            html += '</div>';
            infoDiv.innerHTML = html;
        }
        
async function runAlgorithm() {
            const outputDiv = document.getElementById('output');
            const statusBadge = document.getElementById('status-badge');
            const runBtn = document.getElementById('run-btn');
            runBtn.disabled = true;

            const fail = (message) => {
                outputDiv.textContent = `Failure: ${message}`;
                statusBadge.innerHTML = '<span class="status-badge status-error">Failed</span>';
                runBtn.disabled = false;
            };

            if (!config.selectedAlgorithm) {
                fail('No algorithm selected.');
                return;
            }

            const algo = algorithmConfigs[config.selectedAlgorithm];
            if (!algo) {
                fail('Unknown algorithm selected.');
                return;
            }

            if (config.selectedFiles.length !== algo.requiredFiles) {
                fail(`Selected ${config.selectedFiles.length} file(s); expected ${algo.requiredFiles}.`);
                return;
            }

            if (!config.token) {
                fail('Personal Access Token is required to run workflows.');
                return;
            }

            const inputLines = config.selectedFiles.map((file, index) => {
                const label = algo.fileLabels ? algo.fileLabels[index] : `File ${index + 1}`;
                return `${label}: ${file.path}`;
            });

            const summaryLines = [
                `Algorithm: ${algo.name}`,
                'Inputs:',
                ...inputLines,
                '',
                'Result:',
                'Triggering workflow...'
            ];
            outputDiv.textContent = summaryLines.join('\n');
            statusBadge.innerHTML = '<span class="status-badge status-running">Running...</span>';

            const requestId = (crypto && crypto.randomUUID) ? crypto.randomUUID() : `${Date.now()}-${Math.random()}`;

            const workflowData = {
                ref: config.ref || 'main',
                inputs: {
                    algorithm: config.selectedAlgorithm,
                    input_files: config.selectedFiles.map(f => f.path).join(','),
                    request_id: requestId
                }
            };

            try {
                await apiRequest('/actions/workflows/run-algorithm.yml/dispatches', 'POST', workflowData);
                const result = await waitForResult(requestId);
                if (result.status !== 'success') {
                    throw new Error(result.error || 'Workflow reported failure');
                }

                const finalLines = [
                    `Algorithm: ${algo.name}`,
                    'Inputs:',
                    ...inputLines,
                    '',
                    'Result:',
                    result.output || '(No output)'
                ];
                outputDiv.textContent = finalLines.join('\n');
                statusBadge.innerHTML = '<span class="status-badge status-ready">Success</span>';
            } catch (error) {
                outputDiv.textContent = `Failure: ${error.message || error}`;
                statusBadge.innerHTML = '<span class="status-badge status-error">Failed</span>';
            } finally {
                runBtn.disabled = false;
            }
        }

        function delay(ms) {
            return new Promise(resolve => setTimeout(resolve, ms));
        }

        async function waitForResult(requestId) {
            const maxAttempts = 40;
            const waitMs = 5000;
            let lastError = null;

            for (let attempt = 1; attempt <= maxAttempts; attempt++) {
                try {
                    const refParam = config.ref ? `?ref=${encodeURIComponent(config.ref)}` : '';
                    const file = await apiRequest(`/contents/outputs/result.json${refParam}`);
                    if (file && file.content) {
                        const decoded = atob(file.content.replace(/\\s/g, ''));
                        const json = JSON.parse(decoded);
                        if (!requestId || !json.request_id || json.request_id === requestId) {
                            return json;
                        }
                    }
                } catch (error) {
                    lastError = error;
                    if (error && error.message && error.message.includes('404')) {
                        // Not ready yet; continue polling.
                    } else {
                        // Remember the error but keep retrying until timeout.
                    }
                }
                await delay(waitMs);
            }

            if (lastError) {
                throw lastError;
            }
            throw new Error('Timed out waiting for workflow result.');
        }

        function clearOutput() {
            document.getElementById('output').textContent = 'Output cleared.';
            document.getElementById('status-badge').innerHTML = '';
        }
        
        async function apiRequest(endpoint, method = 'GET', body = null, options = {}) {
            const { useAuth = true } = options;
            const headers = {
                'Accept': 'application/vnd.github.v3+json',
                    'X-GitHub-Api-Version': '2022-11-28'
            };
            
            if (useAuth && config.token) {
                const lower = config.token.toLowerCase();
                const useBearer = lower.startsWith('github_pat_') || lower.startsWith('ghs_') || lower.startsWith('ghu_');
                headers['Authorization'] = useBearer
                    ? `Bearer ${config.token}`
                    : `token ${config.token}`;
            }
            
            const requestOptions = {
                method: method,
                headers: headers
            };
            
            if (body) {
                requestOptions.body = JSON.stringify(body);
            }
            
            const url = `https://api.github.com/repos/${config.owner}/${config.repo}${endpoint}`;
            const response = await fetch(url, requestOptions);
                        
            if (!response.ok) {
                throw new Error(`GitHub API error: ${response.status} ${response.statusText}`);
            }
            
            if (method === 'POST' && response.status === 204) {
                return { success: true };
            }
            
            return await response.json();
        }
        
        function showStatus(message, type) {
            const container = document.getElementById('status-message');
            container.innerHTML = `<div class="${type}">${escapeHtml(message)}</div>`;
            setTimeout(() => {
                container.innerHTML = '';
            }, 5000);
        }
        
        function escapeHtml(text) {
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }
    </script>
</body>
</html>
