name: Build WASM Modules

on:
  workflow_dispatch:
  push:
    branches:
      - main
    paths:
      - '.github/workflows/build-wasm.yml'
      - 'baselines/**'
      - 'wasm/allocator_telemetry.cpp'
      - 'wasm/vf3_baseline_main.cpp'
      - 'src/\[CHATGPT\] Shortest Path.cpp'
      - 'src/\[GEMINI\] Shortest Path.cpp'
      - 'src/\[CHATGPT\] Subgraph Isomorphism.cpp'
      - 'src/\[GEMINI\] Subgraph Isomorphism.cpp'
      - 'src/\[CHATGPT\] Glasgow.cpp'
      - 'src/\[GEMINI\] Glasgow.cpp'

jobs:
  build-wasm:
    # Prevent infinite loops when this workflow commits WASM artifacts back to the repo.
    if: github.actor != 'github-actions[bot]'
    runs-on: ubuntu-latest
    permissions:
      contents: write
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          ref: ${{ github.ref }}
          submodules: recursive

      - name: Install Emscripten SDK
        run: |
          set -euo pipefail
          if [ ! -d emsdk ]; then
            git clone https://github.com/emscripten-core/emsdk.git emsdk
          fi
          cd emsdk
          ./emsdk install latest
          ./emsdk activate latest

      - name: Build VF3 WASM modules
        run: |
          set -euo pipefail
          source emsdk/emsdk_env.sh

          mkdir -p wasm

          echo "Patching vf3lib headers for Emscripten..."
          python3 - <<'PY'
          from pathlib import Path

          def patch_file(path, replacements, require=True):
              text = path.read_text(encoding="utf-8")
              original = text
              applied = 0
              for old, new in replacements:
                  if old in text:
                      count = text.count(old)
                      text = text.replace(old, new)
                      applied += count
              if require and text == original:
                  raise SystemExit(f"No expected patterns found in {path}")
              if text != original:
                  path.write_text(text, encoding="utf-8")
              print(f"Patched {path} ({applied} replacements)")

          # vf3lib mixes malloc/calloc with delete[] (UB) which can crash under wasm.
          # Patch the headers to use new[] (matching the delete[] in destructors).
          vf3_state = Path("baselines/vf3lib/include/VF3State.hpp")
          patch_file(vf3_state, [
              ("termin1 = (uint32_t*)calloc(n1, sizeof(uint32_t));", "termin1 = new uint32_t[n1]();"),
              ("termout1 = (uint32_t*)calloc(n1, sizeof(uint32_t));", "termout1 = new uint32_t[n1]();"),
              ("new1 = (uint32_t*)calloc(n1, sizeof(uint32_t));", "new1 = new uint32_t[n1]();"),
              ("t1both_len_c = (uint32_t**)malloc((n1 + 1) * sizeof(uint32_t*));", "t1both_len_c = new uint32_t*[n1 + 1];"),
              ("t1in_len_c = (uint32_t**)malloc((n1 + 1) * sizeof(uint32_t*));", "t1in_len_c = new uint32_t*[n1 + 1];"),
              ("t1out_len_c = (uint32_t**)malloc((n1 + 1) * sizeof(uint32_t*));", "t1out_len_c = new uint32_t*[n1 + 1];"),
              ("termin1_c = (uint32_t**)malloc(n1 * sizeof(uint32_t*));", "termin1_c = new uint32_t*[n1];"),
              ("termout1_c = (uint32_t**)malloc(n1 * sizeof(uint32_t*));", "termout1_c = new uint32_t*[n1];"),
              ("new1_c = (uint32_t**)malloc(n1 * sizeof(uint32_t*));", "new1_c = new uint32_t*[n1];"),
              ("core_len_c = (uint32_t*)calloc(classes_count, sizeof(uint32_t));", "core_len_c = new uint32_t[classes_count]();"),
              ("t2both_len_c = (uint32_t*)calloc(classes_count, sizeof(uint32_t));", "t2both_len_c = new uint32_t[classes_count]();"),
              ("t2in_len_c = (uint32_t*)calloc(classes_count, sizeof(uint32_t));", "t2in_len_c = new uint32_t[classes_count]();"),
              ("t2out_len_c = (uint32_t*)calloc(classes_count, sizeof(uint32_t));", "t2out_len_c = new uint32_t[classes_count]();"),
              ("termin1_c[i] = (int*)calloc(classes_count, sizeof(int));", "termin1_c[i] = new uint32_t[classes_count]();"),
              ("termout1_c[i] = (int*)calloc(classes_count, sizeof(int));", "termout1_c[i] = new uint32_t[classes_count]();"),
              ("new1_c[i] = (int*)calloc(classes_count, sizeof(int));", "new1_c[i] = new uint32_t[classes_count]();"),
              ("t1both_len_c[i] = (int*)calloc(classes_count, sizeof(int));", "t1both_len_c[i] = new uint32_t[classes_count]();"),
              ("t1in_len_c[i] = (int*)calloc(classes_count, sizeof(int));", "t1in_len_c[i] = new uint32_t[classes_count]();"),
              ("t1out_len_c[i] = (int*)calloc(classes_count, sizeof(int));", "t1out_len_c[i] = new uint32_t[classes_count]();"),
              # If the repo already patched int->uint32_t calloc, handle that too.
              ("termin1_c[i] = (uint32_t*)calloc(classes_count, sizeof(uint32_t));", "termin1_c[i] = new uint32_t[classes_count]();"),
              ("termout1_c[i] = (uint32_t*)calloc(classes_count, sizeof(uint32_t));", "termout1_c[i] = new uint32_t[classes_count]();"),
              ("new1_c[i] = (uint32_t*)calloc(classes_count, sizeof(uint32_t));", "new1_c[i] = new uint32_t[classes_count]();"),
              ("t1both_len_c[i] = (uint32_t*)calloc(classes_count, sizeof(uint32_t));", "t1both_len_c[i] = new uint32_t[classes_count]();"),
              ("t1in_len_c[i] = (uint32_t*)calloc(classes_count, sizeof(uint32_t));", "t1in_len_c[i] = new uint32_t[classes_count]();"),
              ("t1out_len_c[i] = (uint32_t*)calloc(classes_count, sizeof(uint32_t));", "t1out_len_c[i] = new uint32_t[classes_count]();"),
          ])

          vf3_sub = Path("baselines/vf3lib/include/VF3SubState.hpp")
          patch_file(vf3_sub, [
              ("termin1 = (uint32_t*)calloc(n1, sizeof(uint32_t));", "termin1 = new uint32_t[n1]();"),
              ("termout1 = (uint32_t*)calloc(n1, sizeof(uint32_t));", "termout1 = new uint32_t[n1]();"),
              ("new1 = (uint32_t*)calloc(n1, sizeof(uint32_t));", "new1 = new uint32_t[n1]();"),
              ("t1both_len_c = (uint32_t**)malloc((n1 + 1) * sizeof(uint32_t*));", "t1both_len_c = new uint32_t*[n1 + 1];"),
              ("t1in_len_c = (uint32_t**)malloc((n1 + 1) * sizeof(uint32_t*));", "t1in_len_c = new uint32_t*[n1 + 1];"),
              ("t1out_len_c = (uint32_t**)malloc((n1 + 1) * sizeof(uint32_t*));", "t1out_len_c = new uint32_t*[n1 + 1];"),
              ("termin1_c = (uint32_t**)malloc(n1 * sizeof(uint32_t*));", "termin1_c = new uint32_t*[n1];"),
              ("termout1_c = (uint32_t**)malloc(n1 * sizeof(uint32_t*));", "termout1_c = new uint32_t*[n1];"),
              ("new1_c = (uint32_t**)malloc(n1 * sizeof(uint32_t*));", "new1_c = new uint32_t*[n1];"),
              ("core_len_c = (uint32_t*)calloc(classes_count, sizeof(uint32_t));", "core_len_c = new uint32_t[classes_count]();"),
              ("t2both_len_c = (uint32_t*)calloc(classes_count, sizeof(uint32_t));", "t2both_len_c = new uint32_t[classes_count]();"),
              ("t2in_len_c = (uint32_t*)calloc(classes_count, sizeof(uint32_t));", "t2in_len_c = new uint32_t[classes_count]();"),
              ("t2out_len_c = (uint32_t*)calloc(classes_count, sizeof(uint32_t));", "t2out_len_c = new uint32_t[classes_count]();"),
              ("termin1_c[i] = (uint32_t*)calloc(classes_count, sizeof(uint32_t));", "termin1_c[i] = new uint32_t[classes_count]();"),
              ("termout1_c[i] = (uint32_t*)calloc(classes_count, sizeof(uint32_t));", "termout1_c[i] = new uint32_t[classes_count]();"),
              ("new1_c[i] = (uint32_t*)calloc(classes_count, sizeof(uint32_t));", "new1_c[i] = new uint32_t[classes_count]();"),
              ("t1both_len_c[i] = (uint32_t*)calloc(classes_count, sizeof(uint32_t));", "t1both_len_c[i] = new uint32_t[classes_count]();"),
              ("t1in_len_c[i] = (uint32_t*)calloc(classes_count, sizeof(uint32_t));", "t1in_len_c[i] = new uint32_t[classes_count]();"),
              ("t1out_len_c[i] = (uint32_t*)calloc(classes_count, sizeof(uint32_t));", "t1out_len_c[i] = new uint32_t[classes_count]();"),
          ])

          vf3_sorter = Path("baselines/vf3lib/include/VF3NodeSorter.hpp")
          patch_file(vf3_sorter, [
              ("return nodes_order;", "for (VF3SortingNode* n : nodes) delete n;\n\t\t\treturn nodes_order;"),
          ])
          PY

          common_flags=(
            -O3
            -DNDEBUG
            -s WASM=1
            -s MODULARIZE=1
            -s ENVIRONMENT=web
            -s ALLOW_MEMORY_GROWTH=1
            -s EXIT_RUNTIME=0
            -s FORCE_FILESYSTEM=1
            -s EXPORTED_RUNTIME_METHODS='["FS","callMain"]'
            -s EXPORTED_FUNCTIONS='["_main","_capstone_allocator_telemetry_reset","_capstone_allocator_telemetry_peak_bytes","_capstone_allocator_telemetry_current_bytes","_capstone_allocator_telemetry_alloc_count","_capstone_allocator_telemetry_free_count","_capstone_allocator_telemetry_dropped_records"]'
          )

          telemetry_flags=(
            "wasm/allocator_telemetry.cpp"
            -Wl,--wrap=malloc
            -Wl,--wrap=calloc
            -Wl,--wrap=realloc
            -Wl,--wrap=free
          )

          echo "Building VF3 baseline (vf3lib)..."
          em++ -std=c++11 \
            "${common_flags[@]}" \
            "${telemetry_flags[@]}" \
            -I "baselines/vf3lib/include" \
            -DVF3 \
            "wasm/vf3_baseline_main.cpp" \
            -s EXPORT_NAME=createVf3BaselineModule \
            -o "wasm/vf3_baseline.js"

          echo "Building VF3 Gemini..."
          em++ -std=c++17 \
            "${common_flags[@]}" \
            "${telemetry_flags[@]}" \
            -fexceptions \
            -s DISABLE_EXCEPTION_CATCHING=0 \
            "src/[GEMINI] Subgraph Isomorphism.cpp" \
            -s EXPORT_NAME=createVf3GeminiModule \
            -o "wasm/vf3_gemini.js"

          echo "Building VF3 ChatGPT..."
          em++ -std=c++17 \
            "${common_flags[@]}" \
            "${telemetry_flags[@]}" \
            -fexceptions \
            -s DISABLE_EXCEPTION_CATCHING=0 \
            "src/[CHATGPT] Subgraph Isomorphism.cpp" \
            -s EXPORT_NAME=createVf3ChatgptModule \
            -o "wasm/vf3_chatgpt.js"

          echo "Building Dijkstra baseline..."
          em++ -std=c++17 \
            "${common_flags[@]}" \
            "${telemetry_flags[@]}" \
            -fexceptions \
            -s DISABLE_EXCEPTION_CATCHING=0 \
            -I "baselines/nyaan-library" \
            "baselines/dijkstra_main.cpp" \
            -s EXPORT_NAME=createDijkstraBaselineModule \
            -o "wasm/dijkstra_baseline.js"

          echo "Building Dijkstra ChatGPT..."
          em++ -std=c++17 \
            "${common_flags[@]}" \
            "${telemetry_flags[@]}" \
            -fexceptions \
            -s DISABLE_EXCEPTION_CATCHING=0 \
            "src/[CHATGPT] Shortest Path.cpp" \
            -s EXPORT_NAME=createDijkstraLlmModule \
            -o "wasm/dijkstra_llm.js"

          echo "Building Dijkstra Gemini..."
          em++ -std=c++17 \
            "${common_flags[@]}" \
            "${telemetry_flags[@]}" \
            -fexceptions \
            -s DISABLE_EXCEPTION_CATCHING=0 \
            "src/[GEMINI] Shortest Path.cpp" \
            -s EXPORT_NAME=createDijkstraGeminiModule \
            -o "wasm/dijkstra_gemini.js"

          echo "Building Glasgow ChatGPT..."
          em++ -std=c++17 \
            "${common_flags[@]}" \
            "${telemetry_flags[@]}" \
            -fexceptions \
            -s DISABLE_EXCEPTION_CATCHING=0 \
            "src/[CHATGPT] Glasgow.cpp" \
            -s EXPORT_NAME=createGlasgowChatgptModule \
            -o "wasm/glasgow_chatgpt.js"

          echo "Building Glasgow Gemini..."
          em++ -std=c++17 \
            "${common_flags[@]}" \
            "${telemetry_flags[@]}" \
            -fexceptions \
            -s DISABLE_EXCEPTION_CATCHING=0 \
            "src/[GEMINI] Glasgow.cpp" \
            -s EXPORT_NAME=createGlasgowGeminiModule \
            -o "wasm/glasgow_gemini.js"

      - name: Attempt experimental baseline Glasgow WASM build
        continue-on-error: true
        run: |
          set -euo pipefail
          source emsdk/emsdk_env.sh
          mkdir -p wasm outputs .tmp
          LOG="$PWD/outputs/glasgow_baseline_wasm_attempt.log"
          : > "$LOG"
          echo "Attempting experimental baseline Glasgow WASM build (GMP + Emscripten)." | tee -a "$LOG"

          GMP_VERSION=6.3.0
          GMP_TAR="gmp-${GMP_VERSION}.tar.xz"
          GMP_URL_PRIMARY="https://gmplib.org/download/gmp/${GMP_TAR}"
          GMP_URL_GNU_MIRROR="https://ftpmirror.gnu.org/gmp/${GMP_TAR}"
          GMP_URL_GNU_FTP="https://ftp.gnu.org/gnu/gmp/${GMP_TAR}"
          GMP_ARCHIVE="$PWD/.tmp/${GMP_TAR}"
          GMP_SRC_DIR="$PWD/.tmp/gmp-${GMP_VERSION}"
          GMP_BUILD_DIR="$PWD/.tmp/gmp-build-emscripten"
          GMP_PREFIX="$PWD/.tmp/gmp-wasm-prefix"

          if [ ! -d "$GMP_SRC_DIR" ]; then
            echo "Downloading GMP ${GMP_VERSION}..." | tee -a "$LOG"
            rm -f "$GMP_ARCHIVE"
            download_ok=0
            for url in "$GMP_URL_PRIMARY" "$GMP_URL_GNU_MIRROR" "$GMP_URL_GNU_FTP"; do
              echo "Trying $url" | tee -a "$LOG"
              if curl -fL \
                --retry 5 \
                --retry-all-errors \
                --connect-timeout 20 \
                --max-time 600 \
                "$url" -o "$GMP_ARCHIVE" >>"$LOG" 2>&1; then
                download_ok=1
                break
              fi
            done
            if [ "$download_ok" -ne 1 ]; then
              echo "Failed to download GMP archive from all configured URLs." | tee -a "$LOG"
              exit 1
            fi
            tar -xJf "$GMP_ARCHIVE" -C "$PWD/.tmp" >>"$LOG" 2>&1
          fi

          rm -rf "$GMP_BUILD_DIR" "$GMP_PREFIX"
          mkdir -p "$GMP_BUILD_DIR" "$GMP_PREFIX"
          pushd "$GMP_BUILD_DIR" >/dev/null
          echo "Configuring GMP for Emscripten..." | tee -a "$LOG"
          emconfigure "$GMP_SRC_DIR/configure" \
            --host=wasm32-unknown-emscripten \
            --disable-shared \
            --enable-static \
            --disable-assembly \
            --enable-cxx \
            --prefix="$GMP_PREFIX" >>"$LOG" 2>&1
          echo "Building GMP..." | tee -a "$LOG"
          emmake make -j"$(nproc)" >>"$LOG" 2>&1
          emmake make install >>"$LOG" 2>&1
          popd >/dev/null

          echo "Patching Glasgow baseline CMake for an Emscripten attempt..." | tee -a "$LOG"
          python3 - <<'PY'
          from pathlib import Path

          def replace_once(path_str, old, new):
              path = Path(path_str)
              text = path.read_text(encoding="utf-8")
              if old not in text:
                  raise SystemExit(f"Expected pattern not found in {path}: {old[:80]!r}")
              path.write_text(text.replace(old, new, 1), encoding="utf-8")

          replace_once(
              "baselines/glasgow-subgraph-solver/CMakeLists.txt",
              "add_compile_options(-pthread)\n\nadd_link_options(-pthread)\n",
              "if (NOT EMSCRIPTEN)\n    add_compile_options(-pthread)\n    add_link_options(-pthread)\nendif()\n",
          )
          replace_once(
              "baselines/glasgow-subgraph-solver/gss/CMakeLists.txt",
              "if (NOT GMP_INCLUDE_DIR OR NOT GMP_LIBRARY OR NOT GMPXX_LIBRARY)\n    message(FATAL_ERROR \"Could not find GMP/GMPXX libraries. Please install GMP and try again.\")\nendif()\n",
              "if (NOT GMP_INCLUDE_DIR OR NOT GMP_LIBRARY OR (NOT GMPXX_LIBRARY AND NOT EMSCRIPTEN))\n    message(FATAL_ERROR \"Could not find required GMP libraries for this build.\")\nendif()\n",
          )
          replace_once(
              "baselines/glasgow-subgraph-solver/gss/CMakeLists.txt",
              "target_link_libraries(glasgow_subgraphs PUBLIC\n        ${cxxopts_LIBRARIES}\n        ${GMP_LIBRARY}\n        ${GMPXX_LIBRARY}\n)\n",
              "target_link_libraries(glasgow_subgraphs PUBLIC\n        ${cxxopts_LIBRARIES}\n        ${GMP_LIBRARY}\n)\nif (GMPXX_LIBRARY)\n    target_link_libraries(glasgow_subgraphs PUBLIC ${GMPXX_LIBRARY})\nendif()\n",
          )
          replace_once(
              "baselines/glasgow-subgraph-solver/gss/CMakeLists.txt",
              "add_executable(subgraph_isomorphism_test subgraph_isomorphism_test.cc)\n"
              "target_link_libraries(subgraph_isomorphism_test PRIVATE glasgow_subgraphs Catch2::Catch2WithMain)\n"
              "add_test(NAME subgraph_isomorphism_test COMMAND $<TARGET_FILE:subgraph_isomorphism_test>)\n\n"
              "add_executable(homomorphism_test homomorphism_test.cc)\n"
              "target_link_libraries(homomorphism_test PRIVATE glasgow_subgraphs Catch2::Catch2WithMain)\n"
              "add_test(NAME homomorphism_test COMMAND $<TARGET_FILE:homomorphism_test>)\n",
              "if (NOT EMSCRIPTEN)\n"
              "add_executable(subgraph_isomorphism_test subgraph_isomorphism_test.cc)\n"
              "target_link_libraries(subgraph_isomorphism_test PRIVATE glasgow_subgraphs Catch2::Catch2WithMain)\n"
              "add_test(NAME subgraph_isomorphism_test COMMAND $<TARGET_FILE:subgraph_isomorphism_test>)\n\n"
              "add_executable(homomorphism_test homomorphism_test.cc)\n"
              "target_link_libraries(homomorphism_test PRIVATE glasgow_subgraphs Catch2::Catch2WithMain)\n"
              "add_test(NAME homomorphism_test COMMAND $<TARGET_FILE:homomorphism_test>)\n"
              "endif()\n",
          )
          replace_once(
              "baselines/glasgow-subgraph-solver/src/CMakeLists.txt",
              "add_executable(glasgow_subgraph_solver glasgow_subgraph_solver.cc)\n"
              "target_link_libraries(glasgow_subgraph_solver PRIVATE cxxopts)\n",
              "add_executable(glasgow_subgraph_solver glasgow_subgraph_solver.cc)\n"
              "target_link_libraries(glasgow_subgraph_solver PRIVATE cxxopts)\n"
              "if (EMSCRIPTEN)\n"
              "  target_sources(glasgow_subgraph_solver PRIVATE ${CMAKE_SOURCE_DIR}/../../wasm/allocator_telemetry.cpp)\n"
              "  set_target_properties(glasgow_subgraph_solver PROPERTIES SUFFIX \".js\")\n"
              "  target_link_options(glasgow_subgraph_solver PRIVATE\n"
              "    -sWASM=1\n"
              "    -sMODULARIZE=1\n"
              "    -sEXPORT_NAME=createGlasgowBaselineModule\n"
              "    -sENVIRONMENT=web\n"
              "    -sALLOW_MEMORY_GROWTH=1\n"
              "    -sEXIT_RUNTIME=0\n"
              "    -sFORCE_FILESYSTEM=1\n"
              "    -Wl,--wrap=malloc\n"
              "    -Wl,--wrap=calloc\n"
              "    -Wl,--wrap=realloc\n"
              "    -Wl,--wrap=free\n"
              "    -sEXPORTED_RUNTIME_METHODS=[\\\"FS\\\",\\\"callMain\\\"]\n"
              "    -sEXPORTED_FUNCTIONS=[\\\"_main\\\",\\\"_capstone_allocator_telemetry_reset\\\",\\\"_capstone_allocator_telemetry_peak_bytes\\\",\\\"_capstone_allocator_telemetry_current_bytes\\\",\\\"_capstone_allocator_telemetry_alloc_count\\\",\\\"_capstone_allocator_telemetry_free_count\\\",\\\"_capstone_allocator_telemetry_dropped_records\\\"])\n"
              "endif()\n",
          )
          replace_once(
              "baselines/glasgow-subgraph-solver/src/glasgow_subgraph_solver.cc",
              "        if (options_vars.count(\"delay-thread-creation\") || options_vars.count(\"parallel\"))\n            params.delay_thread_creation = true;\n",
              "        if (options_vars.count(\"delay-thread-creation\") || options_vars.count(\"parallel\"))\n            params.delay_thread_creation = true;\n#ifdef __EMSCRIPTEN__\n        params.n_threads = 1;\n        params.delay_thread_creation = false;\n#endif\n",
          )
          replace_once(
              "baselines/glasgow-subgraph-solver/gss/homomorphism.cc",
              "            barrier wait_for_new_nogoods_barrier{n_threads}, synced_nogoods_barrier{n_threads};\n",
              "            barrier wait_for_new_nogoods_barrier{static_cast<ptrdiff_t>(n_threads)}, synced_nogoods_barrier{static_cast<ptrdiff_t>(n_threads)};\n",
          )
          PY

          rm -rf baselines/glasgow-subgraph-solver/build-wasm
          emcmake cmake -S baselines/glasgow-subgraph-solver -B baselines/glasgow-subgraph-solver/build-wasm \
            -DCMAKE_BUILD_TYPE=Release \
            -DGCS_DEBUG_MODE=OFF \
            -DGMP_INCLUDE_DIR="$GMP_PREFIX/include" \
            -DGMP_LIBRARY="$GMP_PREFIX/lib/libgmp.a" \
            -DGMPXX_LIBRARY="$GMP_PREFIX/lib/libgmpxx.a" >>"$LOG" 2>&1
          emmake make -C baselines/glasgow-subgraph-solver/build-wasm -j"$(nproc)" glasgow_subgraph_solver >>"$LOG" 2>&1

          cp baselines/glasgow-subgraph-solver/build-wasm/glasgow_subgraph_solver.js wasm/glasgow_baseline.js
          cp baselines/glasgow-subgraph-solver/build-wasm/glasgow_subgraph_solver.wasm wasm/glasgow_baseline.wasm
          echo "Glasgow baseline WASM build succeeded." | tee -a "$LOG"

      - name: Write WASM manifest
        run: |
          set -euo pipefail
          python3 - <<'PY'
          import datetime
          import json
          import os
          from pathlib import Path

          candidates = {
              "dijkstra_baseline": ("wasm/dijkstra_baseline.js", "wasm/dijkstra_baseline.wasm", "createDijkstraBaselineModule"),
              "dijkstra_llm": ("wasm/dijkstra_llm.js", "wasm/dijkstra_llm.wasm", "createDijkstraLlmModule"),
              "dijkstra_gemini": ("wasm/dijkstra_gemini.js", "wasm/dijkstra_gemini.wasm", "createDijkstraGeminiModule"),
              "vf3_baseline": ("wasm/vf3_baseline.js", "wasm/vf3_baseline.wasm", "createVf3BaselineModule"),
              "vf3_gemini": ("wasm/vf3_gemini.js", "wasm/vf3_gemini.wasm", "createVf3GeminiModule"),
              "vf3_chatgpt": ("wasm/vf3_chatgpt.js", "wasm/vf3_chatgpt.wasm", "createVf3ChatgptModule"),
              "glasgow_chatgpt": ("wasm/glasgow_chatgpt.js", "wasm/glasgow_chatgpt.wasm", "createGlasgowChatgptModule"),
              "glasgow_gemini": ("wasm/glasgow_gemini.js", "wasm/glasgow_gemini.wasm", "createGlasgowGeminiModule"),
              "glasgow_baseline": ("wasm/glasgow_baseline.js", "wasm/glasgow_baseline.wasm", "createGlasgowBaselineModule"),
          }
          modules = {}
          for module_id, (script_path, wasm_path, factory_name) in candidates.items():
              if not Path(script_path).exists() or not Path(wasm_path).exists():
                  continue
              modules[module_id] = {
                  "scriptPath": script_path,
                  "wasmPath": wasm_path,
                  "factoryName": factory_name,
              }

          data = {
              "schema_version": 1,
              "workflow": "Build WASM Modules",
              "workflow_file": ".github/workflows/build-wasm.yml",
              "generated_at_utc": datetime.datetime.now(datetime.timezone.utc).strftime("%Y-%m-%dT%H:%M:%SZ"),
              "git_sha": os.environ.get("GITHUB_SHA", ""),
              "git_ref_name": os.environ.get("GITHUB_REF_NAME", ""),
              "modules": modules,
          }

          Path("wasm").mkdir(parents=True, exist_ok=True)
          Path("wasm/manifest.json").write_text(json.dumps(data, indent=2) + "\n", encoding="utf-8")
          PY

      - name: Upload WASM modules artifact
        uses: actions/upload-artifact@v4
        with:
          name: wasm-modules
          path: |
            wasm/*.js
            wasm/*.wasm
            wasm/manifest.json
          if-no-files-found: error
          retention-days: 14

      - name: Upload Glasgow baseline WASM attempt log
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: glasgow-baseline-wasm-attempt-log
          path: outputs/glasgow_baseline_wasm_attempt.log
          if-no-files-found: warn
          retention-days: 14

      - name: Commit updated WASM artifacts
        run: |
          set -euo pipefail
          git config user.name "github-actions[bot]"
          git config user.email "41898282+github-actions[bot]@users.noreply.github.com"
          git add wasm
          if git diff --cached --quiet; then
            echo "No WASM changes to commit."
            exit 0
          fi
          git commit -m "Update WASM modules"
          git push origin "HEAD:${GITHUB_REF_NAME}"
