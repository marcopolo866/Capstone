name: Build WASM Modules

on:
  workflow_dispatch:
  push:
    branches:
      - main
    paths-ignore:
      - wasm/**

jobs:
  build-wasm:
    # Prevent infinite loops when this workflow commits WASM artifacts back to the repo.
    if: github.actor != 'github-actions[bot]'
    runs-on: ubuntu-latest
    permissions:
      contents: write
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          ref: ${{ github.ref }}
          submodules: recursive

      - name: Install Emscripten SDK
        run: |
          set -euo pipefail
          if [ ! -d emsdk ]; then
            git clone https://github.com/emscripten-core/emsdk.git emsdk
          fi
          cd emsdk
          ./emsdk install latest
          ./emsdk activate latest

      - name: Build VF3 WASM modules
        run: |
          set -euo pipefail
          source emsdk/emsdk_env.sh

          mkdir -p wasm

          echo "Patching vf3lib headers for Emscripten..."
          python3 - <<'PY'
          from pathlib import Path

          def patch_file(path, replacements, require=True):
              text = path.read_text(encoding="utf-8")
              original = text
              applied = 0
              for old, new in replacements:
                  if old in text:
                      count = text.count(old)
                      text = text.replace(old, new)
                      applied += count
              if require and text == original:
                  raise SystemExit(f"No expected patterns found in {path}")
              if text != original:
                  path.write_text(text, encoding="utf-8")
              print(f"Patched {path} ({applied} replacements)")

          # vf3lib mixes malloc/calloc with delete[] (UB) which can crash under wasm.
          # Patch the headers to use new[] (matching the delete[] in destructors).
          vf3_state = Path("baselines/vf3lib/include/VF3State.hpp")
          patch_file(vf3_state, [
              ("termin1 = (uint32_t*)calloc(n1, sizeof(uint32_t));", "termin1 = new uint32_t[n1]();"),
              ("termout1 = (uint32_t*)calloc(n1, sizeof(uint32_t));", "termout1 = new uint32_t[n1]();"),
              ("new1 = (uint32_t*)calloc(n1, sizeof(uint32_t));", "new1 = new uint32_t[n1]();"),
              ("t1both_len_c = (uint32_t**)malloc((n1 + 1) * sizeof(uint32_t*));", "t1both_len_c = new uint32_t*[n1 + 1];"),
              ("t1in_len_c = (uint32_t**)malloc((n1 + 1) * sizeof(uint32_t*));", "t1in_len_c = new uint32_t*[n1 + 1];"),
              ("t1out_len_c = (uint32_t**)malloc((n1 + 1) * sizeof(uint32_t*));", "t1out_len_c = new uint32_t*[n1 + 1];"),
              ("termin1_c = (uint32_t**)malloc(n1 * sizeof(uint32_t*));", "termin1_c = new uint32_t*[n1];"),
              ("termout1_c = (uint32_t**)malloc(n1 * sizeof(uint32_t*));", "termout1_c = new uint32_t*[n1];"),
              ("new1_c = (uint32_t**)malloc(n1 * sizeof(uint32_t*));", "new1_c = new uint32_t*[n1];"),
              ("core_len_c = (uint32_t*)calloc(classes_count, sizeof(uint32_t));", "core_len_c = new uint32_t[classes_count]();"),
              ("t2both_len_c = (uint32_t*)calloc(classes_count, sizeof(uint32_t));", "t2both_len_c = new uint32_t[classes_count]();"),
              ("t2in_len_c = (uint32_t*)calloc(classes_count, sizeof(uint32_t));", "t2in_len_c = new uint32_t[classes_count]();"),
              ("t2out_len_c = (uint32_t*)calloc(classes_count, sizeof(uint32_t));", "t2out_len_c = new uint32_t[classes_count]();"),
              ("termin1_c[i] = (int*)calloc(classes_count, sizeof(int));", "termin1_c[i] = new uint32_t[classes_count]();"),
              ("termout1_c[i] = (int*)calloc(classes_count, sizeof(int));", "termout1_c[i] = new uint32_t[classes_count]();"),
              ("new1_c[i] = (int*)calloc(classes_count, sizeof(int));", "new1_c[i] = new uint32_t[classes_count]();"),
              ("t1both_len_c[i] = (int*)calloc(classes_count, sizeof(int));", "t1both_len_c[i] = new uint32_t[classes_count]();"),
              ("t1in_len_c[i] = (int*)calloc(classes_count, sizeof(int));", "t1in_len_c[i] = new uint32_t[classes_count]();"),
              ("t1out_len_c[i] = (int*)calloc(classes_count, sizeof(int));", "t1out_len_c[i] = new uint32_t[classes_count]();"),
              # If the repo already patched int->uint32_t calloc, handle that too.
              ("termin1_c[i] = (uint32_t*)calloc(classes_count, sizeof(uint32_t));", "termin1_c[i] = new uint32_t[classes_count]();"),
              ("termout1_c[i] = (uint32_t*)calloc(classes_count, sizeof(uint32_t));", "termout1_c[i] = new uint32_t[classes_count]();"),
              ("new1_c[i] = (uint32_t*)calloc(classes_count, sizeof(uint32_t));", "new1_c[i] = new uint32_t[classes_count]();"),
              ("t1both_len_c[i] = (uint32_t*)calloc(classes_count, sizeof(uint32_t));", "t1both_len_c[i] = new uint32_t[classes_count]();"),
              ("t1in_len_c[i] = (uint32_t*)calloc(classes_count, sizeof(uint32_t));", "t1in_len_c[i] = new uint32_t[classes_count]();"),
              ("t1out_len_c[i] = (uint32_t*)calloc(classes_count, sizeof(uint32_t));", "t1out_len_c[i] = new uint32_t[classes_count]();"),
          ])

          vf3_sub = Path("baselines/vf3lib/include/VF3SubState.hpp")
          patch_file(vf3_sub, [
              ("termin1 = (uint32_t*)calloc(n1, sizeof(uint32_t));", "termin1 = new uint32_t[n1]();"),
              ("termout1 = (uint32_t*)calloc(n1, sizeof(uint32_t));", "termout1 = new uint32_t[n1]();"),
              ("new1 = (uint32_t*)calloc(n1, sizeof(uint32_t));", "new1 = new uint32_t[n1]();"),
              ("t1both_len_c = (uint32_t**)malloc((n1 + 1) * sizeof(uint32_t*));", "t1both_len_c = new uint32_t*[n1 + 1];"),
              ("t1in_len_c = (uint32_t**)malloc((n1 + 1) * sizeof(uint32_t*));", "t1in_len_c = new uint32_t*[n1 + 1];"),
              ("t1out_len_c = (uint32_t**)malloc((n1 + 1) * sizeof(uint32_t*));", "t1out_len_c = new uint32_t*[n1 + 1];"),
              ("termin1_c = (uint32_t**)malloc(n1 * sizeof(uint32_t*));", "termin1_c = new uint32_t*[n1];"),
              ("termout1_c = (uint32_t**)malloc(n1 * sizeof(uint32_t*));", "termout1_c = new uint32_t*[n1];"),
              ("new1_c = (uint32_t**)malloc(n1 * sizeof(uint32_t*));", "new1_c = new uint32_t*[n1];"),
              ("core_len_c = (uint32_t*)calloc(classes_count, sizeof(uint32_t));", "core_len_c = new uint32_t[classes_count]();"),
              ("t2both_len_c = (uint32_t*)calloc(classes_count, sizeof(uint32_t));", "t2both_len_c = new uint32_t[classes_count]();"),
              ("t2in_len_c = (uint32_t*)calloc(classes_count, sizeof(uint32_t));", "t2in_len_c = new uint32_t[classes_count]();"),
              ("t2out_len_c = (uint32_t*)calloc(classes_count, sizeof(uint32_t));", "t2out_len_c = new uint32_t[classes_count]();"),
              ("termin1_c[i] = (uint32_t*)calloc(classes_count, sizeof(uint32_t));", "termin1_c[i] = new uint32_t[classes_count]();"),
              ("termout1_c[i] = (uint32_t*)calloc(classes_count, sizeof(uint32_t));", "termout1_c[i] = new uint32_t[classes_count]();"),
              ("new1_c[i] = (uint32_t*)calloc(classes_count, sizeof(uint32_t));", "new1_c[i] = new uint32_t[classes_count]();"),
              ("t1both_len_c[i] = (uint32_t*)calloc(classes_count, sizeof(uint32_t));", "t1both_len_c[i] = new uint32_t[classes_count]();"),
              ("t1in_len_c[i] = (uint32_t*)calloc(classes_count, sizeof(uint32_t));", "t1in_len_c[i] = new uint32_t[classes_count]();"),
              ("t1out_len_c[i] = (uint32_t*)calloc(classes_count, sizeof(uint32_t));", "t1out_len_c[i] = new uint32_t[classes_count]();"),
          ])

          vf3_sorter = Path("baselines/vf3lib/include/VF3NodeSorter.hpp")
          patch_file(vf3_sorter, [
              ("return nodes_order;", "for (VF3SortingNode* n : nodes) delete n;\n\t\t\treturn nodes_order;"),
          ])
          PY

          common_flags=(
            -O3
            -DNDEBUG
            -s WASM=1
            -s MODULARIZE=1
            -s ENVIRONMENT=web
            -s ALLOW_MEMORY_GROWTH=1
            -s EXIT_RUNTIME=0
            -s FORCE_FILESYSTEM=1
            -s EXPORTED_RUNTIME_METHODS='["FS","callMain"]'
          )

          echo "Building VF3 baseline (vf3lib)..."
          em++ -std=c++11 \
            "${common_flags[@]}" \
            -I "baselines/vf3lib/include" \
            -DVF3 \
            "wasm/vf3_baseline_main.cpp" \
            -s EXPORT_NAME=createVf3BaselineModule \
            -o "wasm/vf3_baseline.js"

          echo "Building VF3 Gemini..."
          em++ -std=c++17 \
            "${common_flags[@]}" \
            -fexceptions \
            -s DISABLE_EXCEPTION_CATCHING=0 \
            "src/[GEMINI] Subgraph Isomorphism.cpp" \
            -s EXPORT_NAME=createVf3GeminiModule \
            -o "wasm/vf3_gemini.js"

          echo "Building VF3 ChatGPT..."
          em++ -std=c++17 \
            "${common_flags[@]}" \
            -fexceptions \
            -s DISABLE_EXCEPTION_CATCHING=0 \
            "src/[CHATGPT] Subgraph Isomorphism.cpp" \
            -s EXPORT_NAME=createVf3ChatgptModule \
            -o "wasm/vf3_chatgpt.js"

          echo "Building Dijkstra baseline..."
          em++ -std=c++17 \
            "${common_flags[@]}" \
            -fexceptions \
            -s DISABLE_EXCEPTION_CATCHING=0 \
            -I "baselines/nyaan-library" \
            "baselines/dijkstra_main.cpp" \
            -s EXPORT_NAME=createDijkstraBaselineModule \
            -o "wasm/dijkstra_baseline.js"

          echo "Building Dijkstra ChatGPT..."
          em++ -std=c++17 \
            "${common_flags[@]}" \
            -fexceptions \
            -s DISABLE_EXCEPTION_CATCHING=0 \
            "src/[CHATGPT] Shortest Path.cpp" \
            -s EXPORT_NAME=createDijkstraLlmModule \
            -o "wasm/dijkstra_llm.js"

          echo "Building Dijkstra Gemini..."
          em++ -std=c++17 \
            "${common_flags[@]}" \
            -fexceptions \
            -s DISABLE_EXCEPTION_CATCHING=0 \
            "src/[GEMINI] Shortest Path.cpp" \
            -s EXPORT_NAME=createDijkstraGeminiModule \
            -o "wasm/dijkstra_gemini.js"

      - name: Commit updated WASM artifacts
        run: |
          set -euo pipefail
          git config user.name "github-actions[bot]"
          git config user.email "41898282+github-actions[bot]@users.noreply.github.com"
          git add wasm
          if git diff --cached --quiet; then
            echo "No WASM changes to commit."
            exit 0
          fi
          git commit -m "Update WASM modules"
          git push origin "HEAD:${GITHUB_REF_NAME}"
