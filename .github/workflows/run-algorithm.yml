name: Run Algorithm

on:
  workflow_dispatch:
    inputs:
      algorithm:
        description: 'Algorithm to run'
        required: true
        type: choice
        options:
          - dijkstra
          - glasgow
          - vf3
      input_files:
        description: 'Comma-separated input file paths'
        required: true
        type: string
      request_id:
        description: 'Client request identifier'
        required: false
        type: string

jobs:
  run-algorithm:
    runs-on: ubuntu-latest
    
    permissions:
      contents: write
      actions: write
    
    steps:
      - name: Checkout repository
        uses: actions/checkout@v3
        with:
          submodules: recursive

      - name: Cache VF3 build
        uses: actions/cache@v3
        with:
          path: baselines/vf3lib/bin
          key: ${{ runner.os }}-vf3-${{ hashFiles('baselines/vf3lib/**') }}
          restore-keys: |
            ${{ runner.os }}-vf3-

      - name: Cache VF3 (src) build
        uses: actions/cache@v3
        with:
          path: src/vf3  # <-- The path to the compiled executable
          key: ${{ runner.os }}-vf3-src-${{ hashFiles('src/VF3.cpp') }} # <-- The source file
          restore-keys: |
            ${{ runner.os }}-vf3-src-

      - name: Cache Glasgow build
        uses: actions/cache@v3
        with:
          path: baselines/glasgow-subgraph-solver/build
          key: ${{ runner.os }}-glasgow-${{ hashFiles('baselines/glasgow-subgraph-solver/**') }}
          restore-keys: |
            ${{ runner.os }}-glasgow-
      
      - name: Cache Dijkstra build
        uses: actions/cache@v3
        with:
          path: baselines/dijkstra
          key: ${{ runner.os }}-dijkstra-${{ hashFiles('baselines/Dijkastra Shortest Path/**') }}
      
      - name: Install minimal dependencies
        run: |
          # Only install jq, everything else is already available
          sudo apt-get update -qq && sudo apt-get install -y -qq jq
      
      - name: Build algorithms
        run: |
          echo "Building algorithms..."
          
          # Build Dijkstra (only if not cached)
          if [ -f "baselines/Dijkastra Shortest Path/dijkstra_main.cpp" ] && [ ! -x "baselines/dijkstra" ]; then
            echo "Building Dijkstra..."
            g++ -std=c++17 -O3 \
              -I "baselines/Dijkastra Shortest Path" \
              "baselines/Dijkastra Shortest Path/dijkstra_main.cpp" \
              "baselines/Dijkastra Shortest Path/dijkstra.cpp" \
              -o "baselines/dijkstra"
            echo "✓ Dijkstra built successfully"
          elif [ -x "baselines/dijkstra" ]; then
            echo "✓ Dijkstra already built (cached)"
          fi
          
          # Build Glasgow Subgraph Solver (only if not cached)
          if [ -d "baselines/glasgow-subgraph-solver" ]; then
            if [ ! -f "baselines/glasgow-subgraph-solver/build/glasgow_subgraph_solver" ]; then
              echo "Building Glasgow Subgraph Solver..."
              cd baselines/glasgow-subgraph-solver
              mkdir -p build
              cd build
              cmake .. -DCMAKE_BUILD_TYPE=Release -DCMAKE_CXX_FLAGS="-O3"
              make -j$(nproc)
              cd ../../..
              echo "✓ Glasgow built successfully"
            else
              echo "✓ Glasgow already built (cached)"
            fi
          fi

          # Build VF3 Subgraph Solver (only if not cached)
          if [ -d "baselines/vf3lib" ]; then
            if [ ! -f "baselines/vf3lib/bin/vf3" ]; then
              echo "Building VF3 Subgraph Solver..."
              # Go into the directory that contains the Makefile
              cd baselines/vf3lib
              # Run make for the 'vf3' target
              # The Makefile will create the 'bin/vf3' executable
              make vf3
              # Go back to the root directory
              cd ../..
              echo "✓ VF3 built successfully"
            else
              echo "✓ VF3 already built (cached)"
            fi
          fi

          if [ -f "src/VF3.cpp" ]; then
            if [ ! -x "src/vf3" ]; then
              echo "Building second VF3 (from src)..."
              g++ -std=c++17 -O3 \
                "src/VF3.cpp" \
                -o "src/vf3"
              echo "✓ Second VF3 built successfully"
            else
              echo "✓ Second VF3 already built (cached)"
            fi
          fi

          if [ -f "src/chatVF3.cpp" ]; then
            if [ ! -x "src/chatvf3" ]; then
              echo "Building Third VF3 (from src)..."
              g++ -std=c++17 -O3 \
                "src/chatVF3.cpp" \
                -o "src/chatvf3"
              echo "✓ Third VF3 built successfully"
            else
              echo "✓ Third VF3 already built (cached)"
            fi
          fi
          
          echo "Build complete!"
      
      - name: Run algorithm
        id: run
        run: |
          set -euo pipefail
          ALGORITHM="${{ github.event.inputs.algorithm }}"
          INPUT_FILES="${{ github.event.inputs.input_files }}"
          
          mkdir -p outputs
          : > outputs/result.txt
          
          # Parse input files
          IFS=',' read -ra FILES <<< "$INPUT_FILES"

          if [ "$ALGORITHM" = "dijkstra" ] && [ ${#FILES[@]} -lt 1 ]; then
            echo "No input file provided for Dijkstra." >&2
            exit 1
          fi
          if [ "$ALGORITHM" != "dijkstra" ] && [ ${#FILES[@]} -lt 2 ]; then
            echo "Pattern/target files are required for $ALGORITHM." >&2
            exit 1
          fi

          run_capture() {
            local _out_var="$1"
            local _dur_var="$2"
            shift 2
            local tmp
            tmp=$(mktemp)
            local start_ns end_ns
            start_ns=$(date +%s%N)
            set +e
            "$@" >"$tmp" 2>&1
            local status=$?
            set -e
            end_ns=$(date +%s%N)
            local duration_ns=$((end_ns - start_ns))
            printf -v "$_out_var" "%s" "$(cat "$tmp")"
            printf -v "$_dur_var" "%s" "$duration_ns"
            rm -f "$tmp"
            return $status
          }

          format_ns() {
            python - "$1" <<'PY'
import sys
print(f"{int(sys.argv[1]):,}")
PY
          }
          
          EXIT_CODE=0
          
          case "$ALGORITHM" in
            dijkstra)
              if ! run_capture result_out runtime_ns ./baselines/dijkstra "${FILES[0]}"; then
                EXIT_CODE=1
              fi
              runtime_fmt=$(format_ns "$runtime_ns")
              {
                echo "[Dijkstra]"
                echo "$result_out"
                echo "Runtime (ns): $runtime_fmt"
              } >> outputs/result.txt
              ;;
            glasgow)
              if ! run_capture glasgow_first_out glasgow_first_ns ./baselines/glasgow-subgraph-solver/build/glasgow_subgraph_solver --format lad "${FILES[0]}" "${FILES[1]}"; then
                EXIT_CODE=1
              fi
              if ! run_capture glasgow_all_out glasgow_all_ns ./baselines/glasgow-subgraph-solver/build/glasgow_subgraph_solver --count-solutions --format lad "${FILES[0]}" "${FILES[1]}"; then
                EXIT_CODE=1
              fi
              glasgow_first_fmt=$(format_ns "$glasgow_first_ns")
              glasgow_all_fmt=$(format_ns "$glasgow_all_ns")
              {
                echo "[Glasgow Subgraph Solver]"
                echo "$glasgow_all_out"
                echo "Runtime (ns): first=$glasgow_first_fmt all=$glasgow_all_fmt"
              } >> outputs/result.txt
              ;;
            vf3)
              if ! run_capture vf3_base_first_out vf3_base_first_ns ./baselines/vf3lib/bin/vf3 -F "${FILES[0]}" "${FILES[1]}"; then
                EXIT_CODE=1
              fi
              if ! run_capture vf3_base_all_out vf3_base_all_ns ./baselines/vf3lib/bin/vf3 "${FILES[0]}" "${FILES[1]}"; then
                EXIT_CODE=1
              fi
              vf3_base_first_fmt=$(format_ns "$vf3_base_first_ns")
              vf3_base_all_fmt=$(format_ns "$vf3_base_all_ns")
              vf3_base_result_line=$(echo "$vf3_base_all_out" | head -n1)
              vf3_base_result=$(echo "$vf3_base_result_line" | awk '{print $1}')
              if [ -z "$vf3_base_result" ]; then
                vf3_base_result="$vf3_base_result_line"
              fi
              {
                echo "[VF3 baseline]"
                echo "$vf3_base_result"
                echo "Runtime (ns): first=$vf3_base_first_fmt all=$vf3_base_all_fmt"
                echo
              } >> outputs/result.txt
              
              if ! run_capture vf3_first_out vf3_first_ns ./src/vf3 --first-only "${FILES[0]}" "${FILES[1]}"; then
                EXIT_CODE=1
              fi
              if ! run_capture vf3_all_out vf3_all_ns ./src/vf3 "${FILES[0]}" "${FILES[1]}"; then
                EXIT_CODE=1
              fi
              vf3_first_fmt=$(format_ns "$vf3_first_ns")
              vf3_all_fmt=$(format_ns "$vf3_all_ns")
              {
                echo "[VF3 Gemini]"
                echo "$vf3_all_out"
                echo "Runtime (ns): first=$vf3_first_fmt all=$vf3_all_fmt"
                echo
              } >> outputs/result.txt
              
              if ! run_capture chatvf3_first_out chatvf3_first_ns ./src/chatvf3 --first-only "${FILES[0]}" "${FILES[1]}"; then
                EXIT_CODE=1
              fi
              if ! run_capture chatvf3_all_out chatvf3_all_ns ./src/chatvf3 "${FILES[0]}" "${FILES[1]}"; then
                EXIT_CODE=1
              fi
              chatvf3_first_fmt=$(format_ns "$chatvf3_first_ns")
              chatvf3_all_fmt=$(format_ns "$chatvf3_all_ns")
              {
                echo "[VF3 ChatGPT]"
                echo "$chatvf3_all_out"
                echo "Runtime (ns): first=$chatvf3_first_fmt all=$chatvf3_all_fmt"
              } >> outputs/result.txt
              ;;
            *)
              echo "Unknown algorithm: $ALGORITHM" >&2
              exit 1
              ;;
          esac
          
          echo "EXIT_CODE=$EXIT_CODE" >> "$GITHUB_OUTPUT"
          exit "$EXIT_CODE"
      
      - name: Create result JSON
        run: |
          ALGORITHM="${{ github.event.inputs.algorithm }}"
          EXIT_CODE="${{ steps.run.outputs.EXIT_CODE }}"
          TIMESTAMP=$(date -u +"%Y-%m-%d %H:%M:%S UTC")
          REQUEST_ID="${{ github.event.inputs.request_id }}"
          
          if [ "$EXIT_CODE" = "0" ]; then
            STATUS="success"
            OUTPUT=$(cat outputs/result.txt 2>/dev/null || echo "No output")
            ERROR=""
          else
            STATUS="error"
            OUTPUT=""
            ERROR=$(cat outputs/result.txt 2>/dev/null || echo "Unknown error")
          fi
          
          # Create JSON with proper escaping
          jq -n \
            --arg algo "$ALGORITHM" \
            --arg ts "$TIMESTAMP" \
            --arg status "$STATUS" \
            --arg output "$OUTPUT" \
            --arg error "$ERROR" \
            --arg requestId "$REQUEST_ID" \
            '{
              algorithm: $algo,
              timestamp: $ts,
              status: $status,
              output: $output,
              error: $error,
              request_id: $requestId
            }' > outputs/result.json
      
      - name: Commit results
        run: |
          git config --local user.email "github-actions[bot]@users.noreply.github.com"
          git config --local user.name "github-actions[bot]"
          git add outputs/result.json
          git commit -m "Add algorithm results [skip ci]" || echo "No changes to commit"
          git push
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
