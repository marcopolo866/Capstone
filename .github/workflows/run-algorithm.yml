name: Run Algorithm

on:
  workflow_dispatch:
    inputs:
      algorithm:
        description: 'Algorithm to run'
        required: true
        type: choice
        options:
          - dijkstra
          - glasgow
          - vf3
      input_files:
        description: 'Comma-separated input file paths'
        required: true
        type: string
      request_id:
        description: 'Client request identifier'
        required: false
        type: string
  repository_dispatch:
    types:
      - run-algorithm

jobs:
  run-algorithm:
    runs-on: ubuntu-latest
    env:
      ALGORITHM_INPUT: ${{ github.event.inputs.algorithm || github.event.client_payload.algorithm }}
      INPUT_FILES_INPUT: ${{ github.event.inputs.input_files || github.event.client_payload.input_files }}
      REQUEST_ID_INPUT: ${{ github.event.inputs.request_id || github.event.client_payload.request_id }}

    permissions:
      contents: write
      actions: read

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Download prebuilt binaries
        id: binaries
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          BRANCH: ${{ github.ref_name }}
          REPO: ${{ github.repository }}
        run: |
          mkdir -p outputs
          : > outputs/binaries_download_error.txt
          set +e
          output="$(python - <<'PY'
          import json
          import os
          import stat
          import subprocess
          import urllib.parse
          import urllib.request
          import zipfile
          from pathlib import Path

          repo = os.environ.get("REPO")
          branch = os.environ.get("BRANCH") or "main"
          token = os.environ.get("GITHUB_TOKEN")
          workflow_file = "build-binaries.yml"
          artifact_name = "algorithm-binaries-linux"

          if not repo:
              raise SystemExit("REPO env var is missing")
          if not token:
              raise SystemExit("GITHUB_TOKEN env var is missing")

          api_base = f"https://api.github.com/repos/{repo}"
          headers = {
              "Accept": "application/vnd.github+json",
              "Authorization": f"Bearer {token}",
              "X-GitHub-Api-Version": "2022-11-28",
              "User-Agent": "capstone-download-binaries",
          }


          def api_get(path: str):
              url = api_base + path
              req = urllib.request.Request(url, headers=headers)
              with urllib.request.urlopen(req) as resp:
                  return json.load(resp)


          query = urllib.parse.urlencode({"branch": branch, "status": "success", "per_page": 1})
          runs = api_get(f"/actions/workflows/{workflow_file}/runs?{query}")
          workflow_runs = runs.get("workflow_runs") or []
          if not workflow_runs:
              raise SystemExit(
                  f"No successful '{workflow_file}' runs found for branch '{branch}'. "
                  "Run the 'Build Binaries' workflow first."
              )

          run_id = workflow_runs[0].get("id")
          if not run_id:
              raise SystemExit("Could not read run_id from workflow_runs response.")

          artifacts = api_get(f"/actions/runs/{run_id}/artifacts")
          items = artifacts.get("artifacts") or []
          artifact = next(
              (a for a in items if a.get("name") == artifact_name and not a.get("expired")), None
          )
          if not artifact:
              available = ", ".join(sorted({a.get("name", "") for a in items if a.get("name")}))
              raise SystemExit(
                  f"Artifact '{artifact_name}' not found on run {run_id}. "
                  f"Available artifacts: {available or '(none)'}"
              )

          artifact_id = artifact.get("id")
          if not artifact_id:
              raise SystemExit("Could not read artifact id.")

          zip_path = Path("binaries.zip")
          download_url = f"{api_base}/actions/artifacts/{artifact_id}/zip"
          subprocess.run(
              [
                  "curl",
                  "-fsSL",
                  "-o",
                  str(zip_path),
                  "-H",
                  f"Authorization: Bearer {token}",
                  "-H",
                  "Accept: application/vnd.github+json",
                  download_url,
              ],
              check=True,
          )

          with zipfile.ZipFile(zip_path, "r") as zf:
              zf.extractall(".")

          expected = [
              "baselines/dijkstra",
              "src/dijkstra_llm",
              "src/vf3",
              "src/chatvf3",
              "baselines/vf3lib/bin/vf3",
              "baselines/glasgow-subgraph-solver/build/glasgow_subgraph_solver",
          ]

          missing = []
          for rel in expected:
              p = Path(rel)
              if not p.exists():
                  missing.append(rel)
                  continue
              mode = p.stat().st_mode
              p.chmod(mode | stat.S_IXUSR | stat.S_IXGRP | stat.S_IXOTH)

          if missing:
              raise SystemExit(
                  f"Missing expected binaries after extraction: {', '.join(missing)}"
              )

          print(f"Downloaded artifacts from run {run_id} (artifact_id={artifact_id}).")
          PY
          )"
          status=$?
          set -e
          if [ $status -eq 0 ]; then
            echo "READY=1" >> "$GITHUB_OUTPUT"
          else
            echo "READY=0" >> "$GITHUB_OUTPUT"
            echo "$output" > outputs/binaries_download_error.txt
            echo "$output"
          fi
          exit 0

      - name: Run algorithm
        id: run
        run: |
          set -uo pipefail
          ALGORITHM="${ALGORITHM_INPUT:-}"
          INPUT_FILES="${INPUT_FILES_INPUT:-}"
          REQUEST_ID="${REQUEST_ID_INPUT:-}"

          mkdir -p outputs
          : > outputs/result.txt

          if [ "${{ steps.binaries.outputs.READY }}" != "1" ]; then
            echo "Failed to download prebuilt binaries." >> outputs/result.txt
            if [ -s outputs/binaries_download_error.txt ]; then
              cat outputs/binaries_download_error.txt >> outputs/result.txt
            fi
            echo "EXIT_CODE=1" >> "$GITHUB_OUTPUT"
            echo "REQUEST_ID=${REQUEST_ID}" >> "$GITHUB_OUTPUT"
            exit 0
          fi

          # Parse input files
          IFS=',' read -ra FILES <<< "$INPUT_FILES"

          if [ "$ALGORITHM" = "dijkstra" ] && [ ${#FILES[@]} -lt 1 ]; then
            echo "No input file provided for Dijkstra." >> outputs/result.txt
            echo "EXIT_CODE=1" >> "$GITHUB_OUTPUT"
            echo "REQUEST_ID=${REQUEST_ID}" >> "$GITHUB_OUTPUT"
            exit 0
          fi
          if [ "$ALGORITHM" != "dijkstra" ] && [ ${#FILES[@]} -lt 2 ]; then
            echo "Pattern/target files are required for $ALGORITHM." >> outputs/result.txt
            echo "EXIT_CODE=1" >> "$GITHUB_OUTPUT"
            echo "REQUEST_ID=${REQUEST_ID}" >> "$GITHUB_OUTPUT"
            exit 0
          fi

          run_capture() {
            local _out_var=$1
            local _dur_var=$2
            shift 2
            tmp=$(mktemp)
            local start_ns end_ns duration_ms
            start_ns=$(date +%s%N)
            set +e
            "$@" >"$tmp" 2>&1
            local status=$?
            set -e
            end_ns=$(date +%s%N)
            duration_ms=$(python - <<'PY' "$start_ns" "$end_ns"
          import sys
          start=int(sys.argv[1]); end=int(sys.argv[2])
          print(f"{(end - start)/1_000_000:.3f}")
          PY
            )
            printf -v "$_out_var" "%s" "$(cat "$tmp")"
            printf -v "$_dur_var" "%s" "$duration_ms"
            rm -f "$tmp"
            return $status
          }

          EXIT_CODE=0

          case "$ALGORITHM" in
            dijkstra)
              if ! run_capture dijkstra_baseline_out dijkstra_baseline_ms ./baselines/dijkstra "${FILES[0]}"; then
                EXIT_CODE=1
                echo "[Dijkstra Baseline] failed to run." >> outputs/result.txt
              else
                {
                  echo "[Dijkstra Baseline]"
                  echo "$dijkstra_baseline_out"
                  echo "Runtime (ms): $dijkstra_baseline_ms"
                  echo
                } >> outputs/result.txt
              fi
              if ! run_capture dijkstra_llm_out dijkstra_llm_ms ./src/dijkstra_llm "${FILES[0]}"; then
                EXIT_CODE=1
                echo "[Dijkstra LLM] failed to run." >> outputs/result.txt
              else
                {
                  echo "[Dijkstra LLM]"
                  echo "$dijkstra_llm_out"
                  echo "Runtime (ms): $dijkstra_llm_ms"
                } >> outputs/result.txt
              fi
              ;;
            glasgow)
              if ! run_capture glasgow_first_out glasgow_first_ms ./baselines/glasgow-subgraph-solver/build/glasgow_subgraph_solver --format lad "${FILES[0]}" "${FILES[1]}"; then
                EXIT_CODE=1
                echo "[Glasgow Subgraph Solver] first-solution run failed." >> outputs/result.txt
              fi
              if ! run_capture glasgow_all_out glasgow_all_ms ./baselines/glasgow-subgraph-solver/build/glasgow_subgraph_solver --count-solutions --format lad "${FILES[0]}" "${FILES[1]}"; then
                EXIT_CODE=1
                echo "[Glasgow Subgraph Solver] all-solutions run failed." >> outputs/result.txt
              fi
              if [ -n "${glasgow_all_out:-}" ]; then
                {
                  echo "[Glasgow Subgraph Solver]"
                  echo "$glasgow_all_out"
                  if [ -n "${glasgow_first_ms:-}" ] && [ -n "${glasgow_all_ms:-}" ]; then
                    echo "Runtime (ms): first=$glasgow_first_ms all=$glasgow_all_ms"
                  fi
                } >> outputs/result.txt
              fi
              ;;
            vf3)
              if ! run_capture vf3_base_first_out vf3_base_first_ms ./baselines/vf3lib/bin/vf3 -F "${FILES[0]}" "${FILES[1]}"; then
                EXIT_CODE=1
                echo "[VF3 baseline] first-solution run failed." >> outputs/result.txt
              fi
              if ! run_capture vf3_base_all_out vf3_base_all_ms ./baselines/vf3lib/bin/vf3 "${FILES[0]}" "${FILES[1]}"; then
                EXIT_CODE=1
                echo "[VF3 baseline] all-solutions run failed." >> outputs/result.txt
              fi
              if [ -n "${vf3_base_all_out:-}" ]; then
                vf3_base_result_line=$(echo "$vf3_base_all_out" | head -n1)
                vf3_base_result=$(echo "$vf3_base_result_line" | awk '{print $1}')
                if [ -z "$vf3_base_result" ]; then
                  vf3_base_result="$vf3_base_result_line"
                fi
                {
                  echo "[VF3 baseline]"
                  echo "$vf3_base_result"
                  if [ -n "${vf3_base_first_ms:-}" ] && [ -n "${vf3_base_all_ms:-}" ]; then
                    echo "Runtime (ms): first=$vf3_base_first_ms all=$vf3_base_all_ms"
                  fi
                  echo
                } >> outputs/result.txt
              fi

              if ! run_capture vf3_first_out vf3_first_ms ./src/vf3 --first-only "${FILES[0]}" "${FILES[1]}"; then
                EXIT_CODE=1
                echo "[VF3 Gemini] first-solution run failed." >> outputs/result.txt
              fi
              if ! run_capture vf3_all_out vf3_all_ms ./src/vf3 "${FILES[0]}" "${FILES[1]}"; then
                EXIT_CODE=1
                echo "[VF3 Gemini] all-solutions run failed." >> outputs/result.txt
              fi
              if [ -n "${vf3_all_out:-}" ]; then
                {
                  echo "[VF3 Gemini]"
                  echo "$vf3_all_out"
                  if [ -n "${vf3_first_ms:-}" ] && [ -n "${vf3_all_ms:-}" ]; then
                    echo "Runtime (ms): first=$vf3_first_ms all=$vf3_all_ms"
                  fi
                  echo
                } >> outputs/result.txt
              fi

              if ! run_capture chatvf3_first_out chatvf3_first_ms ./src/chatvf3 --first-only "${FILES[0]}" "${FILES[1]}"; then
                EXIT_CODE=1
                echo "[VF3 ChatGPT] first-solution run failed." >> outputs/result.txt
              fi
              if ! run_capture chatvf3_all_out chatvf3_all_ms ./src/chatvf3 "${FILES[0]}" "${FILES[1]}"; then
                EXIT_CODE=1
                echo "[VF3 ChatGPT] all-solutions run failed." >> outputs/result.txt
              fi
              if [ -n "${chatvf3_all_out:-}" ]; then
                {
                  echo "[VF3 ChatGPT]"
                  echo "$chatvf3_all_out"
                  if [ -n "${chatvf3_first_ms:-}" ] && [ -n "${chatvf3_all_ms:-}" ]; then
                    echo "Runtime (ms): first=$chatvf3_first_ms all=$chatvf3_all_ms"
                  fi
                } >> outputs/result.txt
              fi
              ;;
            *)
              echo "Unknown algorithm: $ALGORITHM" >> outputs/result.txt
              EXIT_CODE=1
              ;;
          esac

          echo "EXIT_CODE=$EXIT_CODE" >> "$GITHUB_OUTPUT"
          echo "REQUEST_ID=${REQUEST_ID}" >> "$GITHUB_OUTPUT"
          # Always exit 0 so later steps run and results are committed
          exit 0

      - name: Create result JSON
        if: always()
        env:
          EXIT_CODE: ${{ steps.run.outputs.EXIT_CODE }}
        run: |
          python - <<'PY'
          import datetime
          import json
          import os
          from pathlib import Path

          algorithm = os.environ.get("ALGORITHM_INPUT", "")
          exit_code = os.environ.get("EXIT_CODE", "")
          request_id = os.environ.get("REQUEST_ID_INPUT", "")
          timestamp = datetime.datetime.utcnow().strftime("%Y-%m-%d %H:%M:%S UTC")

          result_txt = Path("outputs/result.txt")
          text = ""
          if result_txt.exists():
              text = result_txt.read_text(encoding="utf-8", errors="replace")

          if exit_code == "0":
              status = "success"
              output = text or "No output"
              error = ""
          else:
              status = "error"
              output = ""
              error = text or "Unknown error"

          Path("outputs").mkdir(parents=True, exist_ok=True)
          data = {
              "algorithm": algorithm,
              "timestamp": timestamp,
              "status": status,
              "output": output,
              "error": error,
              "request_id": request_id,
          }
          Path("outputs/result.json").write_text(
              json.dumps(data, indent=2) + "\n", encoding="utf-8"
          )
          PY

      - name: Commit results
        if: always()
        run: |
          git config --local user.email "github-actions[bot]@users.noreply.github.com"
          git config --local user.name "github-actions[bot]"
          git add outputs/result.json
          git commit -m "Add algorithm results [skip ci]" || echo "No changes to commit"
          git push
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
