name: Run Algorithm
run-name: Run Algorithm (${{ github.event.inputs.request_id || github.event.client_payload.request_id || github.run_id }})

on:
  workflow_dispatch:
    inputs:
      algorithm:
        description: 'Algorithm to run'
        required: true
        type: choice
        options:
          - dijkstra
          - glasgow
          - vf3
      iterations:
        description: 'Number of benchmark iterations'
        required: false
        type: string
        default: '1'
      warmup:
        description: 'Number of warmup runs (per test)'
        required: false
        type: string
        default: '1'
      input_mode:
        description: 'Input mode (premade or generate)'
        required: false
        type: choice
        options:
          - premade
          - generate
        default: generate
      n:
        description: 'Generated graph node count (N)'
        required: false
        type: string
        default: '100'
      k:
        description: 'Generated pattern node count (k)'
        required: false
        type: string
        default: '10'
      density:
        description: 'Generated graph density (0-1)'
        required: false
        type: string
        default: '0.01'
      seed:
        description: 'Generator seed (optional)'
        required: false
        type: string
      input_files:
        description: 'Comma-separated input file paths'
        required: false
        type: string
        default: ''
      request_id:
        description: 'Client request identifier'
        required: false
        type: string
  repository_dispatch:
    types:
      - run-algorithm

jobs:
  run-algorithm:
    runs-on: ubuntu-latest
    env:
      ALGORITHM_INPUT: ${{ github.event.inputs.algorithm || github.event.client_payload.algorithm }}
      ITERATIONS_INPUT: ${{ github.event.inputs.iterations || github.event.client_payload.iterations }}
      WARMUP_INPUT: ${{ github.event.inputs.warmup || github.event.client_payload.warmup }}
      INPUT_MODE_INPUT: ${{ github.event.inputs.input_mode || github.event.client_payload.input_mode }}
      GENERATOR_N_INPUT: ${{ github.event.inputs.n || github.event.client_payload.n }}
      GENERATOR_K_INPUT: ${{ github.event.inputs.k || github.event.client_payload.k }}
      GENERATOR_DENSITY_INPUT: ${{ github.event.inputs.density || github.event.client_payload.density }}
      GENERATOR_SEED_INPUT: ${{ github.event.inputs.seed || github.event.client_payload.seed }}
      INPUT_FILES_INPUT: ${{ github.event.inputs.input_files || github.event.client_payload.input_files }}
      REQUEST_ID_INPUT: ${{ github.event.inputs.request_id || github.event.client_payload.request_id }}

    permissions:
      contents: write
      actions: read
      checks: write

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Resolve build-binaries artifact
        id: binaries_meta
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          BRANCH: ${{ github.ref_name }}
          REPO: ${{ github.repository }}
        run: |
          set +e
          output="$(python - <<'PY'
          import json
          import os
          import urllib.parse
          import urllib.request

          repo = os.environ.get("REPO")
          branch = os.environ.get("BRANCH") or "main"
          token = os.environ.get("GITHUB_TOKEN")
          workflow_file = "build-binaries.yml"
          artifact_name = "algorithm-binaries-linux"

          if not repo:
              raise SystemExit("REPO env var is missing")
          if not token:
              raise SystemExit("GITHUB_TOKEN env var is missing")

          api_base = f"https://api.github.com/repos/{repo}"
          headers = {
              "Accept": "application/vnd.github+json",
              "Authorization": f"Bearer {token}",
              "X-GitHub-Api-Version": "2022-11-28",
              "User-Agent": "capstone-download-binaries",
          }

          def api_get(path: str):
              url = api_base + path
              req = urllib.request.Request(url, headers=headers)
              with urllib.request.urlopen(req) as resp:
                  return json.load(resp)

          query = urllib.parse.urlencode({"branch": branch, "status": "success", "per_page": 1})
          runs = api_get(f"/actions/workflows/{workflow_file}/runs?{query}")
          workflow_runs = runs.get("workflow_runs") or []
          if not workflow_runs:
              raise SystemExit(
                  f"No successful '{workflow_file}' runs found for branch '{branch}'. "
                  "Run the 'Build Binaries' workflow first."
              )

          run_id = workflow_runs[0].get("id")
          if not run_id:
              raise SystemExit("Could not read run_id from workflow_runs response.")

          artifacts = api_get(f"/actions/runs/{run_id}/artifacts")
          items = artifacts.get("artifacts") or []
          artifact = next(
              (a for a in items if a.get("name") == artifact_name and not a.get("expired")), None
          )
          if not artifact:
              available = ", ".join(sorted({a.get("name", "") for a in items if a.get("name")}))
              raise SystemExit(
                  f"Artifact '{artifact_name}' not found on run {run_id}. "
                  f"Available artifacts: {available or '(none)'}"
              )

          artifact_id = artifact.get("id")
          if not artifact_id:
              raise SystemExit("Could not read artifact id.")

          print(f"{run_id} {artifact_id}")
          PY
          )"
          status=$?
          set -e
          if [ $status -eq 0 ]; then
            run_id="$(echo "$output" | awk '{print $1}')"
            artifact_id="$(echo "$output" | awk '{print $2}')"
            echo "RUN_ID=$run_id" >> "$GITHUB_OUTPUT"
            echo "ARTIFACT_ID=$artifact_id" >> "$GITHUB_OUTPUT"
          else
            echo "$output"
            echo "RUN_ID=" >> "$GITHUB_OUTPUT"
            echo "ARTIFACT_ID=" >> "$GITHUB_OUTPUT"
          fi

      - name: Cache binaries
        id: binaries_cache
        uses: actions/cache@v4
        with:
          path: |
            baselines/dijkstra
            src/dijkstra_llm
            src/vf3
            src/chatvf3
            baselines/vf3lib/bin/vf3
            baselines/glasgow-subgraph-solver/build/glasgow_subgraph_solver
          key: ${{ runner.os }}-algorithm-binaries-${{ steps.binaries_meta.outputs.RUN_ID || 'unknown' }}

      - name: Download prebuilt binaries
        id: binaries
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          BRANCH: ${{ github.ref_name }}
          REPO: ${{ github.repository }}
          CACHE_HIT: ${{ steps.binaries_cache.outputs.cache-hit }}
          BINARIES_RUN_ID: ${{ steps.binaries_meta.outputs.RUN_ID }}
          BINARIES_ARTIFACT_ID: ${{ steps.binaries_meta.outputs.ARTIFACT_ID }}
        run: |
          mkdir -p outputs
          : > outputs/binaries_download_error.txt
          expected=(
            "baselines/dijkstra"
            "src/dijkstra_llm"
            "src/vf3"
            "src/chatvf3"
            "baselines/vf3lib/bin/vf3"
            "baselines/glasgow-subgraph-solver/build/glasgow_subgraph_solver"
          )
          if [ "${CACHE_HIT:-}" = "true" ]; then
            missing=0
            for rel in "${expected[@]}"; do
              if [ ! -f "$rel" ]; then
                missing=1
                break
              fi
            done
            if [ "$missing" -eq 0 ]; then
              chmod +x "${expected[@]}"
              echo "READY=1" >> "$GITHUB_OUTPUT"
              echo "Using cached binaries (run_id=${BINARIES_RUN_ID:-unknown})."
              exit 0
            fi
          fi
          set +e
          output="$(python - <<'PY'
          import json
          import os
          import stat
          import subprocess
          import urllib.parse
          import urllib.request
          import zipfile
          from pathlib import Path

          repo = os.environ.get("REPO")
          branch = os.environ.get("BRANCH") or "main"
          token = os.environ.get("GITHUB_TOKEN")
          artifact_id = os.environ.get("BINARIES_ARTIFACT_ID")
          run_id = os.environ.get("BINARIES_RUN_ID")
          workflow_file = "build-binaries.yml"
          artifact_name = "algorithm-binaries-linux"

          if not repo:
              raise SystemExit("REPO env var is missing")
          if not token:
              raise SystemExit("GITHUB_TOKEN env var is missing")

          api_base = f"https://api.github.com/repos/{repo}"
          headers = {
              "Accept": "application/vnd.github+json",
              "Authorization": f"Bearer {token}",
              "X-GitHub-Api-Version": "2022-11-28",
              "User-Agent": "capstone-download-binaries",
          }


          def api_get(path: str):
              url = api_base + path
              req = urllib.request.Request(url, headers=headers)
              with urllib.request.urlopen(req) as resp:
                  return json.load(resp)

          if not run_id or not artifact_id:
              query = urllib.parse.urlencode({"branch": branch, "status": "success", "per_page": 1})
              runs = api_get(f"/actions/workflows/{workflow_file}/runs?{query}")
              workflow_runs = runs.get("workflow_runs") or []
              if not workflow_runs:
                  raise SystemExit(
                      f"No successful '{workflow_file}' runs found for branch '{branch}'. "
                      "Run the 'Build Binaries' workflow first."
                  )

              run_id = workflow_runs[0].get("id")
              if not run_id:
                  raise SystemExit("Could not read run_id from workflow_runs response.")

              artifacts = api_get(f"/actions/runs/{run_id}/artifacts")
              items = artifacts.get("artifacts") or []
              artifact = next(
                  (a for a in items if a.get("name") == artifact_name and not a.get("expired")), None
              )
              if not artifact:
                  available = ", ".join(sorted({a.get("name", "") for a in items if a.get("name")}))
                  raise SystemExit(
                      f"Artifact '{artifact_name}' not found on run {run_id}. "
                      f"Available artifacts: {available or '(none)'}"
                  )

              artifact_id = artifact.get("id")
              if not artifact_id:
                  raise SystemExit("Could not read artifact id.")


          zip_path = Path("binaries.zip")
          download_url = f"{api_base}/actions/artifacts/{artifact_id}/zip"
          subprocess.run(
              [
                  "curl",
                  "-fsSL",
                  "-o",
                  str(zip_path),
                  "-H",
                  f"Authorization: Bearer {token}",
                  "-H",
                  "Accept: application/vnd.github+json",
                  download_url,
              ],
              check=True,
          )

          with zipfile.ZipFile(zip_path, "r") as zf:
              zf.extractall(".")

          expected = [
              "baselines/dijkstra",
              "src/dijkstra_llm",
              "src/vf3",
              "src/chatvf3",
              "baselines/vf3lib/bin/vf3",
              "baselines/glasgow-subgraph-solver/build/glasgow_subgraph_solver",
          ]

          missing = []
          for rel in expected:
              p = Path(rel)
              if not p.exists():
                  missing.append(rel)
                  continue
              mode = p.stat().st_mode
              p.chmod(mode | stat.S_IXUSR | stat.S_IXGRP | stat.S_IXOTH)

          if missing:
              raise SystemExit(
                  f"Missing expected binaries after extraction: {', '.join(missing)}"
              )

          print(f"Downloaded artifacts from run {run_id} (artifact_id={artifact_id}).")
          PY
          )"
          status=$?
          set -e
          if [ $status -eq 0 ]; then
            echo "READY=1" >> "$GITHUB_OUTPUT"
          else
            echo "READY=0" >> "$GITHUB_OUTPUT"
            echo "$output" > outputs/binaries_download_error.txt
            echo "$output"
          fi
          exit 0

      - name: Run algorithm
        id: run
        env:
          BINARIES_READY: ${{ steps.binaries.outputs.READY }}
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          set -uo pipefail
          ALGORITHM="${ALGORITHM_INPUT:-}"
          ITERATIONS_RAW="${ITERATIONS_INPUT:-1}"
          WARMUP_RAW="${WARMUP_INPUT:-1}"
          INPUT_MODE="${INPUT_MODE_INPUT:-premade}"
          GENERATOR_N="${GENERATOR_N_INPUT:-}"
          GENERATOR_K="${GENERATOR_K_INPUT:-}"
          GENERATOR_DENSITY="${GENERATOR_DENSITY_INPUT:-0.05}"
          GENERATOR_SEED_RAW="${GENERATOR_SEED_INPUT:-}"
          INPUT_FILES="${INPUT_FILES_INPUT:-}"
          REQUEST_ID="${REQUEST_ID_INPUT:-}"

          mkdir -p outputs
          : > outputs/result.txt
          RUN_STARTED_NS="$(date +%s%N)"
          GEN_COUNTER=0
          SOLVER_TIME_MS_TOTAL=""
          SEED_USED=""

          if [ "$INPUT_MODE" = "generate" ]; then
            seed_trimmed="$(echo "${GENERATOR_SEED_RAW}" | tr -d '\r' | xargs)"
            if [[ "${seed_trimmed}" =~ ^-?[0-9]+$ ]]; then
              SEED_USED="${seed_trimmed}"
            else
              SEED_USED="$(python -c "import secrets; print(secrets.randbits(31))")"
            fi
          fi

          generate_graphs_for_run() {
            local variant="$1"
            local iter="$2"
            local gen_dir="outputs/generated/${ALGORITHM}/${variant}/iter_${iter}"
            mkdir -p "$gen_dir"
            GEN_COUNTER=$((GEN_COUNTER + 1))
            local seed
            seed="$(python -c "import sys; base=int(sys.argv[1]); offset=int(sys.argv[2]); print(base + offset)" "$SEED_USED" "$GEN_COUNTER")"
            local output status files
            local -a gen_args
            gen_args=(--algorithm "$ALGORITHM" --n "$GENERATOR_N" --density "$GENERATOR_DENSITY" --seed "$seed" --out-dir "$gen_dir")
            if [ "$ALGORITHM" != "dijkstra" ]; then
              gen_args+=(--k "$GENERATOR_K")
            fi
            output="$(python utilities/generate_graphs.py "${gen_args[@]}" 2>&1)"
            status=$?
            files="$(echo "$output" | tail -n 1 | tr -d '\r')"
            if [ $status -ne 0 ] || [ -z "$files" ]; then
              echo "Graph generation failed." >> outputs/result.txt
              if [ -n "$output" ]; then
                echo "$output" >> outputs/result.txt
              fi
              return 1
            fi
            IFS=',' read -ra FILES <<< "$files"
            return 0
          }

          finish_run() {
            local end_ns duration_ms
            end_ns="$(date +%s%N)"
            if [ -n "${SOLVER_TIME_MS_TOTAL:-}" ]; then
              duration_ms="$SOLVER_TIME_MS_TOTAL"
            else
              duration_ms="$(python -c "import sys; start=int(sys.argv[1]); end=int(sys.argv[2]); print(f'{(end-start)/1_000_000:.3f}')" "$RUN_STARTED_NS" "$end_ns")"
            fi
            echo "RUN_DURATION_MS=$duration_ms" >> "$GITHUB_OUTPUT"
          }

          if [ "${BINARIES_READY:-}" != "1" ]; then
            echo "Failed to download prebuilt binaries." >> outputs/result.txt
            if [ -s outputs/binaries_download_error.txt ]; then
              cat outputs/binaries_download_error.txt >> outputs/result.txt
            fi
            finish_run
            echo "EXIT_CODE=1" >> "$GITHUB_OUTPUT"
            echo "REQUEST_ID=${REQUEST_ID}" >> "$GITHUB_OUTPUT"
            exit 0
          fi

          if [ "$INPUT_MODE" != "generate" ]; then
            # Parse input files
            IFS=',' read -ra FILES <<< "$INPUT_FILES"

            if [ "$ALGORITHM" = "dijkstra" ] && [ ${#FILES[@]} -lt 1 ]; then
              echo "No input file provided for Dijkstra." >> outputs/result.txt
              finish_run
              echo "EXIT_CODE=1" >> "$GITHUB_OUTPUT"
              echo "REQUEST_ID=${REQUEST_ID}" >> "$GITHUB_OUTPUT"
              exit 0
            fi
            if [ "$ALGORITHM" != "dijkstra" ] && [ ${#FILES[@]} -lt 2 ]; then
              echo "Pattern/target files are required for $ALGORITHM." >> outputs/result.txt
              finish_run
              echo "EXIT_CODE=1" >> "$GITHUB_OUTPUT"
              echo "REQUEST_ID=${REQUEST_ID}" >> "$GITHUB_OUTPUT"
              exit 0
            fi

            # Normalize graph inputs so the smaller graph is always the pattern/subgraph.
            # (Order of clicks in the UI should not matter.)
            if [ "$ALGORITHM" = "glasgow" ] || [ "$ALGORITHM" = "vf3" ]; then
              graph_nodes() {
                python - <<'PY' "$1" 2>/dev/null || true
          import re
          import sys

          path = sys.argv[1]
          try:
              with open(path, "r", encoding="utf-8", errors="ignore") as fh:
                  for line in fh:
                      s = line.strip()
                      if not s or s.startswith("#"):
                          continue
                      m = re.match(r"^(-?\\d+)", s)
                      if m:
                          print(int(m.group(1)))
                          raise SystemExit(0)
          except OSError:
              pass
          print("")
          PY
              }

              file0="${FILES[0]}"
              file1="${FILES[1]}"
              nodes0="$(graph_nodes "$file0")"
              nodes1="$(graph_nodes "$file1")"
              size0="$(stat -c%s "$file0" 2>/dev/null || echo 0)"
              size1="$(stat -c%s "$file1" 2>/dev/null || echo 0)"

              swap=0
              if [[ "$nodes0" =~ ^[0-9]+$ ]] && [[ "$nodes1" =~ ^[0-9]+$ ]]; then
                if [ "$nodes0" -gt "$nodes1" ]; then
                  swap=1
                elif [ "$nodes0" -eq "$nodes1" ] && [ "$size0" -gt "$size1" ]; then
                  swap=1
                fi
              else
                if [ "$size0" -gt "$size1" ]; then
                  swap=1
                fi
              fi

              if [ "$swap" -eq 1 ]; then
                FILES[0]="$file1"
                FILES[1]="$file0"
                echo "Normalized inputs (smaller graph used as pattern/subgraph)." >> outputs/result.txt
              fi
            fi
          fi

          ITERATIONS="1"
          if [[ "$ITERATIONS_RAW" =~ ^[0-9]+$ ]] && [ "$ITERATIONS_RAW" -ge 1 ]; then
            ITERATIONS="$ITERATIONS_RAW"
          fi

          WARMUP="0"
          if [[ "${WARMUP_RAW}" =~ ^[0-9]+$ ]]; then
            WARMUP="${WARMUP_RAW}"
          fi
          if [ "$WARMUP" -gt 50 ]; then
            WARMUP="50"
          fi
          WARMUP_REQUESTED="$WARMUP"

          # Progress reporting via GitHub Checks API (used by the web UI progress bar).
          PROGRESS_ENABLED=0
          CHECK_RUN_ID=""
          CHECK_RUN_NAME="Capstone Benchmark Progress (${REQUEST_ID:-${GITHUB_RUN_ID}})"
          PROGRESS_STAGE="setup"
          PROGRESS_SETUP_TOTAL=0
          PROGRESS_SETUP_DONE=0
          PROGRESS_TOTAL_UNITS=0
          PROGRESS_TOTAL_TICKS=0
          PROGRESS_DONE_TICKS=0
          PROGRESS_PHASE=""
          PROGRESS_LAST_UPDATE_EPOCH=0
          PROGRESS_LAST_REPORTED_SETUP=-1
          PROGRESS_LAST_REPORTED_TICKS=-1

          # Progress semantics: count "per program per iteration".
          # For Glasgow and VF3, both "first" and "all" runs are counted together as 1 unit.
          UNITS_PER_ITER=0
          TICKS_PER_ITER=0
          TICKS_PER_UNIT=1
          case "$ALGORITHM" in
            dijkstra)
              UNITS_PER_ITER=2   # baseline + llm
              TICKS_PER_ITER=2   # both are directly ticked
              ;;
            glasgow)
              UNITS_PER_ITER=3   # baseline + gemini + chatgpt
              TICKS_PER_ITER=6   # each has first + all (each ticks)
              ;;
            vf3)
              UNITS_PER_ITER=3   # baseline + gemini + chatgpt
              TICKS_PER_ITER=3   # each runs once (reports first + all)
              ;;
            *)
              UNITS_PER_ITER=0
              TICKS_PER_ITER=0
              ;;
          esac
          if [ "$UNITS_PER_ITER" -gt 0 ] && [ "$TICKS_PER_ITER" -gt 0 ]; then
            TICKS_PER_UNIT=$((TICKS_PER_ITER / UNITS_PER_ITER))
          fi
          PROGRESS_TOTAL_UNITS=$((ITERATIONS * UNITS_PER_ITER))
          PROGRESS_TOTAL_TICKS=$((ITERATIONS * TICKS_PER_ITER))
          PROGRESS_SETUP_TOTAL=$((WARMUP_REQUESTED * TICKS_PER_ITER))
          if [ "$PROGRESS_SETUP_TOTAL" -le 0 ]; then
            PROGRESS_SETUP_TOTAL=1
          fi

          progress_create_check_run() {
            if [ -z "${GITHUB_TOKEN:-}" ] || [ "$PROGRESS_TOTAL_UNITS" -le 0 ] || [ "$PROGRESS_TOTAL_TICKS" -le 0 ]; then
              return 0
            fi

            CHECK_RUN_ID="$(
              python - <<'PY' "$CHECK_RUN_NAME" "$REQUEST_ID" "$ALGORITHM" "$ITERATIONS" "$UNITS_PER_ITER" "$TICKS_PER_UNIT" "$PROGRESS_TOTAL_UNITS" "$PROGRESS_TOTAL_TICKS" "$PROGRESS_STAGE" "$PROGRESS_SETUP_DONE" "$PROGRESS_SETUP_TOTAL" || true
          import datetime
          import json
          import os
          import sys
          import urllib.request

          name = sys.argv[1]
          request_id = sys.argv[2]
          algorithm = sys.argv[3]
          iterations = int(sys.argv[4])
          units_per_iter = int(sys.argv[5])
          ticks_per_unit = int(sys.argv[6])
          total_units = int(sys.argv[7])
          total_ticks = int(sys.argv[8])
          stage = sys.argv[9] if len(sys.argv) > 9 else "tests"
          setup_done = int(sys.argv[10]) if len(sys.argv) > 10 else 0
          setup_total = int(sys.argv[11]) if len(sys.argv) > 11 else 0

          token = os.environ.get("GITHUB_TOKEN", "")
          repo = os.environ.get("GITHUB_REPOSITORY", "")
          sha = os.environ.get("GITHUB_SHA", "")
          if not token or not repo or not sha:
              print("")
              raise SystemExit(0)

          url = f"https://api.github.com/repos/{repo}/check-runs"
          headers = {
              "Accept": "application/vnd.github+json",
              "Authorization": f"Bearer {token}",
              "X-GitHub-Api-Version": "2022-11-28",
              "User-Agent": "capstone-algorithm-runner",
          }
          progress = {
              "request_id": request_id,
              "algorithm": algorithm,
              "iterations": iterations,
              "tests_per_iteration": units_per_iter,
              "ticks_per_unit": ticks_per_unit,
              "total_ticks": total_ticks,
              "completed": 0,
              "total": total_units,
              "percent": 0.0,
              "phase": "",
              "run_id": os.environ.get("GITHUB_RUN_ID", ""),
              "stage": stage,
              "setup_completed": setup_done,
              "setup_total": setup_total,
              "tests_completed": 0,
              "tests_total": total_units,
          }

          setup_percent = (setup_done / setup_total * 100.0) if setup_total else 0.0
          summary = f"Progress: 0/{total_units} (0.0%)"
          if stage == "setup":
              summary = f"Setup: {setup_done}/{setup_total} ({setup_percent:.1f}%)"
          payload = {
              "name": name,
              "head_sha": sha,
              "status": "in_progress",
              "started_at": datetime.datetime.now(datetime.timezone.utc).strftime("%Y-%m-%dT%H:%M:%SZ"),
              "output": {
                  "title": name,
                  "summary": summary,
                  "text": json.dumps(progress),
              },
          }
          req = urllib.request.Request(
              url,
              data=json.dumps(payload).encode("utf-8"),
              headers=headers,
              method="POST",
          )
          try:
              with urllib.request.urlopen(req, timeout=10) as resp:
                  data = json.load(resp)
              print(data.get("id", ""))
          except Exception:
              print("")
          PY
            )"

            if [[ "$CHECK_RUN_ID" =~ ^[0-9]+$ ]]; then
              PROGRESS_ENABLED=1
              PROGRESS_LAST_UPDATE_EPOCH=$(date +%s)
              PROGRESS_LAST_REPORTED_SETUP=0
              PROGRESS_LAST_REPORTED_TICKS=0
            fi
            return 0
          }

          progress_update_check_run() {
            local status="$1"
            local conclusion="${2:-}"
            if [ "${PROGRESS_ENABLED:-0}" != "1" ] || [ -z "${CHECK_RUN_ID:-}" ]; then
              return 0
            fi

            python - <<'PY' "$CHECK_RUN_ID" "$CHECK_RUN_NAME" "$REQUEST_ID" "$ALGORITHM" "$ITERATIONS" "$UNITS_PER_ITER" "$TICKS_PER_UNIT" "$PROGRESS_DONE_TICKS" "$PROGRESS_TOTAL_TICKS" "$PROGRESS_TOTAL_UNITS" "$PROGRESS_STAGE" "$PROGRESS_SETUP_DONE" "$PROGRESS_SETUP_TOTAL" "$PROGRESS_PHASE" "$status" "$conclusion" || true
          import datetime
          import json
          import os
          import sys
          import urllib.request

          check_id = sys.argv[1]
          name = sys.argv[2]
          request_id = sys.argv[3]
          algorithm = sys.argv[4]
          iterations = int(sys.argv[5])
          units_per_iter = int(sys.argv[6])
          ticks_per_unit = int(sys.argv[7])
          completed_ticks = int(sys.argv[8])
          total_ticks = int(sys.argv[9])
          total_units = int(sys.argv[10])
          stage = sys.argv[11] if len(sys.argv) > 11 else "tests"
          setup_done = int(sys.argv[12]) if len(sys.argv) > 12 else 0
          setup_total = int(sys.argv[13]) if len(sys.argv) > 13 else 0
          phase = sys.argv[14] if len(sys.argv) > 14 else ""
          status = sys.argv[15] if len(sys.argv) > 15 else "in_progress"
          conclusion = sys.argv[16] if len(sys.argv) > 16 else ""

          token = os.environ.get("GITHUB_TOKEN", "")
          repo = os.environ.get("GITHUB_REPOSITORY", "")
          if not token or not repo:
              raise SystemExit(0)

          completed_units = (completed_ticks / ticks_per_unit) if ticks_per_unit else 0.0
          percent = (completed_ticks / total_ticks * 100.0) if total_ticks else 0.0
          progress = {
              "request_id": request_id,
              "algorithm": algorithm,
              "iterations": iterations,
              "tests_per_iteration": units_per_iter,
              "ticks_per_unit": ticks_per_unit,
              "completed": round(completed_units, 3),
              "total": total_units,
              "total_ticks": total_ticks,
              "percent": round(percent, 3),
              "phase": phase,
              "run_id": os.environ.get("GITHUB_RUN_ID", ""),
              "stage": stage,
              "setup_completed": setup_done,
              "setup_total": setup_total,
              "tests_completed": round(completed_units, 3),
              "tests_total": total_units,
          }

          if ticks_per_unit > 1:
              completed_str = f"{completed_units:.1f}"
          else:
              completed_str = str(int(completed_units))

          setup_percent = (setup_done / setup_total * 100.0) if setup_total else 0.0
          if stage == "setup":
              summary = f"Setup: {setup_done}/{setup_total} ({setup_percent:.1f}%)"
          else:
              summary = f"Progress: {completed_str}/{total_units} ({percent:.1f}%)"
          if phase:
              summary += f"\\nPhase: {phase}"

          payload = {
              "status": status,
              "output": {
                  "title": name,
                  "summary": summary,
                  "text": json.dumps(progress),
              },
          }
          if status == "completed":
              payload["completed_at"] = datetime.datetime.now(datetime.timezone.utc).strftime(
                  "%Y-%m-%dT%H:%M:%SZ"
              )
              if conclusion:
                  payload["conclusion"] = conclusion

          url = f"https://api.github.com/repos/{repo}/check-runs/{check_id}"
          headers = {
              "Accept": "application/vnd.github+json",
              "Authorization": f"Bearer {token}",
              "X-GitHub-Api-Version": "2022-11-28",
              "User-Agent": "capstone-algorithm-runner",
          }
          req = urllib.request.Request(
              url,
              data=json.dumps(payload).encode("utf-8"),
              headers=headers,
              method="PATCH",
          )
          try:
              with urllib.request.urlopen(req, timeout=10):
                  pass
          except Exception:
              pass
          PY

            PROGRESS_LAST_UPDATE_EPOCH=$(date +%s)
            if [ "${PROGRESS_STAGE:-tests}" = "setup" ]; then
              PROGRESS_LAST_REPORTED_SETUP="$PROGRESS_SETUP_DONE"
            else
              PROGRESS_LAST_REPORTED_TICKS="$PROGRESS_DONE_TICKS"
            fi
            return 0
          }

          progress_maybe_update() {
            if [ "${PROGRESS_ENABLED:-0}" != "1" ]; then
              return 0
            fi

            local now_epoch
            now_epoch=$(date +%s)

            local stage current total last
            stage="${PROGRESS_STAGE:-tests}"
            if [ "$stage" = "setup" ]; then
              current="${PROGRESS_SETUP_DONE:-0}"
              total="${PROGRESS_SETUP_TOTAL:-0}"
              last="${PROGRESS_LAST_REPORTED_SETUP--1}"
            else
              current="${PROGRESS_DONE_TICKS:-0}"
              total="${PROGRESS_TOTAL_TICKS:-0}"
              last="${PROGRESS_LAST_REPORTED_TICKS--1}"
            fi

            if [ "${total:-0}" -le 0 ]; then
              progress_update_check_run "in_progress"
              return 0
            fi

            if [ "$current" -ge "$total" ]; then
              progress_update_check_run "in_progress"
              return 0
            fi

            if [ "$current" -le 2 ]; then
              progress_update_check_run "in_progress"
              return 0
            fi

            if [ "$current" -ne "$last" ] && [ $((now_epoch - PROGRESS_LAST_UPDATE_EPOCH)) -ge 5 ]; then
              progress_update_check_run "in_progress"
            fi
            return 0
          }

          progress_set_phase() {
            PROGRESS_PHASE="$1"
            progress_maybe_update
          }

          progress_tick() {
            PROGRESS_DONE_TICKS=$((PROGRESS_DONE_TICKS + 1))
            progress_maybe_update
          }

          progress_setup_tick() {
            PROGRESS_SETUP_DONE=$((PROGRESS_SETUP_DONE + 1))
            if [ "$PROGRESS_SETUP_DONE" -gt "$PROGRESS_SETUP_TOTAL" ]; then
              PROGRESS_SETUP_DONE="$PROGRESS_SETUP_TOTAL"
            fi
            progress_maybe_update
          }

          progress_finish() {
            if [ "${PROGRESS_ENABLED:-0}" != "1" ] || [ -z "${CHECK_RUN_ID:-}" ]; then
              return 0
            fi
            PROGRESS_DONE_TICKS="$PROGRESS_TOTAL_TICKS"
            local conclusion="success"
            if [ "${EXIT_CODE:-0}" != "0" ]; then
              conclusion="failure"
            fi
            progress_update_check_run "completed" "$conclusion"
            return 0
          }

          progress_create_check_run
          trap 'rc=$?; if [ -z "${EXIT_CODE:-}" ]; then EXIT_CODE=$rc; fi; progress_finish || true' EXIT

          run_with_timeout() {
            "$@"
          }

          run_capture() {
            local _out_var=$1
            local _dur_var=$2
            shift 2
            local tmp
            tmp=$(mktemp)
            local start_ns end_ns duration_ms
            start_ns=$(date +%s%N)
            set +e
            run_with_timeout "$@" >"$tmp" 2>&1
            local status=$?
            set -e
            end_ns=$(date +%s%N)
            duration_ms=$(python - <<'PY' "$start_ns" "$end_ns"
          import sys
          start=int(sys.argv[1]); end=int(sys.argv[2])
          print(f"{(end - start)/1_000_000:.3f}")
          PY
            )
            printf -v "$_out_var" "%s" "$(cat "$tmp")"
            printf -v "$_dur_var" "%s" "$duration_ms"
            rm -f "$tmp"
            return $status
          }

          warmup_only() {
            local label="$1"
            shift

            if [ "${WARMUP_REQUESTED:-0}" -le 0 ]; then
              return 0
            fi

            local out dur
            for ((i=1; i<=WARMUP_REQUESTED; i++)); do
              if ! run_capture out dur "$@"; then
                echo "[Warmup] ${label} failed." >> outputs/result.txt
                return 1
              fi
              progress_setup_tick
            done
            return 0
          }

          bench_capture_n() {
            local _out_var=$1
            local _times_var=$2
            local _runs=$3
            shift 3

            local out dur
            local -a times
            local out_first=""

            # Warmup runs (not included in stats/progress).
            if [ "${WARMUP:-0}" -gt 0 ]; then
              for ((i=1; i<=WARMUP; i++)); do
                if ! run_capture out dur "$@"; then
                  printf -v "$_out_var" "%s" "$out"
                  return 1
                fi
              done
            fi

            for ((i=1; i<=_runs; i++)); do
              if ! run_capture out dur "$@"; then
                printf -v "$_out_var" "%s" "$out"
                return 1
              fi
              if [ $i -eq 1 ]; then
                out_first="$out"
              fi
              times+=("$dur")
              progress_tick
            done

            printf -v "$_out_var" "%s" "$out_first"
            printf -v "$_times_var" "%s" "${times[*]}"
            return 0
          }

          run_capture_rss() {
            local _out_var=$1
            local _dur_var=$2
            local _rss_var=$3
            shift 3
            local tmp rss_tmp
            tmp=$(mktemp)
            rss_tmp=$(mktemp)
            local start_ns end_ns duration_ms rss_kb
            start_ns=$(date +%s%N)
            set +e
            if [ -x /usr/bin/time ]; then
              /usr/bin/time -f "%M" -o "$rss_tmp" "$@" >"$tmp" 2>&1
            else
              run_with_timeout "$@" >"$tmp" 2>&1
            fi
            local status=$?
            set -e
            end_ns=$(date +%s%N)
            duration_ms=$(python - <<'PY' "$start_ns" "$end_ns"
          import sys
          start=int(sys.argv[1]); end=int(sys.argv[2])
          print(f"{(end - start)/1_000_000:.3f}")
          PY
            )
            rss_kb=""
            if [ -s "$rss_tmp" ]; then
              rss_kb="$(head -n1 "$rss_tmp" | tr -d '\r' | awk '{print $1}')"
            fi
            printf -v "$_out_var" "%s" "$(cat "$tmp")"
            printf -v "$_dur_var" "%s" "$duration_ms"
            printf -v "$_rss_var" "%s" "$rss_kb"
            rm -f "$tmp" "$rss_tmp"
            return $status
          }

          run_capture_rss_tmp() {
            local _out_var=$1
            local _dur_var=$2
            local _rss_var=$3
            local _tmp_var=$4
            shift 4
            local tmp rss_tmp
            tmp=$(mktemp)
            rss_tmp=$(mktemp)
            local start_ns end_ns duration_ms rss_kb
            start_ns=$(date +%s%N)
            set +e
            if [ -x /usr/bin/time ]; then
              /usr/bin/time -f "%M" -o "$rss_tmp" "$@" >"$tmp" 2>&1
            else
              run_with_timeout "$@" >"$tmp" 2>&1
            fi
            local status=$?
            set -e
            end_ns=$(date +%s%N)
            duration_ms=$(python - <<'PY' "$start_ns" "$end_ns"
          import sys
          start=int(sys.argv[1]); end=int(sys.argv[2])
          print(f"{(end - start)/1_000_000:.3f}")
          PY
            )
            rss_kb=""
            if [ -s "$rss_tmp" ]; then
              rss_kb="$(head -n1 "$rss_tmp" | tr -d '\r' | awk '{print $1}')"
            fi
            printf -v "$_out_var" "%s" "$(cat "$tmp")"
            printf -v "$_dur_var" "%s" "$duration_ms"
            printf -v "$_rss_var" "%s" "$rss_kb"
            printf -v "$_tmp_var" "%s" "$tmp"
            rm -f "$rss_tmp"
            return $status
          }

          bench_capture_rss_n() {
            local _out_var=$1
            local _times_var=$2
            local _rss_var=$3
            local _runs=$4
            shift 4

            local out dur rss
            local -a times rsses
            local out_first=""

            # Warmup runs (not included in stats/progress).
            if [ "${WARMUP:-0}" -gt 0 ]; then
              for ((i=1; i<=WARMUP; i++)); do
                if ! run_capture_rss out dur rss "$@"; then
                  printf -v "$_out_var" "%s" "$out"
                  return 1
                fi
              done
            fi

            for ((i=1; i<=_runs; i++)); do
              if ! run_capture_rss out dur rss "$@"; then
                printf -v "$_out_var" "%s" "$out"
                return 1
              fi
              if [ $i -eq 1 ]; then
                out_first="$out"
              fi
              times+=("$dur")
              rsses+=("$rss")
              progress_tick
            done

            printf -v "$_out_var" "%s" "$out_first"
            printf -v "$_times_var" "%s" "${times[*]}"
            printf -v "$_rss_var" "%s" "${rsses[*]}"
            return 0
          }

          calc_stats_ms() {
            python - <<'PY' "$@"
          import statistics
          import sys

          vals = []
          for x in sys.argv[1:]:
              try:
                  vals.append(float(x))
              except ValueError:
                  pass

          if not vals:
              print("")
              raise SystemExit(0)

          n = len(vals)
          mean = statistics.fmean(vals)
          median = statistics.median(vals)
          stdev = statistics.stdev(vals) if n > 1 else 0.0
          print(
              f"{median:.3f} {mean:.3f} {stdev:.3f} {min(vals):.3f} {max(vals):.3f} {n}"
          )
          PY
          }

          calc_stats_kb() {
            python - <<'PY' "$@"
          import statistics
          import sys

          vals = []
          for x in sys.argv[1:]:
              try:
                  vals.append(int(x))
              except ValueError:
                  pass

          if not vals:
              print("")
              raise SystemExit(0)

          n = len(vals)
          mean = statistics.fmean(vals)
          median = statistics.median_low(vals)
          stdev = statistics.stdev(vals) if n > 1 else 0.0
          print(
              f"{median} {int(round(mean))} {int(round(stdev))} {min(vals)} {max(vals)} {n}"
          )
          PY
          }

          extract_solution_count() {
            local text="$1"
            local count
            count=$(echo "$text" | tr -d '\r' | awk -F= '/solution_count[[:space:]]*=/{gsub(/[^0-9-]/, "", $2); if ($2 != "") {print $2; exit}}')
            if [ -n "$count" ]; then
              echo "$count"
              return 0
            fi
            echo "$text" | tr -d '\r' | awk 'match($0, /-?[0-9]+/) {print substr($0, RSTART, RLENGTH); exit}'
          }

          extract_solution_times_ms() {
            python - <<'PY' "$1"
          import re
          import sys

          text = sys.argv[1]
          nums = re.findall(r"[-+]?(?:\d+\.?\d*|\.\d+)(?:[eE][-+]?\d+)?", text)
          if len(nums) < 3:
              print("")
              raise SystemExit(0)
          try:
              sol = int(float(nums[0]))
              first_sec = float(nums[1])
              all_sec = float(nums[2])
          except ValueError:
              print("")
              raise SystemExit(0)
          print(f"{sol} {first_sec * 1000:.3f} {all_sec * 1000:.3f}")
          PY
          }

          sum_ms_runs() {
            python - <<'PY' "$@"
          import sys

          total = 0.0
          for x in sys.argv[1:]:
              try:
                  total += float(x)
              except ValueError:
                  pass
          if sys.argv[1:]:
              print(f"{total:.3f}")
          else:
              print("")
          PY
          }

          print_stats_ms_first_all() {
            local prefix="$1"
            shift
            local indent
            indent="$(printf '%*s' ${#prefix} '')"
            printf "%s%-5s median=%10.3f mean=%10.3f stdev=%10.3f min=%10.3f max=%10.3f\n" \
              "$prefix" "first" "$1" "$2" "$3" "$4" "$5"
            printf "%s%-5s median=%10.3f mean=%10.3f stdev=%10.3f min=%10.3f max=%10.3f\n" \
              "$indent" "all" "$6" "$7" "$8" "$9" "${10}"
          }

          print_stats_kb_first_all() {
            local prefix="$1"
            shift
            local indent
            indent="$(printf '%*s' ${#prefix} '')"
            printf "%s%-5s median=%10d mean=%10d stdev=%10d min=%10d max=%10d\n" \
              "$prefix" "first" "$1" "$2" "$3" "$4" "$5"
            printf "%s%-5s median=%10d mean=%10d stdev=%10d min=%10d max=%10d\n" \
              "$indent" "all" "$6" "$7" "$8" "$9" "${10}"
          }

          t_test_line() {
            local label="$1"
            local mean1="$2"
            local stdev1="$3"
            local n1="$4"
            local mean2="$5"
            local stdev2="$6"
            local n2="$7"
            python - <<'PY' "$label" "$mean1" "$stdev1" "$n1" "$mean2" "$stdev2" "$n2"
          import math
          import sys

          label, mean1, stdev1, n1, mean2, stdev2, n2 = sys.argv[1:]
          mean1 = float(mean1)
          stdev1 = float(stdev1)
          n1 = float(n1)
          mean2 = float(mean2)
          stdev2 = float(stdev2)
          n2 = float(n2)

          def betacf(a, b, x):
              maxit = 200
              eps = 3.0e-10
              fpmin = 1.0e-30
              qab = a + b
              qap = a + 1.0
              qam = a - 1.0
              c = 1.0
              d = 1.0 - qab * x / qap
              if abs(d) < fpmin:
                  d = fpmin
              d = 1.0 / d
              h = d
              for m in range(1, maxit + 1):
                  m2 = 2 * m
                  aa = m * (b - m) * x / ((qam + m2) * (a + m2))
                  d = 1.0 + aa * d
                  if abs(d) < fpmin:
                      d = fpmin
                  c = 1.0 + aa / c
                  if abs(c) < fpmin:
                      c = fpmin
                  d = 1.0 / d
                  h *= d * c
                  aa = -(a + m) * (qab + m) * x / ((a + m2) * (qap + m2))
                  d = 1.0 + aa * d
                  if abs(d) < fpmin:
                      d = fpmin
                  c = 1.0 + aa / c
                  if abs(c) < fpmin:
                      c = fpmin
                  d = 1.0 / d
                  delh = d * c
                  h *= delh
                  if abs(delh - 1.0) < eps:
                      break
              return h

          def betai(a, b, x):
              if x <= 0.0:
                  return 0.0
              if x >= 1.0:
                  return 1.0
              bt = math.exp(
                  math.lgamma(a + b) - math.lgamma(a) - math.lgamma(b)
                  + a * math.log(x) + b * math.log(1.0 - x)
              )
              if x < (a + 1.0) / (a + b + 2.0):
                  return bt * betacf(a, b, x) / a
              return 1.0 - bt * betacf(b, a, 1.0 - x) / b

          def t_cdf(t, df):
              if df <= 0:
                  return float("nan")
              x = df / (df + t * t)
              a = df / 2.0
              b = 0.5
              ib = betai(a, b, x)
              if t >= 0:
                  return 1.0 - 0.5 * ib
              return 0.5 * ib

          denom = math.sqrt((stdev1 ** 2) / n1 + (stdev2 ** 2) / n2) if n1 > 0 and n2 > 0 else 0.0
          if denom == 0.0:
              t_val = float("nan")
          else:
              t_val = (mean1 - mean2) / denom

          if n1 > 1 and n2 > 1 and denom != 0.0:
              v1 = (stdev1 ** 2) / n1
              v2 = (stdev2 ** 2) / n2
              df = (v1 + v2) ** 2 / ((v1 ** 2) / (n1 - 1.0) + (v2 ** 2) / (n2 - 1.0))
          else:
              df = float("nan")

          if math.isnan(df) or math.isnan(t_val):
              p_two = float("nan")
              tcrit = float("nan")
          else:
              p_two = 2.0 * (1.0 - t_cdf(abs(t_val), df))
              alpha = 0.05
              target = 1.0 - alpha / 2.0
              lo, hi = 0.0, 10.0
              while t_cdf(hi, df) < target and hi < 1e6:
                  hi *= 2.0
              for _ in range(80):
                  mid = (lo + hi) / 2.0
                  if t_cdf(mid, df) < target:
                      lo = mid
                  else:
                      hi = mid
              tcrit = (lo + hi) / 2.0

          if math.isnan(tcrit):
              ci_low = float("nan")
              ci_high = float("nan")
          else:
              delta = mean1 - mean2
              ci_low = delta - tcrit * denom
              ci_high = delta + tcrit * denom

          print(
              f"Welch two-sample t-test ({label}): "
              f"t={t_val:.6f} df={df:.3f} p={p_two:.6g} "
              f"CI95=[{ci_low:.3f}, {ci_high:.3f}]"
          )
          PY
          }

          EXIT_CODE=0

          case "$ALGORITHM" in
            dijkstra)
              dijkstra_baseline_out=""
              dijkstra_baseline_ms_runs=""
              dijkstra_baseline_rss_runs=""
              dijkstra_llm_out=""
              dijkstra_llm_ms_runs=""
              dijkstra_llm_rss_runs=""

              # Phase 1: setup + warmup (web UI fills the progress bar once here)
              PROGRESS_STAGE="setup"
              progress_set_phase "Setting up Testing Environment"
              if [ "${WARMUP_REQUESTED:-0}" -gt 0 ]; then
                if [ "$INPUT_MODE" = "generate" ]; then
                  for ((i=1; i<=WARMUP_REQUESTED; i++)); do
                    if ! generate_graphs_for_run "dijkstra_baseline_warmup" "w${i}"; then
                      EXIT_CODE=1
                      break
                    fi
                    if ! run_capture out dur ./baselines/dijkstra "${FILES[0]}"; then
                      echo "[Warmup] Dijkstra baseline failed." >> outputs/result.txt
                      EXIT_CODE=1
                      break
                    fi
                    progress_setup_tick
                  done
                  for ((i=1; i<=WARMUP_REQUESTED; i++)); do
                    if ! generate_graphs_for_run "dijkstra_llm_warmup" "w${i}"; then
                      EXIT_CODE=1
                      break
                    fi
                    if ! run_capture out dur ./src/dijkstra_llm "${FILES[0]}"; then
                      echo "[Warmup] Dijkstra llm failed." >> outputs/result.txt
                      EXIT_CODE=1
                      break
                    fi
                    progress_setup_tick
                  done
                else
                  if ! warmup_only "Dijkstra baseline" ./baselines/dijkstra "${FILES[0]}"; then
                    EXIT_CODE=1
                  fi
                  if ! warmup_only "Dijkstra llm" ./src/dijkstra_llm "${FILES[0]}"; then
                    EXIT_CODE=1
                  fi
                fi
              else
                progress_setup_tick
              fi
              PROGRESS_SETUP_DONE="$PROGRESS_SETUP_TOTAL"
              progress_update_check_run "in_progress" || true

              # Phase 2: measured iterations (web UI resets the bar and fills again here)
              PROGRESS_STAGE="tests"
              PROGRESS_PHASE=""
              PROGRESS_DONE_TICKS=0
              progress_update_check_run "in_progress" || true
              WARMUP=0

              progress_set_phase "Dijkstra baseline"
              if [ "$INPUT_MODE" = "generate" ]; then
                dijkstra_baseline_out=""
                dijkstra_baseline_ms_runs=""
                dijkstra_baseline_rss_runs=""
                out=""
                dur=""
                rss=""
                times=()
                rsses=()
                out_first=""
                for ((i=1; i<=ITERATIONS; i++)); do
                  if ! generate_graphs_for_run "dijkstra_baseline" "$i"; then
                    EXIT_CODE=1
                    break
                  fi
                  if ! run_capture_rss out dur rss ./baselines/dijkstra "${FILES[0]}"; then
                    EXIT_CODE=1
                    echo "[Dijkstra Baseline] failed to run." >> outputs/result.txt
                    break
                  fi
                  if [ $i -eq 1 ]; then
                    out_first="$out"
                  fi
                  times+=("$dur")
                  rsses+=("$rss")
                  progress_tick
                done
                dijkstra_baseline_out="$out_first"
                dijkstra_baseline_ms_runs="${times[*]}"
                dijkstra_baseline_rss_runs="${rsses[*]}"
              else
                if ! bench_capture_rss_n dijkstra_baseline_out dijkstra_baseline_ms_runs dijkstra_baseline_rss_runs "$ITERATIONS" ./baselines/dijkstra "${FILES[0]}"; then
                  EXIT_CODE=1
                  echo "[Dijkstra Baseline] failed to run." >> outputs/result.txt
                fi
              fi
              if [ -n "${dijkstra_baseline_ms_runs:-}" ]; then
                read dijkstra_baseline_ms_median dijkstra_baseline_ms_mean dijkstra_baseline_ms_stdev dijkstra_baseline_ms_min dijkstra_baseline_ms_max dijkstra_baseline_ms_n <<< "$(calc_stats_ms $dijkstra_baseline_ms_runs)"
                dijkstra_baseline_ms="$dijkstra_baseline_ms_median"
                if [ -n "${dijkstra_baseline_rss_runs:-}" ]; then
                  read dijkstra_baseline_rss_median dijkstra_baseline_rss_mean dijkstra_baseline_rss_stdev dijkstra_baseline_rss_min dijkstra_baseline_rss_max dijkstra_baseline_rss_n <<< "$(calc_stats_kb $dijkstra_baseline_rss_runs)"
                  dijkstra_baseline_rss_kb="$dijkstra_baseline_rss_median"
                fi
                {
                  echo "[Dijkstra Baseline]"
                  echo "$dijkstra_baseline_out"
                  echo "Warmup: $WARMUP_REQUESTED"
                  echo "Iterations: $ITERATIONS"
                  if [ -n "${dijkstra_baseline_ms_median:-}" ]; then
                    echo "Runtime (ms): median=$dijkstra_baseline_ms_median mean=$dijkstra_baseline_ms_mean stdev=$dijkstra_baseline_ms_stdev min=$dijkstra_baseline_ms_min max=$dijkstra_baseline_ms_max"
                  fi
                  if [ -n "${dijkstra_baseline_rss_median:-}" ]; then
                    echo "Max RSS (kB): median=$dijkstra_baseline_rss_median mean=$dijkstra_baseline_rss_mean stdev=$dijkstra_baseline_rss_stdev min=$dijkstra_baseline_rss_min max=$dijkstra_baseline_rss_max"
                  fi
                  echo
                } >> outputs/result.txt
              fi
              progress_set_phase "Dijkstra llm"
              if [ "$INPUT_MODE" = "generate" ]; then
                dijkstra_llm_out=""
                dijkstra_llm_ms_runs=""
                dijkstra_llm_rss_runs=""
                out=""
                dur=""
                rss=""
                times=()
                rsses=()
                out_first=""
                for ((i=1; i<=ITERATIONS; i++)); do
                  if ! generate_graphs_for_run "dijkstra_llm" "$i"; then
                    EXIT_CODE=1
                    break
                  fi
                  if ! run_capture_rss out dur rss ./src/dijkstra_llm "${FILES[0]}"; then
                    EXIT_CODE=1
                    echo "[Dijkstra LLM] failed to run." >> outputs/result.txt
                    break
                  fi
                  if [ $i -eq 1 ]; then
                    out_first="$out"
                  fi
                  times+=("$dur")
                  rsses+=("$rss")
                  progress_tick
                done
                dijkstra_llm_out="$out_first"
                dijkstra_llm_ms_runs="${times[*]}"
                dijkstra_llm_rss_runs="${rsses[*]}"
              else
                if ! bench_capture_rss_n dijkstra_llm_out dijkstra_llm_ms_runs dijkstra_llm_rss_runs "$ITERATIONS" ./src/dijkstra_llm "${FILES[0]}"; then
                  EXIT_CODE=1
                  echo "[Dijkstra LLM] failed to run." >> outputs/result.txt
                fi
              fi
              if [ -n "${dijkstra_llm_ms_runs:-}" ]; then
                read dijkstra_llm_ms_median dijkstra_llm_ms_mean dijkstra_llm_ms_stdev dijkstra_llm_ms_min dijkstra_llm_ms_max dijkstra_llm_ms_n <<< "$(calc_stats_ms $dijkstra_llm_ms_runs)"
                dijkstra_llm_ms="$dijkstra_llm_ms_median"
                if [ -n "${dijkstra_llm_rss_runs:-}" ]; then
                  read dijkstra_llm_rss_median dijkstra_llm_rss_mean dijkstra_llm_rss_stdev dijkstra_llm_rss_min dijkstra_llm_rss_max dijkstra_llm_rss_n <<< "$(calc_stats_kb $dijkstra_llm_rss_runs)"
                  dijkstra_llm_rss_kb="$dijkstra_llm_rss_median"
                fi
                {
                  echo "[Dijkstra LLM]"
                  echo "$dijkstra_llm_out"
                  echo "Warmup: $WARMUP_REQUESTED"
                  echo "Iterations: $ITERATIONS"
                  if [ -n "${dijkstra_llm_ms_median:-}" ]; then
                    echo "Runtime (ms): median=$dijkstra_llm_ms_median mean=$dijkstra_llm_ms_mean stdev=$dijkstra_llm_ms_stdev min=$dijkstra_llm_ms_min max=$dijkstra_llm_ms_max"
                  fi
                  if [ -n "${dijkstra_llm_rss_median:-}" ]; then
                    echo "Max RSS (kB): median=$dijkstra_llm_rss_median mean=$dijkstra_llm_rss_mean stdev=$dijkstra_llm_rss_stdev min=$dijkstra_llm_rss_min max=$dijkstra_llm_rss_max"
                  fi
                  if [ -n "${dijkstra_baseline_ms_mean:-}" ] && [ -n "${dijkstra_llm_ms_mean:-}" ]; then
                    t_test_line "runtime ms baseline vs LLM" \
                      "$dijkstra_baseline_ms_mean" "$dijkstra_baseline_ms_stdev" "$dijkstra_baseline_ms_n" \
                      "$dijkstra_llm_ms_mean" "$dijkstra_llm_ms_stdev" "$dijkstra_llm_ms_n"
                  fi
                  echo
                } >> outputs/result.txt
              fi
              if [ -n "${dijkstra_baseline_ms_runs:-}" ] || [ -n "${dijkstra_llm_ms_runs:-}" ]; then
                SOLVER_TIME_MS_TOTAL="$(sum_ms_runs $dijkstra_baseline_ms_runs $dijkstra_llm_ms_runs)"
              fi
              ;;
            glasgow)
              glasgow_first_out=""
              glasgow_first_ms_runs=""
              glasgow_first_rss_runs=""
              glasgow_all_out=""
              glasgow_all_ms_runs=""
              glasgow_all_rss_runs=""

              glasgow_gemini_first_out=""
              glasgow_gemini_first_ms_runs=""
              glasgow_gemini_first_rss_runs=""
              glasgow_gemini_all_out=""
              glasgow_gemini_all_ms_runs=""
              glasgow_gemini_all_rss_runs=""

              glasgow_chatgpt_first_out=""
              glasgow_chatgpt_first_ms_runs=""
              glasgow_chatgpt_first_rss_runs=""
              glasgow_chatgpt_all_out=""
              glasgow_chatgpt_all_ms_runs=""
              glasgow_chatgpt_all_rss_runs=""

              # Phase 1: setup + warmup (web UI fills the progress bar once here)
              PROGRESS_STAGE="setup"
              progress_set_phase "Setting up Testing Environment"
              if [ "${WARMUP_REQUESTED:-0}" -gt 0 ]; then
                if [ "$INPUT_MODE" = "generate" ]; then
                  out=""
                  dur=""
                  for ((i=1; i<=WARMUP_REQUESTED; i++)); do
                    if ! generate_graphs_for_run "glasgow_warmup" "w${i}"; then
                      EXIT_CODE=1
                      break
                    fi
                    if ! run_capture out dur ./baselines/glasgow-subgraph-solver/build/glasgow_subgraph_solver --induced --format lad "${FILES[0]}" "${FILES[1]}"; then
                      echo "[Warmup] Glasgow first failed." >> outputs/result.txt
                      EXIT_CODE=1
                      break
                    fi
                    progress_setup_tick
                    if ! run_capture out dur ./baselines/glasgow-subgraph-solver/build/glasgow_subgraph_solver --induced --count-solutions --format lad "${FILES[0]}" "${FILES[1]}"; then
                      echo "[Warmup] Glasgow all failed." >> outputs/result.txt
                      EXIT_CODE=1
                      break
                    fi
                    progress_setup_tick
                    if ! run_capture out dur ./src/chatvf3 --induced --first-only "${FILES[0]}" "${FILES[1]}"; then
                      echo "[Warmup] Glasgow ChatGPT first failed." >> outputs/result.txt
                      EXIT_CODE=1
                      break
                    fi
                    progress_setup_tick
                    if ! run_capture out dur ./src/chatvf3 --induced "${FILES[0]}" "${FILES[1]}"; then
                      echo "[Warmup] Glasgow ChatGPT all failed." >> outputs/result.txt
                      EXIT_CODE=1
                      break
                    fi
                    progress_setup_tick
                    if ! run_capture out dur ./src/vf3 --induced --first-only "${FILES[0]}" "${FILES[1]}"; then
                      echo "[Warmup] Glasgow Gemini first failed." >> outputs/result.txt
                      EXIT_CODE=1
                      break
                    fi
                    progress_setup_tick
                    if ! run_capture out dur ./src/vf3 --induced "${FILES[0]}" "${FILES[1]}"; then
                      echo "[Warmup] Glasgow Gemini all failed." >> outputs/result.txt
                      EXIT_CODE=1
                      break
                    fi
                    progress_setup_tick
                  done
                else
                  if ! warmup_only "Glasgow first" ./baselines/glasgow-subgraph-solver/build/glasgow_subgraph_solver --induced --format lad "${FILES[0]}" "${FILES[1]}"; then
                    EXIT_CODE=1
                  fi
                  if ! warmup_only "Glasgow all" ./baselines/glasgow-subgraph-solver/build/glasgow_subgraph_solver --induced --count-solutions --format lad "${FILES[0]}" "${FILES[1]}"; then
                    EXIT_CODE=1
                  fi
                  if ! warmup_only "Glasgow ChatGPT first" ./src/chatvf3 --induced --first-only "${FILES[0]}" "${FILES[1]}"; then
                    EXIT_CODE=1
                  fi
                  if ! warmup_only "Glasgow ChatGPT all" ./src/chatvf3 --induced "${FILES[0]}" "${FILES[1]}"; then
                    EXIT_CODE=1
                  fi
                  if ! warmup_only "Glasgow Gemini first" ./src/vf3 --induced --first-only "${FILES[0]}" "${FILES[1]}"; then
                    EXIT_CODE=1
                  fi
                  if ! warmup_only "Glasgow Gemini all" ./src/vf3 --induced "${FILES[0]}" "${FILES[1]}"; then
                    EXIT_CODE=1
                  fi
                fi
              else
                progress_setup_tick
              fi
              PROGRESS_SETUP_DONE="$PROGRESS_SETUP_TOTAL"
              progress_update_check_run "in_progress" || true

              # Phase 2: measured iterations (web UI resets the bar and fills again here)
              PROGRESS_STAGE="tests"
              PROGRESS_PHASE=""
              PROGRESS_DONE_TICKS=0
              progress_update_check_run "in_progress" || true
              WARMUP=0

              progress_set_phase "Glasgow baseline"
              glasgow_success=0
              glasgow_fail=0
              glasgow_chatgpt_match=0
              glasgow_chatgpt_total=0
              glasgow_chatgpt_mismatch=0
              glasgow_gemini_match=0
              glasgow_gemini_total=0
              glasgow_gemini_mismatch=0

              first_times=()
              first_rsses=()
              all_times=()
              all_rsses=()
              chat_first_times=()
              chat_first_rsses=()
              chat_all_times=()
              chat_all_rsses=()
              gem_first_times=()
              gem_first_rsses=()
              gem_all_times=()
              gem_all_rsses=()
              out=""
              dur=""
              rss=""

              for ((i=1; i<=ITERATIONS; i++)); do
                if [ "$INPUT_MODE" = "generate" ]; then
                  if ! generate_graphs_for_run "glasgow_iter" "$i"; then
                    EXIT_CODE=1
                    break
                  fi
                fi

                baseline_ok=1
                progress_set_phase "Glasgow baseline"
                if ! run_capture_rss out dur rss ./baselines/glasgow-subgraph-solver/build/glasgow_subgraph_solver --induced --format lad "${FILES[0]}" "${FILES[1]}"; then
                  EXIT_CODE=1
                  echo "[Glasgow Subgraph Solver] first-solution run failed." >> outputs/result.txt
                  baseline_ok=0
                else
                  first_times+=("$dur")
                  first_rsses+=("$rss")
                  progress_tick
                fi
                if [ "$baseline_ok" -eq 1 ]; then
                  if ! run_capture_rss out dur rss ./baselines/glasgow-subgraph-solver/build/glasgow_subgraph_solver --induced --count-solutions --format lad "${FILES[0]}" "${FILES[1]}"; then
                    EXIT_CODE=1
                    echo "[Glasgow Subgraph Solver] all-solutions run failed." >> outputs/result.txt
                    baseline_ok=0
                  else
                    all_times+=("$dur")
                    all_rsses+=("$rss")
                    progress_tick
                    baseline_count="$(extract_solution_count "$out")"
                    if [ -z "${baseline_count:-}" ]; then
                      echo "[Glasgow Subgraph Solver] could not parse solution count." >> outputs/result.txt
                      baseline_ok=0
                      EXIT_CODE=1
                    fi
                  fi
                fi

                if [ "$baseline_ok" -ne 1 ]; then
                  glasgow_fail=$((glasgow_fail + 1))
                  continue
                fi

                glasgow_success=$((glasgow_success + 1))

                progress_set_phase "Glasgow ChatGPT"
                glasgow_chatgpt_total=$((glasgow_chatgpt_total + 1))
                chat_ok=1
                chat_count=""
                if ! run_capture_rss out dur rss ./src/chatvf3 --induced --first-only "${FILES[0]}" "${FILES[1]}"; then
                  EXIT_CODE=1
                  echo "[Glasgow ChatGPT] first-solution run failed." >> outputs/result.txt
                  chat_ok=0
                else
                  chat_first_times+=("$dur")
                  chat_first_rsses+=("$rss")
                  progress_tick
                fi
                if ! run_capture_rss out dur rss ./src/chatvf3 --induced "${FILES[0]}" "${FILES[1]}"; then
                  EXIT_CODE=1
                  echo "[Glasgow ChatGPT] all-solutions run failed." >> outputs/result.txt
                  chat_ok=0
                else
                  chat_all_times+=("$dur")
                  chat_all_rsses+=("$rss")
                  progress_tick
                  chat_count="$(extract_solution_count "$out")"
                fi
                if [ "$chat_ok" -eq 1 ] && [ -n "${chat_count:-}" ] && [ "$chat_count" = "$baseline_count" ]; then
                  glasgow_chatgpt_match=$((glasgow_chatgpt_match + 1))
                else
                  glasgow_chatgpt_mismatch=$((glasgow_chatgpt_mismatch + 1))
                fi

                progress_set_phase "Glasgow Gemini"
                glasgow_gemini_total=$((glasgow_gemini_total + 1))
                gem_ok=1
                gem_count=""
                if ! run_capture_rss out dur rss ./src/vf3 --induced --first-only "${FILES[0]}" "${FILES[1]}"; then
                  EXIT_CODE=1
                  echo "[Glasgow Gemini] first-solution run failed." >> outputs/result.txt
                  gem_ok=0
                else
                  gem_first_times+=("$dur")
                  gem_first_rsses+=("$rss")
                  progress_tick
                fi
                if ! run_capture_rss out dur rss ./src/vf3 --induced "${FILES[0]}" "${FILES[1]}"; then
                  EXIT_CODE=1
                  echo "[Glasgow Gemini] all-solutions run failed." >> outputs/result.txt
                  gem_ok=0
                else
                  gem_all_times+=("$dur")
                  gem_all_rsses+=("$rss")
                  progress_tick
                  gem_count="$(extract_solution_count "$out")"
                fi
                if [ "$gem_ok" -eq 1 ] && [ -n "${gem_count:-}" ] && [ "$gem_count" = "$baseline_count" ]; then
                  glasgow_gemini_match=$((glasgow_gemini_match + 1))
                else
                  glasgow_gemini_mismatch=$((glasgow_gemini_mismatch + 1))
                fi
              done

              glasgow_first_ms_runs="${first_times[*]}"
              glasgow_first_rss_runs="${first_rsses[*]}"
              glasgow_all_ms_runs="${all_times[*]}"
              glasgow_all_rss_runs="${all_rsses[*]}"
              glasgow_chatgpt_first_ms_runs="${chat_first_times[*]}"
              glasgow_chatgpt_first_rss_runs="${chat_first_rsses[*]}"
              glasgow_chatgpt_all_ms_runs="${chat_all_times[*]}"
              glasgow_chatgpt_all_rss_runs="${chat_all_rsses[*]}"
              glasgow_gemini_first_ms_runs="${gem_first_times[*]}"
              glasgow_gemini_first_rss_runs="${gem_first_rsses[*]}"
              glasgow_gemini_all_ms_runs="${gem_all_times[*]}"
              glasgow_gemini_all_rss_runs="${gem_all_rsses[*]}"

              if [ -n "${glasgow_first_ms_runs:-}" ]; then
                read glasgow_first_ms_median glasgow_first_ms_mean glasgow_first_ms_stdev glasgow_first_ms_min glasgow_first_ms_max glasgow_first_ms_n <<< "$(calc_stats_ms $glasgow_first_ms_runs)"
                glasgow_first_ms="$glasgow_first_ms_median"
              fi
              if [ -n "${glasgow_all_ms_runs:-}" ]; then
                read glasgow_all_ms_median glasgow_all_ms_mean glasgow_all_ms_stdev glasgow_all_ms_min glasgow_all_ms_max glasgow_all_ms_n <<< "$(calc_stats_ms $glasgow_all_ms_runs)"
                glasgow_all_ms="$glasgow_all_ms_median"
              fi
              if [ -n "${glasgow_first_rss_runs:-}" ]; then
                read glasgow_first_rss_median glasgow_first_rss_mean glasgow_first_rss_stdev glasgow_first_rss_min glasgow_first_rss_max glasgow_first_rss_n <<< "$(calc_stats_kb $glasgow_first_rss_runs)"
                glasgow_first_rss_kb="$glasgow_first_rss_median"
              fi
              if [ -n "${glasgow_all_rss_runs:-}" ]; then
                read glasgow_all_rss_median glasgow_all_rss_mean glasgow_all_rss_stdev glasgow_all_rss_min glasgow_all_rss_max glasgow_all_rss_n <<< "$(calc_stats_kb $glasgow_all_rss_runs)"
                glasgow_all_rss_kb="$glasgow_all_rss_median"
              fi
              if [ "$ITERATIONS" -ge 1 ]; then
                glasgow_failure_suffix=""
                if [ "${glasgow_fail:-0}" -gt 0 ]; then
                  glasgow_failure_suffix=", ${glasgow_fail} failed"
                fi
                {
                  echo "[Glasgow Subgraph Solver]"
                  echo "${glasgow_success} iterations ran successfully${glasgow_failure_suffix}"
                  echo "Warmup: $WARMUP_REQUESTED"
                  echo "Iterations: $ITERATIONS"
                  if [ -n "${glasgow_first_ms_median:-}" ] && [ -n "${glasgow_all_ms_median:-}" ]; then
                    print_stats_ms_first_all "Runtime (ms): " \
                      "$glasgow_first_ms_median" "$glasgow_first_ms_mean" "$glasgow_first_ms_stdev" "$glasgow_first_ms_min" "$glasgow_first_ms_max" \
                      "$glasgow_all_ms_median" "$glasgow_all_ms_mean" "$glasgow_all_ms_stdev" "$glasgow_all_ms_min" "$glasgow_all_ms_max"
                  fi
                  if [ -n "${glasgow_first_rss_median:-}" ] && [ -n "${glasgow_all_rss_median:-}" ]; then
                    print_stats_kb_first_all "Max RSS (kB): " \
                      "$glasgow_first_rss_median" "$glasgow_first_rss_mean" "$glasgow_first_rss_stdev" "$glasgow_first_rss_min" "$glasgow_first_rss_max" \
                      "$glasgow_all_rss_median" "$glasgow_all_rss_mean" "$glasgow_all_rss_stdev" "$glasgow_all_rss_min" "$glasgow_all_rss_max"
                  fi
                  echo
                } >> outputs/result.txt
              fi

              if [ -n "${glasgow_chatgpt_first_ms_runs:-}" ]; then
                read glasgow_chatgpt_first_ms_median glasgow_chatgpt_first_ms_mean glasgow_chatgpt_first_ms_stdev glasgow_chatgpt_first_ms_min glasgow_chatgpt_first_ms_max glasgow_chatgpt_first_ms_n <<< "$(calc_stats_ms $glasgow_chatgpt_first_ms_runs)"
                glasgow_chatgpt_first_ms="$glasgow_chatgpt_first_ms_median"
              fi
              if [ -n "${glasgow_chatgpt_all_ms_runs:-}" ]; then
                read glasgow_chatgpt_all_ms_median glasgow_chatgpt_all_ms_mean glasgow_chatgpt_all_ms_stdev glasgow_chatgpt_all_ms_min glasgow_chatgpt_all_ms_max glasgow_chatgpt_all_ms_n <<< "$(calc_stats_ms $glasgow_chatgpt_all_ms_runs)"
                glasgow_chatgpt_all_ms="$glasgow_chatgpt_all_ms_median"
              fi
              if [ -n "${glasgow_chatgpt_first_rss_runs:-}" ]; then
                read glasgow_chatgpt_first_rss_median glasgow_chatgpt_first_rss_mean glasgow_chatgpt_first_rss_stdev glasgow_chatgpt_first_rss_min glasgow_chatgpt_first_rss_max glasgow_chatgpt_first_rss_n <<< "$(calc_stats_kb $glasgow_chatgpt_first_rss_runs)"
                glasgow_chatgpt_first_rss_kb="$glasgow_chatgpt_first_rss_median"
              fi
              if [ -n "${glasgow_chatgpt_all_rss_runs:-}" ]; then
                read glasgow_chatgpt_all_rss_median glasgow_chatgpt_all_rss_mean glasgow_chatgpt_all_rss_stdev glasgow_chatgpt_all_rss_min glasgow_chatgpt_all_rss_max glasgow_chatgpt_all_rss_n <<< "$(calc_stats_kb $glasgow_chatgpt_all_rss_runs)"
                glasgow_chatgpt_all_rss_kb="$glasgow_chatgpt_all_rss_median"
              fi
              if [ "$ITERATIONS" -ge 1 ]; then
                {
                  echo "[Glasgow ChatGPT]"
                  echo "Matches: ${glasgow_chatgpt_match}/${glasgow_chatgpt_total} (mismatches: ${glasgow_chatgpt_mismatch})"
                  echo "Warmup: $WARMUP_REQUESTED"
                  echo "Iterations: $ITERATIONS"
                  if [ -n "${glasgow_chatgpt_first_ms_median:-}" ] && [ -n "${glasgow_chatgpt_all_ms_median:-}" ]; then
                    print_stats_ms_first_all "Runtime (ms): " \
                      "$glasgow_chatgpt_first_ms_median" "$glasgow_chatgpt_first_ms_mean" "$glasgow_chatgpt_first_ms_stdev" "$glasgow_chatgpt_first_ms_min" "$glasgow_chatgpt_first_ms_max" \
                      "$glasgow_chatgpt_all_ms_median" "$glasgow_chatgpt_all_ms_mean" "$glasgow_chatgpt_all_ms_stdev" "$glasgow_chatgpt_all_ms_min" "$glasgow_chatgpt_all_ms_max"
                  fi
                  if [ -n "${glasgow_chatgpt_first_rss_median:-}" ] && [ -n "${glasgow_chatgpt_all_rss_median:-}" ]; then
                    print_stats_kb_first_all "Max RSS (kB): " \
                      "$glasgow_chatgpt_first_rss_median" "$glasgow_chatgpt_first_rss_mean" "$glasgow_chatgpt_first_rss_stdev" "$glasgow_chatgpt_first_rss_min" "$glasgow_chatgpt_first_rss_max" \
                      "$glasgow_chatgpt_all_rss_median" "$glasgow_chatgpt_all_rss_mean" "$glasgow_chatgpt_all_rss_stdev" "$glasgow_chatgpt_all_rss_min" "$glasgow_chatgpt_all_rss_max"
                  fi
                  if [ -n "${glasgow_first_ms_mean:-}" ] && [ -n "${glasgow_chatgpt_first_ms_mean:-}" ]; then
                    t_test_line "runtime ms first baseline vs ChatGPT" \
                      "$glasgow_first_ms_mean" "$glasgow_first_ms_stdev" "$glasgow_first_ms_n" \
                      "$glasgow_chatgpt_first_ms_mean" "$glasgow_chatgpt_first_ms_stdev" "$glasgow_chatgpt_first_ms_n"
                  fi
                  if [ -n "${glasgow_all_ms_mean:-}" ] && [ -n "${glasgow_chatgpt_all_ms_mean:-}" ]; then
                    t_test_line "runtime ms all baseline vs ChatGPT" \
                      "$glasgow_all_ms_mean" "$glasgow_all_ms_stdev" "$glasgow_all_ms_n" \
                      "$glasgow_chatgpt_all_ms_mean" "$glasgow_chatgpt_all_ms_stdev" "$glasgow_chatgpt_all_ms_n"
                  fi
                  echo
                } >> outputs/result.txt
              fi

              if [ -n "${glasgow_gemini_first_ms_runs:-}" ]; then
                read glasgow_gemini_first_ms_median glasgow_gemini_first_ms_mean glasgow_gemini_first_ms_stdev glasgow_gemini_first_ms_min glasgow_gemini_first_ms_max glasgow_gemini_first_ms_n <<< "$(calc_stats_ms $glasgow_gemini_first_ms_runs)"
                glasgow_gemini_first_ms="$glasgow_gemini_first_ms_median"
              fi
              if [ -n "${glasgow_gemini_all_ms_runs:-}" ]; then
                read glasgow_gemini_all_ms_median glasgow_gemini_all_ms_mean glasgow_gemini_all_ms_stdev glasgow_gemini_all_ms_min glasgow_gemini_all_ms_max glasgow_gemini_all_ms_n <<< "$(calc_stats_ms $glasgow_gemini_all_ms_runs)"
                glasgow_gemini_all_ms="$glasgow_gemini_all_ms_median"
              fi
              if [ -n "${glasgow_gemini_first_rss_runs:-}" ]; then
                read glasgow_gemini_first_rss_median glasgow_gemini_first_rss_mean glasgow_gemini_first_rss_stdev glasgow_gemini_first_rss_min glasgow_gemini_first_rss_max glasgow_gemini_first_rss_n <<< "$(calc_stats_kb $glasgow_gemini_first_rss_runs)"
                glasgow_gemini_first_rss_kb="$glasgow_gemini_first_rss_median"
              fi
              if [ -n "${glasgow_gemini_all_rss_runs:-}" ]; then
                read glasgow_gemini_all_rss_median glasgow_gemini_all_rss_mean glasgow_gemini_all_rss_stdev glasgow_gemini_all_rss_min glasgow_gemini_all_rss_max glasgow_gemini_all_rss_n <<< "$(calc_stats_kb $glasgow_gemini_all_rss_runs)"
                glasgow_gemini_all_rss_kb="$glasgow_gemini_all_rss_median"
              fi
              if [ "$ITERATIONS" -ge 1 ]; then
                {
                  echo "[Glasgow Gemini]"
                  echo "Matches: ${glasgow_gemini_match}/${glasgow_gemini_total} (mismatches: ${glasgow_gemini_mismatch})"
                  echo "Warmup: $WARMUP_REQUESTED"
                  echo "Iterations: $ITERATIONS"
                  if [ -n "${glasgow_gemini_first_ms_median:-}" ] && [ -n "${glasgow_gemini_all_ms_median:-}" ]; then
                    print_stats_ms_first_all "Runtime (ms): " \
                      "$glasgow_gemini_first_ms_median" "$glasgow_gemini_first_ms_mean" "$glasgow_gemini_first_ms_stdev" "$glasgow_gemini_first_ms_min" "$glasgow_gemini_first_ms_max" \
                      "$glasgow_gemini_all_ms_median" "$glasgow_gemini_all_ms_mean" "$glasgow_gemini_all_ms_stdev" "$glasgow_gemini_all_ms_min" "$glasgow_gemini_all_ms_max"
                  fi
                  if [ -n "${glasgow_gemini_first_rss_median:-}" ] && [ -n "${glasgow_gemini_all_rss_median:-}" ]; then
                    print_stats_kb_first_all "Max RSS (kB): " \
                      "$glasgow_gemini_first_rss_median" "$glasgow_gemini_first_rss_mean" "$glasgow_gemini_first_rss_stdev" "$glasgow_gemini_first_rss_min" "$glasgow_gemini_first_rss_max" \
                      "$glasgow_gemini_all_rss_median" "$glasgow_gemini_all_rss_mean" "$glasgow_gemini_all_rss_stdev" "$glasgow_gemini_all_rss_min" "$glasgow_gemini_all_rss_max"
                  fi
                  if [ -n "${glasgow_first_ms_mean:-}" ] && [ -n "${glasgow_gemini_first_ms_mean:-}" ]; then
                    t_test_line "runtime ms first baseline vs Gemini" \
                      "$glasgow_first_ms_mean" "$glasgow_first_ms_stdev" "$glasgow_first_ms_n" \
                      "$glasgow_gemini_first_ms_mean" "$glasgow_gemini_first_ms_stdev" "$glasgow_gemini_first_ms_n"
                  fi
                  if [ -n "${glasgow_all_ms_mean:-}" ] && [ -n "${glasgow_gemini_all_ms_mean:-}" ]; then
                    t_test_line "runtime ms all baseline vs Gemini" \
                      "$glasgow_all_ms_mean" "$glasgow_all_ms_stdev" "$glasgow_all_ms_n" \
                      "$glasgow_gemini_all_ms_mean" "$glasgow_gemini_all_ms_stdev" "$glasgow_gemini_all_ms_n"
                  fi
                  echo
                } >> outputs/result.txt
              fi
              if [ -n "${glasgow_first_ms_runs:-}" ] || [ -n "${glasgow_all_ms_runs:-}" ] || [ -n "${glasgow_gemini_first_ms_runs:-}" ] || [ -n "${glasgow_gemini_all_ms_runs:-}" ] || [ -n "${glasgow_chatgpt_first_ms_runs:-}" ] || [ -n "${glasgow_chatgpt_all_ms_runs:-}" ]; then
                SOLVER_TIME_MS_TOTAL="$(sum_ms_runs $glasgow_first_ms_runs $glasgow_all_ms_runs $glasgow_gemini_first_ms_runs $glasgow_gemini_all_ms_runs $glasgow_chatgpt_first_ms_runs $glasgow_chatgpt_all_ms_runs)"
              fi
              ;;
            vf3)
              vf3_base_first_out=""
              vf3_base_first_ms_runs=""
              vf3_base_first_rss_runs=""
              vf3_base_all_out=""
              vf3_base_all_ms_runs=""
              vf3_base_all_rss_runs=""

              vf3_first_out=""
              vf3_first_ms_runs=""
              vf3_first_rss_runs=""
              vf3_all_out=""
              vf3_all_ms_runs=""
              vf3_all_rss_runs=""

              chatvf3_first_out=""
              chatvf3_first_ms_runs=""
              chatvf3_first_rss_runs=""
              chatvf3_all_out=""
              chatvf3_all_ms_runs=""
              chatvf3_all_rss_runs=""

              # Phase 1: setup + warmup (web UI fills the progress bar once here)
              PROGRESS_STAGE="setup"
              progress_set_phase "Setting up Testing Environment"
              if [ "${WARMUP_REQUESTED:-0}" -gt 0 ]; then
                if [ "$INPUT_MODE" = "generate" ]; then
                  out=""
                  dur=""
                  for ((i=1; i<=WARMUP_REQUESTED; i++)); do
                    if ! generate_graphs_for_run "vf3_warmup" "w${i}"; then
                      EXIT_CODE=1
                      break
                    fi
                    if ! run_capture out dur ./baselines/vf3lib/bin/vf3 -r 0 "${FILES[0]}" "${FILES[1]}"; then
                      echo "[Warmup] VF3 baseline all failed." >> outputs/result.txt
                      EXIT_CODE=1
                      break
                    fi
                    progress_setup_tick
                    if ! run_capture out dur ./src/chatvf3 "${FILES[0]}" "${FILES[1]}"; then
                      echo "[Warmup] VF3 ChatGPT all failed." >> outputs/result.txt
                      EXIT_CODE=1
                      break
                    fi
                    progress_setup_tick
                    if ! run_capture out dur ./src/vf3 "${FILES[0]}" "${FILES[1]}"; then
                      echo "[Warmup] VF3 Gemini all failed." >> outputs/result.txt
                      EXIT_CODE=1
                      break
                    fi
                    progress_setup_tick
                  done
                else
                  if ! warmup_only "VF3 baseline all" ./baselines/vf3lib/bin/vf3 -r 0 "${FILES[0]}" "${FILES[1]}"; then
                    EXIT_CODE=1
                  fi
                  if ! warmup_only "VF3 ChatGPT all" ./src/chatvf3 "${FILES[0]}" "${FILES[1]}"; then
                    EXIT_CODE=1
                  fi
                  if ! warmup_only "VF3 Gemini all" ./src/vf3 "${FILES[0]}" "${FILES[1]}"; then
                    EXIT_CODE=1
                  fi
                fi
              else
                progress_setup_tick
              fi
              PROGRESS_SETUP_DONE="$PROGRESS_SETUP_TOTAL"
              progress_update_check_run "in_progress" || true

              # Phase 2: measured iterations (web UI resets the bar and fills again here)
              PROGRESS_STAGE="tests"
              PROGRESS_PHASE=""
              PROGRESS_DONE_TICKS=0
              progress_update_check_run "in_progress" || true
              WARMUP=0

              progress_set_phase "VF3 baseline"
              vf3_success=0
              vf3_fail=0
              vf3_chatgpt_match=0
              vf3_chatgpt_total=0
              vf3_chatgpt_mismatch=0
              vf3_gemini_match=0
              vf3_gemini_total=0
              vf3_gemini_mismatch=0

              base_first_times=()
              base_first_rsses=()
              base_all_times=()
              base_all_rsses=()
              chat_first_times=()
              chat_first_rsses=()
              chat_all_times=()
              chat_all_rsses=()
              gem_first_times=()
              gem_first_rsses=()
              gem_all_times=()
              gem_all_rsses=()
              out=""
              dur=""
              rss=""

              for ((i=1; i<=ITERATIONS; i++)); do
                if [ "$INPUT_MODE" = "generate" ]; then
                  if ! generate_graphs_for_run "vf3_iter" "$i"; then
                    EXIT_CODE=1
                    break
                  fi
                fi

                baseline_ok=0
                progress_set_phase "VF3 baseline"
                max_attempts=1
                if [ "$INPUT_MODE" = "generate" ]; then
                  max_attempts=3
                fi
                attempt=1
                while [ "$attempt" -le "$max_attempts" ]; do
                  if [ "$attempt" -gt 1 ]; then
                    if ! generate_graphs_for_run "vf3_iter_retry" "${i}_retry${attempt}"; then
                      echo "[VF3 baseline] graph regeneration failed (retry)." >> outputs/result.txt
                      break
                    fi
                  fi
                  vf3_err_tmp=""
                  if run_capture_rss_tmp out dur rss vf3_err_tmp ./baselines/vf3lib/bin/vf3 -r 0 "${FILES[0]}" "${FILES[1]}"; then
                    baseline_ok=1
                    if [ -n "${vf3_err_tmp:-}" ] && [ -f "$vf3_err_tmp" ]; then
                      rm -f "$vf3_err_tmp"
                    fi
                    break
                  fi
                  if [ "$attempt" -eq 1 ] && [ "$max_attempts" -gt 1 ]; then
                    echo "[VF3 baseline] run failed; regenerating graph and retrying." >> outputs/result.txt
                  elif [ "$attempt" -lt "$max_attempts" ]; then
                    echo "[VF3 baseline] run failed (retry); regenerating graph and retrying." >> outputs/result.txt
                  else
                    echo "[VF3 baseline] run failed (retry)." >> outputs/result.txt
                  fi
                  if [ -n "${vf3_err_tmp:-}" ] && [ -s "$vf3_err_tmp" ]; then
                    if [ "$attempt" -gt 1 ]; then
                      echo "[VF3 baseline] stderr (retry $attempt):" >> outputs/result.txt
                    else
                      echo "[VF3 baseline] stderr:" >> outputs/result.txt
                    fi
                    head -n 5 "$vf3_err_tmp" >> outputs/result.txt
                  fi
                  if [ -n "${vf3_err_tmp:-}" ] && [ -f "$vf3_err_tmp" ]; then
                    rm -f "$vf3_err_tmp"
                  fi
                  attempt=$((attempt + 1))
                done
                if [ "$baseline_ok" -ne 1 ]; then
                  EXIT_CODE=1
                fi
                if [ "$baseline_ok" -eq 1 ]; then
                  read baseline_count base_first_ms base_all_ms <<< "$(extract_solution_times_ms "$out")"
                  if [ -z "${baseline_count:-}" ] || [ -z "${base_first_ms:-}" ] || [ -z "${base_all_ms:-}" ]; then
                    echo "[VF3 baseline] could not parse solution timings." >> outputs/result.txt
                    baseline_ok=0
                    EXIT_CODE=1
                  else
                    base_first_times+=("$base_first_ms")
                    base_all_times+=("$base_all_ms")
                    base_first_rsses+=("$rss")
                    base_all_rsses+=("$rss")
                    progress_tick
                  fi
                fi

                if [ "$baseline_ok" -ne 1 ]; then
                  vf3_fail=$((vf3_fail + 1))
                  continue
                fi

                vf3_success=$((vf3_success + 1))

                progress_set_phase "VF3 ChatGPT"
                vf3_chatgpt_total=$((vf3_chatgpt_total + 1))
                chat_ok=1
                chat_count=""
                if ! run_capture_rss out dur rss ./src/chatvf3 "${FILES[0]}" "${FILES[1]}"; then
                  EXIT_CODE=1
                  echo "[VF3 ChatGPT] all-solutions run failed." >> outputs/result.txt
                  chat_ok=0
                else
                  read chat_count chat_first_ms chat_all_ms <<< "$(extract_solution_times_ms "$out")"
                  if [ -z "${chat_count:-}" ] || [ -z "${chat_first_ms:-}" ] || [ -z "${chat_all_ms:-}" ]; then
                    EXIT_CODE=1
                    echo "[VF3 ChatGPT] could not parse solution timings." >> outputs/result.txt
                    chat_ok=0
                  else
                    chat_first_times+=("$chat_first_ms")
                    chat_all_times+=("$chat_all_ms")
                    chat_first_rsses+=("$rss")
                    chat_all_rsses+=("$rss")
                    progress_tick
                  fi
                fi
                if [ "$chat_ok" -eq 1 ] && [ -n "${chat_count:-}" ] && [ "$chat_count" = "$baseline_count" ]; then
                  vf3_chatgpt_match=$((vf3_chatgpt_match + 1))
                else
                  vf3_chatgpt_mismatch=$((vf3_chatgpt_mismatch + 1))
                fi

                progress_set_phase "VF3 Gemini"
                vf3_gemini_total=$((vf3_gemini_total + 1))
                gem_ok=1
                gem_count=""
                if ! run_capture_rss out dur rss ./src/vf3 "${FILES[0]}" "${FILES[1]}"; then
                  EXIT_CODE=1
                  echo "[VF3 Gemini] all-solutions run failed." >> outputs/result.txt
                  gem_ok=0
                else
                  read gem_count gem_first_ms gem_all_ms <<< "$(extract_solution_times_ms "$out")"
                  if [ -z "${gem_count:-}" ] || [ -z "${gem_first_ms:-}" ] || [ -z "${gem_all_ms:-}" ]; then
                    EXIT_CODE=1
                    echo "[VF3 Gemini] could not parse solution timings." >> outputs/result.txt
                    gem_ok=0
                  else
                    gem_first_times+=("$gem_first_ms")
                    gem_all_times+=("$gem_all_ms")
                    gem_first_rsses+=("$rss")
                    gem_all_rsses+=("$rss")
                    progress_tick
                  fi
                fi
                if [ "$gem_ok" -eq 1 ] && [ -n "${gem_count:-}" ] && [ "$gem_count" = "$baseline_count" ]; then
                  vf3_gemini_match=$((vf3_gemini_match + 1))
                else
                  vf3_gemini_mismatch=$((vf3_gemini_mismatch + 1))
                fi
              done

              vf3_base_first_ms_runs="${base_first_times[*]}"
              vf3_base_first_rss_runs="${base_first_rsses[*]}"
              vf3_base_all_ms_runs="${base_all_times[*]}"
              vf3_base_all_rss_runs="${base_all_rsses[*]}"
              chatvf3_first_ms_runs="${chat_first_times[*]}"
              chatvf3_first_rss_runs="${chat_first_rsses[*]}"
              chatvf3_all_ms_runs="${chat_all_times[*]}"
              chatvf3_all_rss_runs="${chat_all_rsses[*]}"
              vf3_first_ms_runs="${gem_first_times[*]}"
              vf3_first_rss_runs="${gem_first_rsses[*]}"
              vf3_all_ms_runs="${gem_all_times[*]}"
              vf3_all_rss_runs="${gem_all_rsses[*]}"

              if [ -n "${vf3_base_first_ms_runs:-}" ]; then
                read vf3_base_first_ms_median vf3_base_first_ms_mean vf3_base_first_ms_stdev vf3_base_first_ms_min vf3_base_first_ms_max vf3_base_first_ms_n <<< "$(calc_stats_ms $vf3_base_first_ms_runs)"
                vf3_base_first_ms="$vf3_base_first_ms_median"
              fi
              if [ -n "${vf3_base_all_ms_runs:-}" ]; then
                read vf3_base_all_ms_median vf3_base_all_ms_mean vf3_base_all_ms_stdev vf3_base_all_ms_min vf3_base_all_ms_max vf3_base_all_ms_n <<< "$(calc_stats_ms $vf3_base_all_ms_runs)"
                vf3_base_all_ms="$vf3_base_all_ms_median"
              fi
              if [ -n "${vf3_base_first_rss_runs:-}" ]; then
                read vf3_base_first_rss_median vf3_base_first_rss_mean vf3_base_first_rss_stdev vf3_base_first_rss_min vf3_base_first_rss_max vf3_base_first_rss_n <<< "$(calc_stats_kb $vf3_base_first_rss_runs)"
                vf3_base_first_rss_kb="$vf3_base_first_rss_median"
              fi
              if [ -n "${vf3_base_all_rss_runs:-}" ]; then
                read vf3_base_all_rss_median vf3_base_all_rss_mean vf3_base_all_rss_stdev vf3_base_all_rss_min vf3_base_all_rss_max vf3_base_all_rss_n <<< "$(calc_stats_kb $vf3_base_all_rss_runs)"
                vf3_base_all_rss_kb="$vf3_base_all_rss_median"
              fi
              if [ "$ITERATIONS" -ge 1 ]; then
                vf3_failure_suffix=""
                if [ "${vf3_fail:-0}" -gt 0 ]; then
                  vf3_failure_suffix=", ${vf3_fail} failed"
                fi
                {
                  echo "[VF3 baseline]"
                  echo "${vf3_success} iterations ran successfully${vf3_failure_suffix}"
                  echo "Warmup: $WARMUP_REQUESTED"
                  echo "Iterations: $ITERATIONS"
                  if [ -n "${vf3_base_first_ms_median:-}" ] && [ -n "${vf3_base_all_ms_median:-}" ]; then
                    print_stats_ms_first_all "Runtime (ms): " \
                      "$vf3_base_first_ms_median" "$vf3_base_first_ms_mean" "$vf3_base_first_ms_stdev" "$vf3_base_first_ms_min" "$vf3_base_first_ms_max" \
                      "$vf3_base_all_ms_median" "$vf3_base_all_ms_mean" "$vf3_base_all_ms_stdev" "$vf3_base_all_ms_min" "$vf3_base_all_ms_max"
                  fi
                  if [ -n "${vf3_base_first_rss_median:-}" ] && [ -n "${vf3_base_all_rss_median:-}" ]; then
                    print_stats_kb_first_all "Max RSS (kB): " \
                      "$vf3_base_first_rss_median" "$vf3_base_first_rss_mean" "$vf3_base_first_rss_stdev" "$vf3_base_first_rss_min" "$vf3_base_first_rss_max" \
                      "$vf3_base_all_rss_median" "$vf3_base_all_rss_mean" "$vf3_base_all_rss_stdev" "$vf3_base_all_rss_min" "$vf3_base_all_rss_max"
                  fi
                  echo
                } >> outputs/result.txt
              fi

              if [ -n "${chatvf3_first_ms_runs:-}" ]; then
                read chatvf3_first_ms_median chatvf3_first_ms_mean chatvf3_first_ms_stdev chatvf3_first_ms_min chatvf3_first_ms_max chatvf3_first_ms_n <<< "$(calc_stats_ms $chatvf3_first_ms_runs)"
                chatvf3_first_ms="$chatvf3_first_ms_median"
              fi
              if [ -n "${chatvf3_all_ms_runs:-}" ]; then
                read chatvf3_all_ms_median chatvf3_all_ms_mean chatvf3_all_ms_stdev chatvf3_all_ms_min chatvf3_all_ms_max chatvf3_all_ms_n <<< "$(calc_stats_ms $chatvf3_all_ms_runs)"
                chatvf3_all_ms="$chatvf3_all_ms_median"
              fi
              if [ -n "${chatvf3_first_rss_runs:-}" ]; then
                read chatvf3_first_rss_median chatvf3_first_rss_mean chatvf3_first_rss_stdev chatvf3_first_rss_min chatvf3_first_rss_max chatvf3_first_rss_n <<< "$(calc_stats_kb $chatvf3_first_rss_runs)"
                chatvf3_first_rss_kb="$chatvf3_first_rss_median"
              fi
              if [ -n "${chatvf3_all_rss_runs:-}" ]; then
                read chatvf3_all_rss_median chatvf3_all_rss_mean chatvf3_all_rss_stdev chatvf3_all_rss_min chatvf3_all_rss_max chatvf3_all_rss_n <<< "$(calc_stats_kb $chatvf3_all_rss_runs)"
                chatvf3_all_rss_kb="$chatvf3_all_rss_median"
              fi
              if [ "$ITERATIONS" -ge 1 ]; then
                {
                  echo "[VF3 ChatGPT]"
                  echo "Matches: ${vf3_chatgpt_match}/${vf3_chatgpt_total} (mismatches: ${vf3_chatgpt_mismatch})"
                  echo "Warmup: $WARMUP_REQUESTED"
                  echo "Iterations: $ITERATIONS"
                  if [ -n "${chatvf3_first_ms_median:-}" ] && [ -n "${chatvf3_all_ms_median:-}" ]; then
                    print_stats_ms_first_all "Runtime (ms): " \
                      "$chatvf3_first_ms_median" "$chatvf3_first_ms_mean" "$chatvf3_first_ms_stdev" "$chatvf3_first_ms_min" "$chatvf3_first_ms_max" \
                      "$chatvf3_all_ms_median" "$chatvf3_all_ms_mean" "$chatvf3_all_ms_stdev" "$chatvf3_all_ms_min" "$chatvf3_all_ms_max"
                  fi
                  if [ -n "${chatvf3_first_rss_median:-}" ] && [ -n "${chatvf3_all_rss_median:-}" ]; then
                    print_stats_kb_first_all "Max RSS (kB): " \
                      "$chatvf3_first_rss_median" "$chatvf3_first_rss_mean" "$chatvf3_first_rss_stdev" "$chatvf3_first_rss_min" "$chatvf3_first_rss_max" \
                      "$chatvf3_all_rss_median" "$chatvf3_all_rss_mean" "$chatvf3_all_rss_stdev" "$chatvf3_all_rss_min" "$chatvf3_all_rss_max"
                  fi
                  if [ -n "${vf3_base_first_ms_mean:-}" ] && [ -n "${chatvf3_first_ms_mean:-}" ]; then
                    t_test_line "runtime ms first baseline vs ChatGPT" \
                      "$vf3_base_first_ms_mean" "$vf3_base_first_ms_stdev" "$vf3_base_first_ms_n" \
                      "$chatvf3_first_ms_mean" "$chatvf3_first_ms_stdev" "$chatvf3_first_ms_n"
                  fi
                  if [ -n "${vf3_base_all_ms_mean:-}" ] && [ -n "${chatvf3_all_ms_mean:-}" ]; then
                    t_test_line "runtime ms all baseline vs ChatGPT" \
                      "$vf3_base_all_ms_mean" "$vf3_base_all_ms_stdev" "$vf3_base_all_ms_n" \
                      "$chatvf3_all_ms_mean" "$chatvf3_all_ms_stdev" "$chatvf3_all_ms_n"
                  fi
                  echo
                } >> outputs/result.txt
              fi

              if [ -n "${vf3_first_ms_runs:-}" ]; then
                read vf3_first_ms_median vf3_first_ms_mean vf3_first_ms_stdev vf3_first_ms_min vf3_first_ms_max vf3_first_ms_n <<< "$(calc_stats_ms $vf3_first_ms_runs)"
                vf3_first_ms="$vf3_first_ms_median"
              fi
              if [ -n "${vf3_all_ms_runs:-}" ]; then
                read vf3_all_ms_median vf3_all_ms_mean vf3_all_ms_stdev vf3_all_ms_min vf3_all_ms_max vf3_all_ms_n <<< "$(calc_stats_ms $vf3_all_ms_runs)"
                vf3_all_ms="$vf3_all_ms_median"
              fi
              if [ -n "${vf3_first_rss_runs:-}" ]; then
                read vf3_first_rss_median vf3_first_rss_mean vf3_first_rss_stdev vf3_first_rss_min vf3_first_rss_max vf3_first_rss_n <<< "$(calc_stats_kb $vf3_first_rss_runs)"
                vf3_first_rss_kb="$vf3_first_rss_median"
              fi
              if [ -n "${vf3_all_rss_runs:-}" ]; then
                read vf3_all_rss_median vf3_all_rss_mean vf3_all_rss_stdev vf3_all_rss_min vf3_all_rss_max vf3_all_rss_n <<< "$(calc_stats_kb $vf3_all_rss_runs)"
                vf3_all_rss_kb="$vf3_all_rss_median"
              fi
              if [ "$ITERATIONS" -ge 1 ]; then
                {
                  echo "[VF3 Gemini]"
                  echo "Matches: ${vf3_gemini_match}/${vf3_gemini_total} (mismatches: ${vf3_gemini_mismatch})"
                  echo "Warmup: $WARMUP_REQUESTED"
                  echo "Iterations: $ITERATIONS"
                  if [ -n "${vf3_first_ms_median:-}" ] && [ -n "${vf3_all_ms_median:-}" ]; then
                    print_stats_ms_first_all "Runtime (ms): " \
                      "$vf3_first_ms_median" "$vf3_first_ms_mean" "$vf3_first_ms_stdev" "$vf3_first_ms_min" "$vf3_first_ms_max" \
                      "$vf3_all_ms_median" "$vf3_all_ms_mean" "$vf3_all_ms_stdev" "$vf3_all_ms_min" "$vf3_all_ms_max"
                  fi
                  if [ -n "${vf3_first_rss_median:-}" ] && [ -n "${vf3_all_rss_median:-}" ]; then
                    print_stats_kb_first_all "Max RSS (kB): " \
                      "$vf3_first_rss_median" "$vf3_first_rss_mean" "$vf3_first_rss_stdev" "$vf3_first_rss_min" "$vf3_first_rss_max" \
                      "$vf3_all_rss_median" "$vf3_all_rss_mean" "$vf3_all_rss_stdev" "$vf3_all_rss_min" "$vf3_all_rss_max"
                  fi
                  if [ -n "${vf3_base_first_ms_mean:-}" ] && [ -n "${vf3_first_ms_mean:-}" ]; then
                    t_test_line "runtime ms first baseline vs Gemini" \
                      "$vf3_base_first_ms_mean" "$vf3_base_first_ms_stdev" "$vf3_base_first_ms_n" \
                      "$vf3_first_ms_mean" "$vf3_first_ms_stdev" "$vf3_first_ms_n"
                  fi
                  if [ -n "${vf3_base_all_ms_mean:-}" ] && [ -n "${vf3_all_ms_mean:-}" ]; then
                    t_test_line "runtime ms all baseline vs Gemini" \
                      "$vf3_base_all_ms_mean" "$vf3_base_all_ms_stdev" "$vf3_base_all_ms_n" \
                      "$vf3_all_ms_mean" "$vf3_all_ms_stdev" "$vf3_all_ms_n"
                  fi
                  echo
                } >> outputs/result.txt
              fi
              if [ -n "${vf3_base_all_ms_runs:-}" ] || [ -n "${vf3_all_ms_runs:-}" ] || [ -n "${chatvf3_all_ms_runs:-}" ]; then
                SOLVER_TIME_MS_TOTAL="$(sum_ms_runs $vf3_base_all_ms_runs $vf3_all_ms_runs $chatvf3_all_ms_runs)"
              fi
              ;;
            *)
              echo "Unknown algorithm: $ALGORITHM" >> outputs/result.txt
              EXIT_CODE=1
              ;;
          esac
          
          finish_run
          echo "EXIT_CODE=$EXIT_CODE" >> "$GITHUB_OUTPUT"
          echo "REQUEST_ID=${REQUEST_ID}" >> "$GITHUB_OUTPUT"
          echo "ITERATIONS=${ITERATIONS}" >> "$GITHUB_OUTPUT"
          echo "WARMUP=${WARMUP_REQUESTED}" >> "$GITHUB_OUTPUT"
          echo "DIJKSTRA_BASELINE_MS=${dijkstra_baseline_ms:-}" >> "$GITHUB_OUTPUT"
          echo "DIJKSTRA_LLM_MS=${dijkstra_llm_ms:-}" >> "$GITHUB_OUTPUT"
          echo "DIJKSTRA_BASELINE_MS_STDEV=${dijkstra_baseline_ms_stdev:-}" >> "$GITHUB_OUTPUT"
          echo "DIJKSTRA_LLM_MS_STDEV=${dijkstra_llm_ms_stdev:-}" >> "$GITHUB_OUTPUT"
          echo "DIJKSTRA_BASELINE_RSS_KB=${dijkstra_baseline_rss_kb:-}" >> "$GITHUB_OUTPUT"
          echo "DIJKSTRA_LLM_RSS_KB=${dijkstra_llm_rss_kb:-}" >> "$GITHUB_OUTPUT"
          echo "DIJKSTRA_BASELINE_RSS_KB_STDEV=${dijkstra_baseline_rss_stdev:-}" >> "$GITHUB_OUTPUT"
          echo "DIJKSTRA_LLM_RSS_KB_STDEV=${dijkstra_llm_rss_stdev:-}" >> "$GITHUB_OUTPUT"
          echo "GLASGOW_FIRST_MS=${glasgow_first_ms:-}" >> "$GITHUB_OUTPUT"
          echo "GLASGOW_ALL_MS=${glasgow_all_ms:-}" >> "$GITHUB_OUTPUT"
          echo "GLASGOW_FIRST_MS_STDEV=${glasgow_first_ms_stdev:-}" >> "$GITHUB_OUTPUT"
          echo "GLASGOW_ALL_MS_STDEV=${glasgow_all_ms_stdev:-}" >> "$GITHUB_OUTPUT"
          echo "GLASGOW_FIRST_RSS_KB=${glasgow_first_rss_kb:-}" >> "$GITHUB_OUTPUT"
          echo "GLASGOW_ALL_RSS_KB=${glasgow_all_rss_kb:-}" >> "$GITHUB_OUTPUT"
          echo "GLASGOW_FIRST_RSS_KB_STDEV=${glasgow_first_rss_stdev:-}" >> "$GITHUB_OUTPUT"
          echo "GLASGOW_ALL_RSS_KB_STDEV=${glasgow_all_rss_stdev:-}" >> "$GITHUB_OUTPUT"
          echo "GLASGOW_GEMINI_FIRST_MS=${glasgow_gemini_first_ms:-}" >> "$GITHUB_OUTPUT"
          echo "GLASGOW_GEMINI_ALL_MS=${glasgow_gemini_all_ms:-}" >> "$GITHUB_OUTPUT"
          echo "GLASGOW_GEMINI_FIRST_MS_STDEV=${glasgow_gemini_first_ms_stdev:-}" >> "$GITHUB_OUTPUT"
          echo "GLASGOW_GEMINI_ALL_MS_STDEV=${glasgow_gemini_all_ms_stdev:-}" >> "$GITHUB_OUTPUT"
          echo "GLASGOW_GEMINI_FIRST_RSS_KB=${glasgow_gemini_first_rss_kb:-}" >> "$GITHUB_OUTPUT"
          echo "GLASGOW_GEMINI_ALL_RSS_KB=${glasgow_gemini_all_rss_kb:-}" >> "$GITHUB_OUTPUT"
          echo "GLASGOW_GEMINI_FIRST_RSS_KB_STDEV=${glasgow_gemini_first_rss_stdev:-}" >> "$GITHUB_OUTPUT"
          echo "GLASGOW_GEMINI_ALL_RSS_KB_STDEV=${glasgow_gemini_all_rss_stdev:-}" >> "$GITHUB_OUTPUT"
          echo "GLASGOW_CHATGPT_FIRST_MS=${glasgow_chatgpt_first_ms:-}" >> "$GITHUB_OUTPUT"
          echo "GLASGOW_CHATGPT_ALL_MS=${glasgow_chatgpt_all_ms:-}" >> "$GITHUB_OUTPUT"
          echo "GLASGOW_CHATGPT_FIRST_MS_STDEV=${glasgow_chatgpt_first_ms_stdev:-}" >> "$GITHUB_OUTPUT"
          echo "GLASGOW_CHATGPT_ALL_MS_STDEV=${glasgow_chatgpt_all_ms_stdev:-}" >> "$GITHUB_OUTPUT"
          echo "GLASGOW_CHATGPT_FIRST_RSS_KB=${glasgow_chatgpt_first_rss_kb:-}" >> "$GITHUB_OUTPUT"
          echo "GLASGOW_CHATGPT_ALL_RSS_KB=${glasgow_chatgpt_all_rss_kb:-}" >> "$GITHUB_OUTPUT"
          echo "GLASGOW_CHATGPT_FIRST_RSS_KB_STDEV=${glasgow_chatgpt_first_rss_stdev:-}" >> "$GITHUB_OUTPUT"
          echo "GLASGOW_CHATGPT_ALL_RSS_KB_STDEV=${glasgow_chatgpt_all_rss_stdev:-}" >> "$GITHUB_OUTPUT"
          echo "GLASGOW_BASELINE_SUCCESS=${glasgow_success:-}" >> "$GITHUB_OUTPUT"
          echo "GLASGOW_BASELINE_FAILED=${glasgow_fail:-}" >> "$GITHUB_OUTPUT"
          echo "GLASGOW_CHATGPT_MATCH=${glasgow_chatgpt_match:-}" >> "$GITHUB_OUTPUT"
          echo "GLASGOW_CHATGPT_TOTAL=${glasgow_chatgpt_total:-}" >> "$GITHUB_OUTPUT"
          echo "GLASGOW_CHATGPT_MISMATCH=${glasgow_chatgpt_mismatch:-}" >> "$GITHUB_OUTPUT"
          echo "GLASGOW_GEMINI_MATCH=${glasgow_gemini_match:-}" >> "$GITHUB_OUTPUT"
          echo "GLASGOW_GEMINI_TOTAL=${glasgow_gemini_total:-}" >> "$GITHUB_OUTPUT"
          echo "GLASGOW_GEMINI_MISMATCH=${glasgow_gemini_mismatch:-}" >> "$GITHUB_OUTPUT"
          echo "VF3_BASE_FIRST_MS=${vf3_base_first_ms:-}" >> "$GITHUB_OUTPUT"
          echo "VF3_BASE_ALL_MS=${vf3_base_all_ms:-}" >> "$GITHUB_OUTPUT"
          echo "VF3_BASE_FIRST_MS_STDEV=${vf3_base_first_ms_stdev:-}" >> "$GITHUB_OUTPUT"
          echo "VF3_BASE_ALL_MS_STDEV=${vf3_base_all_ms_stdev:-}" >> "$GITHUB_OUTPUT"
          echo "VF3_BASE_FIRST_RSS_KB=${vf3_base_first_rss_kb:-}" >> "$GITHUB_OUTPUT"
          echo "VF3_BASE_ALL_RSS_KB=${vf3_base_all_rss_kb:-}" >> "$GITHUB_OUTPUT"
          echo "VF3_BASE_FIRST_RSS_KB_STDEV=${vf3_base_first_rss_stdev:-}" >> "$GITHUB_OUTPUT"
          echo "VF3_BASE_ALL_RSS_KB_STDEV=${vf3_base_all_rss_stdev:-}" >> "$GITHUB_OUTPUT"
          echo "VF3_GEMINI_FIRST_MS=${vf3_first_ms:-}" >> "$GITHUB_OUTPUT"
          echo "VF3_GEMINI_ALL_MS=${vf3_all_ms:-}" >> "$GITHUB_OUTPUT"
          echo "VF3_GEMINI_FIRST_MS_STDEV=${vf3_first_ms_stdev:-}" >> "$GITHUB_OUTPUT"
          echo "VF3_GEMINI_ALL_MS_STDEV=${vf3_all_ms_stdev:-}" >> "$GITHUB_OUTPUT"
          echo "VF3_GEMINI_FIRST_RSS_KB=${vf3_first_rss_kb:-}" >> "$GITHUB_OUTPUT"
          echo "VF3_GEMINI_ALL_RSS_KB=${vf3_all_rss_kb:-}" >> "$GITHUB_OUTPUT"
          echo "VF3_GEMINI_FIRST_RSS_KB_STDEV=${vf3_first_rss_stdev:-}" >> "$GITHUB_OUTPUT"
          echo "VF3_GEMINI_ALL_RSS_KB_STDEV=${vf3_all_rss_stdev:-}" >> "$GITHUB_OUTPUT"
          echo "VF3_CHATGPT_FIRST_MS=${chatvf3_first_ms:-}" >> "$GITHUB_OUTPUT"
          echo "VF3_CHATGPT_ALL_MS=${chatvf3_all_ms:-}" >> "$GITHUB_OUTPUT"
          echo "VF3_CHATGPT_FIRST_MS_STDEV=${chatvf3_first_ms_stdev:-}" >> "$GITHUB_OUTPUT"
          echo "VF3_CHATGPT_ALL_MS_STDEV=${chatvf3_all_ms_stdev:-}" >> "$GITHUB_OUTPUT"
          echo "VF3_CHATGPT_FIRST_RSS_KB=${chatvf3_first_rss_kb:-}" >> "$GITHUB_OUTPUT"
          echo "VF3_CHATGPT_ALL_RSS_KB=${chatvf3_all_rss_kb:-}" >> "$GITHUB_OUTPUT"
          echo "VF3_CHATGPT_FIRST_RSS_KB_STDEV=${chatvf3_first_rss_stdev:-}" >> "$GITHUB_OUTPUT"
          echo "VF3_CHATGPT_ALL_RSS_KB_STDEV=${chatvf3_all_rss_stdev:-}" >> "$GITHUB_OUTPUT"
          echo "VF3_BASELINE_SUCCESS=${vf3_success:-}" >> "$GITHUB_OUTPUT"
          echo "VF3_BASELINE_FAILED=${vf3_fail:-}" >> "$GITHUB_OUTPUT"
          echo "VF3_CHATGPT_MATCH=${vf3_chatgpt_match:-}" >> "$GITHUB_OUTPUT"
          echo "VF3_CHATGPT_TOTAL=${vf3_chatgpt_total:-}" >> "$GITHUB_OUTPUT"
          echo "VF3_CHATGPT_MISMATCH=${vf3_chatgpt_mismatch:-}" >> "$GITHUB_OUTPUT"
          echo "VF3_GEMINI_MATCH=${vf3_gemini_match:-}" >> "$GITHUB_OUTPUT"
          echo "VF3_GEMINI_TOTAL=${vf3_gemini_total:-}" >> "$GITHUB_OUTPUT"
          echo "VF3_GEMINI_MISMATCH=${vf3_gemini_mismatch:-}" >> "$GITHUB_OUTPUT"
          echo "SEED_USED=${SEED_USED:-}" >> "$GITHUB_OUTPUT"
          # Always exit 0 so later steps run and results are committed
          exit 0
      
      - name: Create result JSON
        if: always()
        env:
          EXIT_CODE: ${{ steps.run.outputs.EXIT_CODE }}
          ITERATIONS: ${{ steps.run.outputs.ITERATIONS }}
          WARMUP: ${{ steps.run.outputs.WARMUP }}
          RUN_DURATION_MS: ${{ steps.run.outputs.RUN_DURATION_MS }}
          SEED_USED: ${{ steps.run.outputs.SEED_USED }}
          DIJKSTRA_BASELINE_MS: ${{ steps.run.outputs.DIJKSTRA_BASELINE_MS }}
          DIJKSTRA_LLM_MS: ${{ steps.run.outputs.DIJKSTRA_LLM_MS }}
          DIJKSTRA_BASELINE_MS_STDEV: ${{ steps.run.outputs.DIJKSTRA_BASELINE_MS_STDEV }}
          DIJKSTRA_LLM_MS_STDEV: ${{ steps.run.outputs.DIJKSTRA_LLM_MS_STDEV }}
          DIJKSTRA_BASELINE_RSS_KB: ${{ steps.run.outputs.DIJKSTRA_BASELINE_RSS_KB }}
          DIJKSTRA_LLM_RSS_KB: ${{ steps.run.outputs.DIJKSTRA_LLM_RSS_KB }}
          DIJKSTRA_BASELINE_RSS_KB_STDEV: ${{ steps.run.outputs.DIJKSTRA_BASELINE_RSS_KB_STDEV }}
          DIJKSTRA_LLM_RSS_KB_STDEV: ${{ steps.run.outputs.DIJKSTRA_LLM_RSS_KB_STDEV }}
          GLASGOW_FIRST_MS: ${{ steps.run.outputs.GLASGOW_FIRST_MS }}
          GLASGOW_ALL_MS: ${{ steps.run.outputs.GLASGOW_ALL_MS }}
          GLASGOW_FIRST_MS_STDEV: ${{ steps.run.outputs.GLASGOW_FIRST_MS_STDEV }}
          GLASGOW_ALL_MS_STDEV: ${{ steps.run.outputs.GLASGOW_ALL_MS_STDEV }}
          GLASGOW_FIRST_RSS_KB: ${{ steps.run.outputs.GLASGOW_FIRST_RSS_KB }}
          GLASGOW_ALL_RSS_KB: ${{ steps.run.outputs.GLASGOW_ALL_RSS_KB }}
          GLASGOW_FIRST_RSS_KB_STDEV: ${{ steps.run.outputs.GLASGOW_FIRST_RSS_KB_STDEV }}
          GLASGOW_ALL_RSS_KB_STDEV: ${{ steps.run.outputs.GLASGOW_ALL_RSS_KB_STDEV }}
          GLASGOW_GEMINI_FIRST_MS: ${{ steps.run.outputs.GLASGOW_GEMINI_FIRST_MS }}
          GLASGOW_GEMINI_ALL_MS: ${{ steps.run.outputs.GLASGOW_GEMINI_ALL_MS }}
          GLASGOW_GEMINI_FIRST_MS_STDEV: ${{ steps.run.outputs.GLASGOW_GEMINI_FIRST_MS_STDEV }}
          GLASGOW_GEMINI_ALL_MS_STDEV: ${{ steps.run.outputs.GLASGOW_GEMINI_ALL_MS_STDEV }}
          GLASGOW_GEMINI_FIRST_RSS_KB: ${{ steps.run.outputs.GLASGOW_GEMINI_FIRST_RSS_KB }}
          GLASGOW_GEMINI_ALL_RSS_KB: ${{ steps.run.outputs.GLASGOW_GEMINI_ALL_RSS_KB }}
          GLASGOW_GEMINI_FIRST_RSS_KB_STDEV: ${{ steps.run.outputs.GLASGOW_GEMINI_FIRST_RSS_KB_STDEV }}
          GLASGOW_GEMINI_ALL_RSS_KB_STDEV: ${{ steps.run.outputs.GLASGOW_GEMINI_ALL_RSS_KB_STDEV }}
          GLASGOW_CHATGPT_FIRST_MS: ${{ steps.run.outputs.GLASGOW_CHATGPT_FIRST_MS }}
          GLASGOW_CHATGPT_ALL_MS: ${{ steps.run.outputs.GLASGOW_CHATGPT_ALL_MS }}
          GLASGOW_CHATGPT_FIRST_MS_STDEV: ${{ steps.run.outputs.GLASGOW_CHATGPT_FIRST_MS_STDEV }}
          GLASGOW_CHATGPT_ALL_MS_STDEV: ${{ steps.run.outputs.GLASGOW_CHATGPT_ALL_MS_STDEV }}
          GLASGOW_CHATGPT_FIRST_RSS_KB: ${{ steps.run.outputs.GLASGOW_CHATGPT_FIRST_RSS_KB }}
          GLASGOW_CHATGPT_ALL_RSS_KB: ${{ steps.run.outputs.GLASGOW_CHATGPT_ALL_RSS_KB }}
          GLASGOW_CHATGPT_FIRST_RSS_KB_STDEV: ${{ steps.run.outputs.GLASGOW_CHATGPT_FIRST_RSS_KB_STDEV }}
          GLASGOW_CHATGPT_ALL_RSS_KB_STDEV: ${{ steps.run.outputs.GLASGOW_CHATGPT_ALL_RSS_KB_STDEV }}
          GLASGOW_BASELINE_SUCCESS: ${{ steps.run.outputs.GLASGOW_BASELINE_SUCCESS }}
          GLASGOW_BASELINE_FAILED: ${{ steps.run.outputs.GLASGOW_BASELINE_FAILED }}
          GLASGOW_CHATGPT_MATCH: ${{ steps.run.outputs.GLASGOW_CHATGPT_MATCH }}
          GLASGOW_CHATGPT_TOTAL: ${{ steps.run.outputs.GLASGOW_CHATGPT_TOTAL }}
          GLASGOW_CHATGPT_MISMATCH: ${{ steps.run.outputs.GLASGOW_CHATGPT_MISMATCH }}
          GLASGOW_GEMINI_MATCH: ${{ steps.run.outputs.GLASGOW_GEMINI_MATCH }}
          GLASGOW_GEMINI_TOTAL: ${{ steps.run.outputs.GLASGOW_GEMINI_TOTAL }}
          GLASGOW_GEMINI_MISMATCH: ${{ steps.run.outputs.GLASGOW_GEMINI_MISMATCH }}
          VF3_BASE_FIRST_MS: ${{ steps.run.outputs.VF3_BASE_FIRST_MS }}
          VF3_BASE_ALL_MS: ${{ steps.run.outputs.VF3_BASE_ALL_MS }}
          VF3_BASE_FIRST_MS_STDEV: ${{ steps.run.outputs.VF3_BASE_FIRST_MS_STDEV }}
          VF3_BASE_ALL_MS_STDEV: ${{ steps.run.outputs.VF3_BASE_ALL_MS_STDEV }}
          VF3_BASE_FIRST_RSS_KB: ${{ steps.run.outputs.VF3_BASE_FIRST_RSS_KB }}
          VF3_BASE_ALL_RSS_KB: ${{ steps.run.outputs.VF3_BASE_ALL_RSS_KB }}
          VF3_BASE_FIRST_RSS_KB_STDEV: ${{ steps.run.outputs.VF3_BASE_FIRST_RSS_KB_STDEV }}
          VF3_BASE_ALL_RSS_KB_STDEV: ${{ steps.run.outputs.VF3_BASE_ALL_RSS_KB_STDEV }}
          VF3_GEMINI_FIRST_MS: ${{ steps.run.outputs.VF3_GEMINI_FIRST_MS }}
          VF3_GEMINI_ALL_MS: ${{ steps.run.outputs.VF3_GEMINI_ALL_MS }}
          VF3_GEMINI_FIRST_MS_STDEV: ${{ steps.run.outputs.VF3_GEMINI_FIRST_MS_STDEV }}
          VF3_GEMINI_ALL_MS_STDEV: ${{ steps.run.outputs.VF3_GEMINI_ALL_MS_STDEV }}
          VF3_GEMINI_FIRST_RSS_KB: ${{ steps.run.outputs.VF3_GEMINI_FIRST_RSS_KB }}
          VF3_GEMINI_ALL_RSS_KB: ${{ steps.run.outputs.VF3_GEMINI_ALL_RSS_KB }}
          VF3_GEMINI_FIRST_RSS_KB_STDEV: ${{ steps.run.outputs.VF3_GEMINI_FIRST_RSS_KB_STDEV }}
          VF3_GEMINI_ALL_RSS_KB_STDEV: ${{ steps.run.outputs.VF3_GEMINI_ALL_RSS_KB_STDEV }}
          VF3_CHATGPT_FIRST_MS: ${{ steps.run.outputs.VF3_CHATGPT_FIRST_MS }}
          VF3_CHATGPT_ALL_MS: ${{ steps.run.outputs.VF3_CHATGPT_ALL_MS }}
          VF3_CHATGPT_FIRST_MS_STDEV: ${{ steps.run.outputs.VF3_CHATGPT_FIRST_MS_STDEV }}
          VF3_CHATGPT_ALL_MS_STDEV: ${{ steps.run.outputs.VF3_CHATGPT_ALL_MS_STDEV }}
          VF3_CHATGPT_FIRST_RSS_KB: ${{ steps.run.outputs.VF3_CHATGPT_FIRST_RSS_KB }}
          VF3_CHATGPT_ALL_RSS_KB: ${{ steps.run.outputs.VF3_CHATGPT_ALL_RSS_KB }}
          VF3_CHATGPT_FIRST_RSS_KB_STDEV: ${{ steps.run.outputs.VF3_CHATGPT_FIRST_RSS_KB_STDEV }}
          VF3_CHATGPT_ALL_RSS_KB_STDEV: ${{ steps.run.outputs.VF3_CHATGPT_ALL_RSS_KB_STDEV }}
          VF3_BASELINE_SUCCESS: ${{ steps.run.outputs.VF3_BASELINE_SUCCESS }}
          VF3_BASELINE_FAILED: ${{ steps.run.outputs.VF3_BASELINE_FAILED }}
          VF3_CHATGPT_MATCH: ${{ steps.run.outputs.VF3_CHATGPT_MATCH }}
          VF3_CHATGPT_TOTAL: ${{ steps.run.outputs.VF3_CHATGPT_TOTAL }}
          VF3_CHATGPT_MISMATCH: ${{ steps.run.outputs.VF3_CHATGPT_MISMATCH }}
          VF3_GEMINI_MATCH: ${{ steps.run.outputs.VF3_GEMINI_MATCH }}
          VF3_GEMINI_TOTAL: ${{ steps.run.outputs.VF3_GEMINI_TOTAL }}
          VF3_GEMINI_MISMATCH: ${{ steps.run.outputs.VF3_GEMINI_MISMATCH }}
        run: |
          python - <<'PY'
          import datetime
          import json
          import os
          from pathlib import Path

          algorithm = os.environ.get("ALGORITHM_INPUT", "")
          exit_code = os.environ.get("EXIT_CODE", "")
          request_id = os.environ.get("REQUEST_ID_INPUT", "")
          timestamp = datetime.datetime.now(datetime.timezone.utc).strftime("%Y-%m-%d %H:%M:%S UTC")
          input_mode = os.environ.get("INPUT_MODE_INPUT", "")
          input_files = os.environ.get("INPUT_FILES_INPUT", "")
          gen_n = os.environ.get("GENERATOR_N_INPUT", "")
          gen_k = os.environ.get("GENERATOR_K_INPUT", "")
          gen_density = os.environ.get("GENERATOR_DENSITY_INPUT", "")
          seed_used = os.environ.get("SEED_USED", "")

          result_txt = Path("outputs/result.txt")
          text = ""
          if result_txt.exists():
              text = result_txt.read_text(encoding="utf-8", errors="replace")

          if exit_code == "0":
              status = "success"
              output = text or "No output"
              error = ""
          else:
              status = "error"
              output = ""
              error = text or "Unknown error"

          Path("outputs").mkdir(parents=True, exist_ok=True)
          data = {
              "algorithm": algorithm,
              "timestamp": timestamp,
              "status": status,
              "output": output,
              "error": error,
              "request_id": request_id,
          }
          inputs = {"input_mode": input_mode, "input_files": input_files}
          if gen_n:
              try:
                  inputs["n"] = int(gen_n)
              except ValueError:
                  inputs["n"] = gen_n
          if gen_k:
              try:
                  inputs["k"] = int(gen_k)
              except ValueError:
                  inputs["k"] = gen_k
          if gen_density:
              try:
                  inputs["density"] = float(gen_density)
              except ValueError:
                  inputs["density"] = gen_density
          if seed_used:
              try:
                  inputs["seed"] = int(seed_used)
              except ValueError:
                  inputs["seed"] = seed_used
          if inputs:
              data["inputs"] = inputs
          iterations = os.environ.get("ITERATIONS", "").strip()
          if iterations:
              try:
                  data["iterations"] = int(iterations)
              except ValueError:
                  pass
          warmup = os.environ.get("WARMUP", "").strip()
          if warmup:
              try:
                  data["warmup"] = int(warmup)
              except ValueError:
                  pass
          duration_ms = os.environ.get("RUN_DURATION_MS", "").strip()
          if duration_ms:
              try:
                  data["run_duration_ms"] = float(duration_ms)
              except ValueError:
                  pass
          timings_ms = {}
          if algorithm == "dijkstra":
              baseline = os.environ.get("DIJKSTRA_BASELINE_MS", "")
              llm = os.environ.get("DIJKSTRA_LLM_MS", "")
              if baseline:
                  timings_ms["baseline"] = float(baseline)
              if llm:
                  timings_ms["llm"] = float(llm)
          elif algorithm == "glasgow":
              first = os.environ.get("GLASGOW_FIRST_MS", "")
              all_ms = os.environ.get("GLASGOW_ALL_MS", "")
              if first:
                  timings_ms["first"] = float(first)
              if all_ms:
                  timings_ms["all"] = float(all_ms)
              gemini_first = os.environ.get("GLASGOW_GEMINI_FIRST_MS", "")
              gemini_all = os.environ.get("GLASGOW_GEMINI_ALL_MS", "")
              chatgpt_first = os.environ.get("GLASGOW_CHATGPT_FIRST_MS", "")
              chatgpt_all = os.environ.get("GLASGOW_CHATGPT_ALL_MS", "")
              if gemini_first:
                  timings_ms["gemini_first"] = float(gemini_first)
              if gemini_all:
                  timings_ms["gemini_all"] = float(gemini_all)
              if chatgpt_first:
                  timings_ms["chatgpt_first"] = float(chatgpt_first)
              if chatgpt_all:
                  timings_ms["chatgpt_all"] = float(chatgpt_all)
          elif algorithm == "vf3":
              def maybe_add(name: str, key: str) -> None:
                  value = os.environ.get(key, "")
                  if value:
                      timings_ms[name] = float(value)

              maybe_add("baseline_first", "VF3_BASE_FIRST_MS")
              maybe_add("baseline_all", "VF3_BASE_ALL_MS")
              maybe_add("gemini_first", "VF3_GEMINI_FIRST_MS")
              maybe_add("gemini_all", "VF3_GEMINI_ALL_MS")
              maybe_add("chatgpt_first", "VF3_CHATGPT_FIRST_MS")
              maybe_add("chatgpt_all", "VF3_CHATGPT_ALL_MS")
          if timings_ms:
              data["timings_ms"] = timings_ms

          timings_ms_stdev = {}
          if algorithm == "dijkstra":
              baseline = os.environ.get("DIJKSTRA_BASELINE_MS_STDEV", "")
              llm = os.environ.get("DIJKSTRA_LLM_MS_STDEV", "")
              if baseline:
                  timings_ms_stdev["baseline"] = float(baseline)
              if llm:
                  timings_ms_stdev["llm"] = float(llm)
          elif algorithm == "glasgow":
              first = os.environ.get("GLASGOW_FIRST_MS_STDEV", "")
              all_ms = os.environ.get("GLASGOW_ALL_MS_STDEV", "")
              if first:
                  timings_ms_stdev["first"] = float(first)
              if all_ms:
                  timings_ms_stdev["all"] = float(all_ms)
              gemini_first = os.environ.get("GLASGOW_GEMINI_FIRST_MS_STDEV", "")
              gemini_all = os.environ.get("GLASGOW_GEMINI_ALL_MS_STDEV", "")
              chatgpt_first = os.environ.get("GLASGOW_CHATGPT_FIRST_MS_STDEV", "")
              chatgpt_all = os.environ.get("GLASGOW_CHATGPT_ALL_MS_STDEV", "")
              if gemini_first:
                  timings_ms_stdev["gemini_first"] = float(gemini_first)
              if gemini_all:
                  timings_ms_stdev["gemini_all"] = float(gemini_all)
              if chatgpt_first:
                  timings_ms_stdev["chatgpt_first"] = float(chatgpt_first)
              if chatgpt_all:
                  timings_ms_stdev["chatgpt_all"] = float(chatgpt_all)
          elif algorithm == "vf3":
              def maybe_add_stdev(name: str, key: str) -> None:
                  value = os.environ.get(key, "")
                  if value:
                      timings_ms_stdev[name] = float(value)

              maybe_add_stdev("baseline_first", "VF3_BASE_FIRST_MS_STDEV")
              maybe_add_stdev("baseline_all", "VF3_BASE_ALL_MS_STDEV")
              maybe_add_stdev("gemini_first", "VF3_GEMINI_FIRST_MS_STDEV")
              maybe_add_stdev("gemini_all", "VF3_GEMINI_ALL_MS_STDEV")
              maybe_add_stdev("chatgpt_first", "VF3_CHATGPT_FIRST_MS_STDEV")
              maybe_add_stdev("chatgpt_all", "VF3_CHATGPT_ALL_MS_STDEV")
          if timings_ms_stdev:
              data["timings_ms_stdev"] = timings_ms_stdev

          memory_kb = {}
          if algorithm == "dijkstra":
              baseline = os.environ.get("DIJKSTRA_BASELINE_RSS_KB", "")
              llm = os.environ.get("DIJKSTRA_LLM_RSS_KB", "")
              if baseline:
                  try:
                      memory_kb["baseline"] = int(baseline)
                  except ValueError:
                      pass
              if llm:
                  try:
                      memory_kb["llm"] = int(llm)
                  except ValueError:
                      pass
          elif algorithm == "glasgow":
              first = os.environ.get("GLASGOW_FIRST_RSS_KB", "")
              all_kb = os.environ.get("GLASGOW_ALL_RSS_KB", "")
              if first:
                  try:
                      memory_kb["first"] = int(first)
                  except ValueError:
                      pass
              if all_kb:
                  try:
                      memory_kb["all"] = int(all_kb)
                  except ValueError:
                      pass
              gemini_first = os.environ.get("GLASGOW_GEMINI_FIRST_RSS_KB", "")
              gemini_all = os.environ.get("GLASGOW_GEMINI_ALL_RSS_KB", "")
              chatgpt_first = os.environ.get("GLASGOW_CHATGPT_FIRST_RSS_KB", "")
              chatgpt_all = os.environ.get("GLASGOW_CHATGPT_ALL_RSS_KB", "")
              for key, value in (
                  ("gemini_first", gemini_first),
                  ("gemini_all", gemini_all),
                  ("chatgpt_first", chatgpt_first),
                  ("chatgpt_all", chatgpt_all),
              ):
                  if value:
                      try:
                          memory_kb[key] = int(value)
                      except ValueError:
                          pass
          elif algorithm == "vf3":
              def maybe_add_int(name: str, key: str) -> None:
                  value = os.environ.get(key, "")
                  if not value:
                      return
                  try:
                      memory_kb[name] = int(value)
                  except ValueError:
                      return

              maybe_add_int("baseline_first", "VF3_BASE_FIRST_RSS_KB")
              maybe_add_int("baseline_all", "VF3_BASE_ALL_RSS_KB")
              maybe_add_int("gemini_first", "VF3_GEMINI_FIRST_RSS_KB")
              maybe_add_int("gemini_all", "VF3_GEMINI_ALL_RSS_KB")
              maybe_add_int("chatgpt_first", "VF3_CHATGPT_FIRST_RSS_KB")
              maybe_add_int("chatgpt_all", "VF3_CHATGPT_ALL_RSS_KB")

          if memory_kb:
              data["memory_kb"] = memory_kb

          memory_kb_stdev = {}
          if algorithm == "dijkstra":
              baseline = os.environ.get("DIJKSTRA_BASELINE_RSS_KB_STDEV", "")
              llm = os.environ.get("DIJKSTRA_LLM_RSS_KB_STDEV", "")
              if baseline:
                  try:
                      memory_kb_stdev["baseline"] = int(baseline)
                  except ValueError:
                      pass
              if llm:
                  try:
                      memory_kb_stdev["llm"] = int(llm)
                  except ValueError:
                      pass
          elif algorithm == "glasgow":
              first = os.environ.get("GLASGOW_FIRST_RSS_KB_STDEV", "")
              all_kb = os.environ.get("GLASGOW_ALL_RSS_KB_STDEV", "")
              if first:
                  try:
                      memory_kb_stdev["first"] = int(first)
                  except ValueError:
                      pass
              if all_kb:
                  try:
                      memory_kb_stdev["all"] = int(all_kb)
                  except ValueError:
                      pass
              gemini_first = os.environ.get("GLASGOW_GEMINI_FIRST_RSS_KB_STDEV", "")
              gemini_all = os.environ.get("GLASGOW_GEMINI_ALL_RSS_KB_STDEV", "")
              chatgpt_first = os.environ.get("GLASGOW_CHATGPT_FIRST_RSS_KB_STDEV", "")
              chatgpt_all = os.environ.get("GLASGOW_CHATGPT_ALL_RSS_KB_STDEV", "")
              for key, value in (
                  ("gemini_first", gemini_first),
                  ("gemini_all", gemini_all),
                  ("chatgpt_first", chatgpt_first),
                  ("chatgpt_all", chatgpt_all),
              ):
                  if value:
                      try:
                          memory_kb_stdev[key] = int(value)
                      except ValueError:
                          pass
          elif algorithm == "vf3":
              def maybe_add_int_stdev(name: str, key: str) -> None:
                  value = os.environ.get(key, "")
                  if not value:
                      return
                  try:
                      memory_kb_stdev[name] = int(value)
                  except ValueError:
                      return

              maybe_add_int_stdev("baseline_first", "VF3_BASE_FIRST_RSS_KB_STDEV")
              maybe_add_int_stdev("baseline_all", "VF3_BASE_ALL_RSS_KB_STDEV")
              maybe_add_int_stdev("gemini_first", "VF3_GEMINI_FIRST_RSS_KB_STDEV")
              maybe_add_int_stdev("gemini_all", "VF3_GEMINI_ALL_RSS_KB_STDEV")
              maybe_add_int_stdev("chatgpt_first", "VF3_CHATGPT_FIRST_RSS_KB_STDEV")
              maybe_add_int_stdev("chatgpt_all", "VF3_CHATGPT_ALL_RSS_KB_STDEV")

          if memory_kb_stdev:
              data["memory_kb_stdev"] = memory_kb_stdev

          def maybe_int_env(key: str):
              value = os.environ.get(key, "").strip()
              if not value:
                  return None
              try:
                  return int(value)
              except ValueError:
                  return None

          if algorithm == "glasgow":
              baseline_success = maybe_int_env("GLASGOW_BASELINE_SUCCESS")
              baseline_failed = maybe_int_env("GLASGOW_BASELINE_FAILED")
              chat_match = maybe_int_env("GLASGOW_CHATGPT_MATCH")
              chat_total = maybe_int_env("GLASGOW_CHATGPT_TOTAL")
              chat_mismatch = maybe_int_env("GLASGOW_CHATGPT_MISMATCH")
              gem_match = maybe_int_env("GLASGOW_GEMINI_MATCH")
              gem_total = maybe_int_env("GLASGOW_GEMINI_TOTAL")
              gem_mismatch = maybe_int_env("GLASGOW_GEMINI_MISMATCH")
              if any(
                  v is not None
                  for v in (
                      baseline_success,
                      baseline_failed,
                      chat_match,
                      chat_total,
                      chat_mismatch,
                      gem_match,
                      gem_total,
                      gem_mismatch,
                  )
              ):
                  data["match_counts"] = {
                      "baseline": {
                          "success": baseline_success,
                          "failed": baseline_failed,
                      },
                      "chatgpt": {
                          "matches": chat_match,
                          "total": chat_total,
                          "mismatches": chat_mismatch,
                      },
                      "gemini": {
                          "matches": gem_match,
                          "total": gem_total,
                          "mismatches": gem_mismatch,
                      },
                  }

          if algorithm == "vf3":
              baseline_success = maybe_int_env("VF3_BASELINE_SUCCESS")
              baseline_failed = maybe_int_env("VF3_BASELINE_FAILED")
              chat_match = maybe_int_env("VF3_CHATGPT_MATCH")
              chat_total = maybe_int_env("VF3_CHATGPT_TOTAL")
              chat_mismatch = maybe_int_env("VF3_CHATGPT_MISMATCH")
              gem_match = maybe_int_env("VF3_GEMINI_MATCH")
              gem_total = maybe_int_env("VF3_GEMINI_TOTAL")
              gem_mismatch = maybe_int_env("VF3_GEMINI_MISMATCH")
              if any(
                  v is not None
                  for v in (
                      baseline_success,
                      baseline_failed,
                      chat_match,
                      chat_total,
                      chat_mismatch,
                      gem_match,
                      gem_total,
                      gem_mismatch,
                  )
              ):
                  data["match_counts"] = {
                      "baseline": {
                          "success": baseline_success,
                          "failed": baseline_failed,
                      },
                      "chatgpt": {
                          "matches": chat_match,
                          "total": chat_total,
                          "mismatches": chat_mismatch,
                      },
                      "gemini": {
                          "matches": gem_match,
                          "total": gem_total,
                          "mismatches": gem_mismatch,
                      },
                  }
          Path("outputs/result.json").write_text(
              json.dumps(data, indent=2) + "\n", encoding="utf-8"
          )
          PY

      - name: Upload generated graphs
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: generated-graphs-${{ steps.run.outputs.REQUEST_ID || github.run_id }}
          path: outputs/generated
          if-no-files-found: ignore
          retention-days: 30

      - name: Upload results artifact
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: algorithm-result
          path: outputs/result.json
          if-no-files-found: error
          retention-days: 14
