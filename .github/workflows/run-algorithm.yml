name: Run Algorithm
run-name: Run Algorithm (${{ github.event.inputs.request_id || github.event.client_payload.request_id || github.run_id }})

on:
  workflow_dispatch:
    inputs:
      algorithm:
        description: 'Algorithm to run'
        required: true
        type: choice
        options:
          - dijkstra
          - glasgow
          - vf3
      iterations:
        description: 'Number of benchmark iterations'
        required: false
        type: string
        default: '1'
      warmup:
        description: 'Number of warmup runs (per test)'
        required: false
        type: string
        default: '1'
      input_mode:
        description: 'Input mode (premade or generate)'
        required: false
        type: choice
        options:
          - premade
          - generate
        default: premade
      n:
        description: 'Generated graph node count (N)'
        required: false
        type: string
        default: ''
      k:
        description: 'Generated pattern node count (k)'
        required: false
        type: string
        default: ''
      density:
        description: 'Generated graph density (0-1)'
        required: false
        type: string
        default: '0.05'
      input_files:
        description: 'Comma-separated input file paths'
        required: false
        type: string
        default: ''
      request_id:
        description: 'Client request identifier'
        required: false
        type: string
  repository_dispatch:
    types:
      - run-algorithm

jobs:
  run-algorithm:
    runs-on: ubuntu-latest
    env:
      ALGORITHM_INPUT: ${{ github.event.inputs.algorithm || github.event.client_payload.algorithm }}
      ITERATIONS_INPUT: ${{ github.event.inputs.iterations || github.event.client_payload.iterations }}
      WARMUP_INPUT: ${{ github.event.inputs.warmup || github.event.client_payload.warmup }}
      INPUT_MODE_INPUT: ${{ github.event.inputs.input_mode || github.event.client_payload.input_mode }}
      GENERATOR_N_INPUT: ${{ github.event.inputs.n || github.event.client_payload.n }}
      GENERATOR_K_INPUT: ${{ github.event.inputs.k || github.event.client_payload.k }}
      GENERATOR_DENSITY_INPUT: ${{ github.event.inputs.density || github.event.client_payload.density }}
      INPUT_FILES_INPUT: ${{ github.event.inputs.input_files || github.event.client_payload.input_files }}
      REQUEST_ID_INPUT: ${{ github.event.inputs.request_id || github.event.client_payload.request_id }}

    permissions:
      contents: write
      actions: read
      checks: write

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Download prebuilt binaries
        id: binaries
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          BRANCH: ${{ github.ref_name }}
          REPO: ${{ github.repository }}
        run: |
          mkdir -p outputs
          : > outputs/binaries_download_error.txt
          set +e
          output="$(python - <<'PY'
          import json
          import os
          import stat
          import subprocess
          import urllib.parse
          import urllib.request
          import zipfile
          from pathlib import Path

          repo = os.environ.get("REPO")
          branch = os.environ.get("BRANCH") or "main"
          token = os.environ.get("GITHUB_TOKEN")
          workflow_file = "build-binaries.yml"
          artifact_name = "algorithm-binaries-linux"

          if not repo:
              raise SystemExit("REPO env var is missing")
          if not token:
              raise SystemExit("GITHUB_TOKEN env var is missing")

          api_base = f"https://api.github.com/repos/{repo}"
          headers = {
              "Accept": "application/vnd.github+json",
              "Authorization": f"Bearer {token}",
              "X-GitHub-Api-Version": "2022-11-28",
              "User-Agent": "capstone-download-binaries",
          }


          def api_get(path: str):
              url = api_base + path
              req = urllib.request.Request(url, headers=headers)
              with urllib.request.urlopen(req) as resp:
                  return json.load(resp)


          query = urllib.parse.urlencode({"branch": branch, "status": "success", "per_page": 1})
          runs = api_get(f"/actions/workflows/{workflow_file}/runs?{query}")
          workflow_runs = runs.get("workflow_runs") or []
          if not workflow_runs:
              raise SystemExit(
                  f"No successful '{workflow_file}' runs found for branch '{branch}'. "
                  "Run the 'Build Binaries' workflow first."
              )

          run_id = workflow_runs[0].get("id")
          if not run_id:
              raise SystemExit("Could not read run_id from workflow_runs response.")

          artifacts = api_get(f"/actions/runs/{run_id}/artifacts")
          items = artifacts.get("artifacts") or []
          artifact = next(
              (a for a in items if a.get("name") == artifact_name and not a.get("expired")), None
          )
          if not artifact:
              available = ", ".join(sorted({a.get("name", "") for a in items if a.get("name")}))
              raise SystemExit(
                  f"Artifact '{artifact_name}' not found on run {run_id}. "
                  f"Available artifacts: {available or '(none)'}"
              )

          artifact_id = artifact.get("id")
          if not artifact_id:
              raise SystemExit("Could not read artifact id.")

          zip_path = Path("binaries.zip")
          download_url = f"{api_base}/actions/artifacts/{artifact_id}/zip"
          subprocess.run(
              [
                  "curl",
                  "-fsSL",
                  "-o",
                  str(zip_path),
                  "-H",
                  f"Authorization: Bearer {token}",
                  "-H",
                  "Accept: application/vnd.github+json",
                  download_url,
              ],
              check=True,
          )

          with zipfile.ZipFile(zip_path, "r") as zf:
              zf.extractall(".")

          expected = [
              "baselines/dijkstra",
              "src/dijkstra_llm",
              "src/vf3",
              "src/chatvf3",
              "baselines/vf3lib/bin/vf3",
              "baselines/glasgow-subgraph-solver/build/glasgow_subgraph_solver",
          ]

          missing = []
          for rel in expected:
              p = Path(rel)
              if not p.exists():
                  missing.append(rel)
                  continue
              mode = p.stat().st_mode
              p.chmod(mode | stat.S_IXUSR | stat.S_IXGRP | stat.S_IXOTH)

          if missing:
              raise SystemExit(
                  f"Missing expected binaries after extraction: {', '.join(missing)}"
              )

          print(f"Downloaded artifacts from run {run_id} (artifact_id={artifact_id}).")
          PY
          )"
          status=$?
          set -e
          if [ $status -eq 0 ]; then
            echo "READY=1" >> "$GITHUB_OUTPUT"
          else
            echo "READY=0" >> "$GITHUB_OUTPUT"
            echo "$output" > outputs/binaries_download_error.txt
            echo "$output"
          fi
          exit 0

      - name: Run algorithm
        id: run
        env:
          BINARIES_READY: ${{ steps.binaries.outputs.READY }}
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          set -uo pipefail
          ALGORITHM="${ALGORITHM_INPUT:-}"
          ITERATIONS_RAW="${ITERATIONS_INPUT:-1}"
          WARMUP_RAW="${WARMUP_INPUT:-1}"
          INPUT_MODE="${INPUT_MODE_INPUT:-premade}"
          GENERATOR_N="${GENERATOR_N_INPUT:-}"
          GENERATOR_K="${GENERATOR_K_INPUT:-}"
          GENERATOR_DENSITY="${GENERATOR_DENSITY_INPUT:-0.05}"
          INPUT_FILES="${INPUT_FILES_INPUT:-}"
          REQUEST_ID="${REQUEST_ID_INPUT:-}"

          mkdir -p outputs
          : > outputs/result.txt
          RUN_STARTED_NS="$(date +%s%N)"

          finish_run() {
            local end_ns duration_ms
            end_ns="$(date +%s%N)"
            duration_ms="$(python -c "import sys; start=int(sys.argv[1]); end=int(sys.argv[2]); print(f'{(end-start)/1_000_000:.3f}')" "$RUN_STARTED_NS" "$end_ns")"
            echo "RUN_DURATION_MS=$duration_ms" >> "$GITHUB_OUTPUT"
          }

          if [ "${BINARIES_READY:-}" != "1" ]; then
            echo "Failed to download prebuilt binaries." >> outputs/result.txt
            if [ -s outputs/binaries_download_error.txt ]; then
              cat outputs/binaries_download_error.txt >> outputs/result.txt
            fi
            finish_run
            echo "EXIT_CODE=1" >> "$GITHUB_OUTPUT"
            echo "REQUEST_ID=${REQUEST_ID}" >> "$GITHUB_OUTPUT"
            exit 0
          fi

          if [ "$INPUT_MODE" = "generate" ]; then
            mkdir -p outputs/generated
            GEN_OUTPUT="$(python utilities/generate_graphs.py \
              --algorithm "$ALGORITHM" \
              --n "$GENERATOR_N" \
              --k "$GENERATOR_K" \
              --density "$GENERATOR_DENSITY" \
              --out-dir "outputs/generated" 2>&1)"
            gen_status=$?
            GENERATED_FILES="$(echo "$GEN_OUTPUT" | tail -n 1 | tr -d '\r')"
            if [ $gen_status -ne 0 ] || [ -z "$GENERATED_FILES" ]; then
              echo "Graph generation failed." >> outputs/result.txt
              if [ -n "$GEN_OUTPUT" ]; then
                echo "$GEN_OUTPUT" >> outputs/result.txt
              fi
              finish_run
              echo "EXIT_CODE=1" >> "$GITHUB_OUTPUT"
              echo "REQUEST_ID=${REQUEST_ID}" >> "$GITHUB_OUTPUT"
              exit 0
            fi
            INPUT_FILES="$GENERATED_FILES"
          fi

          # Parse input files
          IFS=',' read -ra FILES <<< "$INPUT_FILES"

          if [ "$ALGORITHM" = "dijkstra" ] && [ ${#FILES[@]} -lt 1 ]; then
            echo "No input file provided for Dijkstra." >> outputs/result.txt
            finish_run
            echo "EXIT_CODE=1" >> "$GITHUB_OUTPUT"
            echo "REQUEST_ID=${REQUEST_ID}" >> "$GITHUB_OUTPUT"
            exit 0
          fi
          if [ "$ALGORITHM" != "dijkstra" ] && [ ${#FILES[@]} -lt 2 ]; then
            echo "Pattern/target files are required for $ALGORITHM." >> outputs/result.txt
            finish_run
            echo "EXIT_CODE=1" >> "$GITHUB_OUTPUT"
            echo "REQUEST_ID=${REQUEST_ID}" >> "$GITHUB_OUTPUT"
            exit 0
          fi

          # Normalize graph inputs so the smaller graph is always the pattern/subgraph.
          # (Order of clicks in the UI should not matter.)
          if [ "$ALGORITHM" = "glasgow" ] || [ "$ALGORITHM" = "vf3" ]; then
            graph_nodes() {
              python - <<'PY' "$1" 2>/dev/null || true
          import re
          import sys

          path = sys.argv[1]
          try:
              with open(path, "r", encoding="utf-8", errors="ignore") as fh:
                  for line in fh:
                      s = line.strip()
                      if not s or s.startswith("#"):
                          continue
                      m = re.match(r"^(-?\\d+)", s)
                      if m:
                          print(int(m.group(1)))
                          raise SystemExit(0)
          except OSError:
              pass
          print("")
          PY
            }

            file0="${FILES[0]}"
            file1="${FILES[1]}"
            nodes0="$(graph_nodes "$file0")"
            nodes1="$(graph_nodes "$file1")"
            size0="$(stat -c%s "$file0" 2>/dev/null || echo 0)"
            size1="$(stat -c%s "$file1" 2>/dev/null || echo 0)"

            swap=0
            if [[ "$nodes0" =~ ^[0-9]+$ ]] && [[ "$nodes1" =~ ^[0-9]+$ ]]; then
              if [ "$nodes0" -gt "$nodes1" ]; then
                swap=1
              elif [ "$nodes0" -eq "$nodes1" ] && [ "$size0" -gt "$size1" ]; then
                swap=1
              fi
            else
              if [ "$size0" -gt "$size1" ]; then
                swap=1
              fi
            fi

            if [ "$swap" -eq 1 ]; then
              FILES[0]="$file1"
              FILES[1]="$file0"
              echo "Normalized inputs (smaller graph used as pattern/subgraph)." >> outputs/result.txt
            fi
          fi

          ITERATIONS="1"
          if [[ "$ITERATIONS_RAW" =~ ^[0-9]+$ ]] && [ "$ITERATIONS_RAW" -ge 1 ]; then
            ITERATIONS="$ITERATIONS_RAW"
          fi

          WARMUP="0"
          if [[ "${WARMUP_RAW}" =~ ^[0-9]+$ ]]; then
            WARMUP="${WARMUP_RAW}"
          fi
          if [ "$WARMUP" -gt 50 ]; then
            WARMUP="50"
          fi
          WARMUP_REQUESTED="$WARMUP"

          # Progress reporting via GitHub Checks API (used by the web UI progress bar).
          PROGRESS_ENABLED=0
          CHECK_RUN_ID=""
          CHECK_RUN_NAME="Capstone Benchmark Progress (${REQUEST_ID:-${GITHUB_RUN_ID}})"
          PROGRESS_STAGE="setup"
          PROGRESS_SETUP_TOTAL=0
          PROGRESS_SETUP_DONE=0
          PROGRESS_TOTAL_UNITS=0
          PROGRESS_TOTAL_TICKS=0
          PROGRESS_DONE_TICKS=0
          PROGRESS_PHASE=""
          PROGRESS_LAST_UPDATE_EPOCH=0
          PROGRESS_LAST_REPORTED_SETUP=-1
          PROGRESS_LAST_REPORTED_TICKS=-1

          # Progress semantics: count "per program per iteration".
          # For Glasgow and VF3, both "first" and "all" runs are counted together as 1 unit.
          UNITS_PER_ITER=0
          TICKS_PER_ITER=0
          TICKS_PER_UNIT=1
          case "$ALGORITHM" in
            dijkstra)
              UNITS_PER_ITER=2   # baseline + llm
              TICKS_PER_ITER=2   # both are directly ticked
              ;;
            glasgow)
              UNITS_PER_ITER=3   # baseline + gemini + chatgpt
              TICKS_PER_ITER=6   # each has first + all (each ticks)
              ;;
            vf3)
              UNITS_PER_ITER=3   # baseline + gemini + chatgpt
              TICKS_PER_ITER=6   # each has first + all (each ticks)
              ;;
            *)
              UNITS_PER_ITER=0
              TICKS_PER_ITER=0
              ;;
          esac
          if [ "$UNITS_PER_ITER" -gt 0 ] && [ "$TICKS_PER_ITER" -gt 0 ]; then
            TICKS_PER_UNIT=$((TICKS_PER_ITER / UNITS_PER_ITER))
          fi
          PROGRESS_TOTAL_UNITS=$((ITERATIONS * UNITS_PER_ITER))
          PROGRESS_TOTAL_TICKS=$((ITERATIONS * TICKS_PER_ITER))
          PROGRESS_SETUP_TOTAL=$((WARMUP_REQUESTED * TICKS_PER_ITER))
          if [ "$PROGRESS_SETUP_TOTAL" -le 0 ]; then
            PROGRESS_SETUP_TOTAL=1
          fi

          progress_create_check_run() {
            if [ -z "${GITHUB_TOKEN:-}" ] || [ "$PROGRESS_TOTAL_UNITS" -le 0 ] || [ "$PROGRESS_TOTAL_TICKS" -le 0 ]; then
              return 0
            fi

            CHECK_RUN_ID="$(
              python - <<'PY' "$CHECK_RUN_NAME" "$REQUEST_ID" "$ALGORITHM" "$ITERATIONS" "$UNITS_PER_ITER" "$TICKS_PER_UNIT" "$PROGRESS_TOTAL_UNITS" "$PROGRESS_TOTAL_TICKS" "$PROGRESS_STAGE" "$PROGRESS_SETUP_DONE" "$PROGRESS_SETUP_TOTAL" || true
          import datetime
          import json
          import os
          import sys
          import urllib.request

          name = sys.argv[1]
          request_id = sys.argv[2]
          algorithm = sys.argv[3]
          iterations = int(sys.argv[4])
          units_per_iter = int(sys.argv[5])
          ticks_per_unit = int(sys.argv[6])
          total_units = int(sys.argv[7])
          total_ticks = int(sys.argv[8])
          stage = sys.argv[9] if len(sys.argv) > 9 else "tests"
          setup_done = int(sys.argv[10]) if len(sys.argv) > 10 else 0
          setup_total = int(sys.argv[11]) if len(sys.argv) > 11 else 0

          token = os.environ.get("GITHUB_TOKEN", "")
          repo = os.environ.get("GITHUB_REPOSITORY", "")
          sha = os.environ.get("GITHUB_SHA", "")
          if not token or not repo or not sha:
              print("")
              raise SystemExit(0)

          url = f"https://api.github.com/repos/{repo}/check-runs"
          headers = {
              "Accept": "application/vnd.github+json",
              "Authorization": f"Bearer {token}",
              "X-GitHub-Api-Version": "2022-11-28",
              "User-Agent": "capstone-algorithm-runner",
          }
          progress = {
              "request_id": request_id,
              "algorithm": algorithm,
              "iterations": iterations,
              "tests_per_iteration": units_per_iter,
              "ticks_per_unit": ticks_per_unit,
              "total_ticks": total_ticks,
              "completed": 0,
              "total": total_units,
              "percent": 0.0,
              "phase": "",
              "run_id": os.environ.get("GITHUB_RUN_ID", ""),
              "stage": stage,
              "setup_completed": setup_done,
              "setup_total": setup_total,
              "tests_completed": 0,
              "tests_total": total_units,
          }

          setup_percent = (setup_done / setup_total * 100.0) if setup_total else 0.0
          summary = f"Progress: 0/{total_units} (0.0%)"
          if stage == "setup":
              summary = f"Setup: {setup_done}/{setup_total} ({setup_percent:.1f}%)"
          payload = {
              "name": name,
              "head_sha": sha,
              "status": "in_progress",
              "started_at": datetime.datetime.now(datetime.timezone.utc).strftime("%Y-%m-%dT%H:%M:%SZ"),
              "output": {
                  "title": name,
                  "summary": summary,
                  "text": json.dumps(progress),
              },
          }
          req = urllib.request.Request(
              url,
              data=json.dumps(payload).encode("utf-8"),
              headers=headers,
              method="POST",
          )
          try:
              with urllib.request.urlopen(req, timeout=10) as resp:
                  data = json.load(resp)
              print(data.get("id", ""))
          except Exception:
              print("")
          PY
            )"

            if [[ "$CHECK_RUN_ID" =~ ^[0-9]+$ ]]; then
              PROGRESS_ENABLED=1
              PROGRESS_LAST_UPDATE_EPOCH=$(date +%s)
              PROGRESS_LAST_REPORTED_SETUP=0
              PROGRESS_LAST_REPORTED_TICKS=0
            fi
            return 0
          }

          progress_update_check_run() {
            local status="$1"
            local conclusion="${2:-}"
            if [ "${PROGRESS_ENABLED:-0}" != "1" ] || [ -z "${CHECK_RUN_ID:-}" ]; then
              return 0
            fi

            python - <<'PY' "$CHECK_RUN_ID" "$CHECK_RUN_NAME" "$REQUEST_ID" "$ALGORITHM" "$ITERATIONS" "$UNITS_PER_ITER" "$TICKS_PER_UNIT" "$PROGRESS_DONE_TICKS" "$PROGRESS_TOTAL_TICKS" "$PROGRESS_TOTAL_UNITS" "$PROGRESS_STAGE" "$PROGRESS_SETUP_DONE" "$PROGRESS_SETUP_TOTAL" "$PROGRESS_PHASE" "$status" "$conclusion" || true
          import datetime
          import json
          import os
          import sys
          import urllib.request

          check_id = sys.argv[1]
          name = sys.argv[2]
          request_id = sys.argv[3]
          algorithm = sys.argv[4]
          iterations = int(sys.argv[5])
          units_per_iter = int(sys.argv[6])
          ticks_per_unit = int(sys.argv[7])
          completed_ticks = int(sys.argv[8])
          total_ticks = int(sys.argv[9])
          total_units = int(sys.argv[10])
          stage = sys.argv[11] if len(sys.argv) > 11 else "tests"
          setup_done = int(sys.argv[12]) if len(sys.argv) > 12 else 0
          setup_total = int(sys.argv[13]) if len(sys.argv) > 13 else 0
          phase = sys.argv[14] if len(sys.argv) > 14 else ""
          status = sys.argv[15] if len(sys.argv) > 15 else "in_progress"
          conclusion = sys.argv[16] if len(sys.argv) > 16 else ""

          token = os.environ.get("GITHUB_TOKEN", "")
          repo = os.environ.get("GITHUB_REPOSITORY", "")
          if not token or not repo:
              raise SystemExit(0)

          completed_units = (completed_ticks / ticks_per_unit) if ticks_per_unit else 0.0
          percent = (completed_ticks / total_ticks * 100.0) if total_ticks else 0.0
          progress = {
              "request_id": request_id,
              "algorithm": algorithm,
              "iterations": iterations,
              "tests_per_iteration": units_per_iter,
              "ticks_per_unit": ticks_per_unit,
              "completed": round(completed_units, 3),
              "total": total_units,
              "total_ticks": total_ticks,
              "percent": round(percent, 3),
              "phase": phase,
              "run_id": os.environ.get("GITHUB_RUN_ID", ""),
              "stage": stage,
              "setup_completed": setup_done,
              "setup_total": setup_total,
              "tests_completed": round(completed_units, 3),
              "tests_total": total_units,
          }

          if ticks_per_unit > 1:
              completed_str = f"{completed_units:.1f}"
          else:
              completed_str = str(int(completed_units))

          setup_percent = (setup_done / setup_total * 100.0) if setup_total else 0.0
          if stage == "setup":
              summary = f"Setup: {setup_done}/{setup_total} ({setup_percent:.1f}%)"
          else:
              summary = f"Progress: {completed_str}/{total_units} ({percent:.1f}%)"
          if phase:
              summary += f"\\nPhase: {phase}"

          payload = {
              "status": status,
              "output": {
                  "title": name,
                  "summary": summary,
                  "text": json.dumps(progress),
              },
          }
          if status == "completed":
              payload["completed_at"] = datetime.datetime.now(datetime.timezone.utc).strftime(
                  "%Y-%m-%dT%H:%M:%SZ"
              )
              if conclusion:
                  payload["conclusion"] = conclusion

          url = f"https://api.github.com/repos/{repo}/check-runs/{check_id}"
          headers = {
              "Accept": "application/vnd.github+json",
              "Authorization": f"Bearer {token}",
              "X-GitHub-Api-Version": "2022-11-28",
              "User-Agent": "capstone-algorithm-runner",
          }
          req = urllib.request.Request(
              url,
              data=json.dumps(payload).encode("utf-8"),
              headers=headers,
              method="PATCH",
          )
          try:
              with urllib.request.urlopen(req, timeout=10):
                  pass
          except Exception:
              pass
          PY

            PROGRESS_LAST_UPDATE_EPOCH=$(date +%s)
            if [ "${PROGRESS_STAGE:-tests}" = "setup" ]; then
              PROGRESS_LAST_REPORTED_SETUP="$PROGRESS_SETUP_DONE"
            else
              PROGRESS_LAST_REPORTED_TICKS="$PROGRESS_DONE_TICKS"
            fi
            return 0
          }

          progress_maybe_update() {
            if [ "${PROGRESS_ENABLED:-0}" != "1" ]; then
              return 0
            fi

            local now_epoch
            now_epoch=$(date +%s)

            local stage current total last
            stage="${PROGRESS_STAGE:-tests}"
            if [ "$stage" = "setup" ]; then
              current="${PROGRESS_SETUP_DONE:-0}"
              total="${PROGRESS_SETUP_TOTAL:-0}"
              last="${PROGRESS_LAST_REPORTED_SETUP--1}"
            else
              current="${PROGRESS_DONE_TICKS:-0}"
              total="${PROGRESS_TOTAL_TICKS:-0}"
              last="${PROGRESS_LAST_REPORTED_TICKS--1}"
            fi

            if [ "${total:-0}" -le 0 ]; then
              progress_update_check_run "in_progress"
              return 0
            fi

            if [ "$current" -ge "$total" ]; then
              progress_update_check_run "in_progress"
              return 0
            fi

            if [ "$current" -le 2 ]; then
              progress_update_check_run "in_progress"
              return 0
            fi

            if [ "$current" -ne "$last" ] && [ $((now_epoch - PROGRESS_LAST_UPDATE_EPOCH)) -ge 5 ]; then
              progress_update_check_run "in_progress"
            fi
            return 0
          }

          progress_set_phase() {
            PROGRESS_PHASE="$1"
            progress_maybe_update
          }

          progress_tick() {
            PROGRESS_DONE_TICKS=$((PROGRESS_DONE_TICKS + 1))
            progress_maybe_update
          }

          progress_setup_tick() {
            PROGRESS_SETUP_DONE=$((PROGRESS_SETUP_DONE + 1))
            if [ "$PROGRESS_SETUP_DONE" -gt "$PROGRESS_SETUP_TOTAL" ]; then
              PROGRESS_SETUP_DONE="$PROGRESS_SETUP_TOTAL"
            fi
            progress_maybe_update
          }

          progress_finish() {
            if [ "${PROGRESS_ENABLED:-0}" != "1" ] || [ -z "${CHECK_RUN_ID:-}" ]; then
              return 0
            fi
            PROGRESS_DONE_TICKS="$PROGRESS_TOTAL_TICKS"
            local conclusion="success"
            if [ "${EXIT_CODE:-0}" != "0" ]; then
              conclusion="failure"
            fi
            progress_update_check_run "completed" "$conclusion"
            return 0
          }

          progress_create_check_run
          trap 'rc=$?; if [ -z "${EXIT_CODE:-}" ]; then EXIT_CODE=$rc; fi; progress_finish || true' EXIT

          run_with_timeout() {
            "$@"
          }

          run_capture() {
            local _out_var=$1
            local _dur_var=$2
            shift 2
            local tmp
            tmp=$(mktemp)
            local start_ns end_ns duration_ms
            start_ns=$(date +%s%N)
            set +e
            run_with_timeout "$@" >"$tmp" 2>&1
            local status=$?
            set -e
            end_ns=$(date +%s%N)
            duration_ms=$(python - <<'PY' "$start_ns" "$end_ns"
          import sys
          start=int(sys.argv[1]); end=int(sys.argv[2])
          print(f"{(end - start)/1_000_000:.3f}")
          PY
            )
            printf -v "$_out_var" "%s" "$(cat "$tmp")"
            printf -v "$_dur_var" "%s" "$duration_ms"
            rm -f "$tmp"
            return $status
          }

          warmup_only() {
            local label="$1"
            shift

            if [ "${WARMUP_REQUESTED:-0}" -le 0 ]; then
              return 0
            fi

          local out dur
          for ((i=1; i<=WARMUP_REQUESTED; i++)); do
            echo "[Warmup] ${label} (${i}/${WARMUP_REQUESTED})"
            if ! run_capture out dur "$@"; then
              echo "[Warmup] ${label} failed." >> outputs/result.txt
              return 1
            fi
            progress_setup_tick
            done
            return 0
          }

          bench_capture_n() {
            local _out_var=$1
            local _times_var=$2
            local _runs=$3
            shift 3

            local out dur
            local -a times
            local out_first=""

            # Warmup runs (not included in stats/progress).
            if [ "${WARMUP:-0}" -gt 0 ]; then
              for ((i=1; i<=WARMUP; i++)); do
                if ! run_capture out dur "$@"; then
                  printf -v "$_out_var" "%s" "$out"
                  return 1
                fi
              done
            fi

            for ((i=1; i<=_runs; i++)); do
              if ! run_capture out dur "$@"; then
                printf -v "$_out_var" "%s" "$out"
                return 1
              fi
              if [ $i -eq 1 ]; then
                out_first="$out"
              fi
              times+=("$dur")
              progress_tick
            done

            printf -v "$_out_var" "%s" "$out_first"
            printf -v "$_times_var" "%s" "${times[*]}"
            return 0
          }

          run_capture_rss() {
            local _out_var=$1
            local _dur_var=$2
            local _rss_var=$3
            shift 3
            local tmp rss_tmp
            tmp=$(mktemp)
            rss_tmp=$(mktemp)
            local start_ns end_ns duration_ms rss_kb
            start_ns=$(date +%s%N)
            set +e
            if [ -x /usr/bin/time ]; then
              /usr/bin/time -f "%M" -o "$rss_tmp" "$@" >"$tmp" 2>&1
            else
              run_with_timeout "$@" >"$tmp" 2>&1
            fi
            local status=$?
            set -e
            end_ns=$(date +%s%N)
            duration_ms=$(python - <<'PY' "$start_ns" "$end_ns"
          import sys
          start=int(sys.argv[1]); end=int(sys.argv[2])
          print(f"{(end - start)/1_000_000:.3f}")
          PY
            )
            rss_kb=""
            if [ -s "$rss_tmp" ]; then
              rss_kb="$(head -n1 "$rss_tmp" | tr -d '\r' | awk '{print $1}')"
            fi
            printf -v "$_out_var" "%s" "$(cat "$tmp")"
            printf -v "$_dur_var" "%s" "$duration_ms"
            printf -v "$_rss_var" "%s" "$rss_kb"
            rm -f "$tmp" "$rss_tmp"
            return $status
          }

          bench_capture_rss_n() {
            local _out_var=$1
            local _times_var=$2
            local _rss_var=$3
            local _runs=$4
            shift 4

            local out dur rss
            local -a times rsses
            local out_first=""

            # Warmup runs (not included in stats/progress).
            if [ "${WARMUP:-0}" -gt 0 ]; then
              for ((i=1; i<=WARMUP; i++)); do
                if ! run_capture_rss out dur rss "$@"; then
                  printf -v "$_out_var" "%s" "$out"
                  return 1
                fi
              done
            fi

            for ((i=1; i<=_runs; i++)); do
              if ! run_capture_rss out dur rss "$@"; then
                printf -v "$_out_var" "%s" "$out"
                return 1
              fi
              if [ $i -eq 1 ]; then
                out_first="$out"
              fi
              times+=("$dur")
              rsses+=("$rss")
              progress_tick
            done

            printf -v "$_out_var" "%s" "$out_first"
            printf -v "$_times_var" "%s" "${times[*]}"
            printf -v "$_rss_var" "%s" "${rsses[*]}"
            return 0
          }

          calc_stats_ms() {
            python - <<'PY' "$@"
          import statistics
          import sys

          vals = []
          for x in sys.argv[1:]:
              try:
                  vals.append(float(x))
              except ValueError:
                  pass

          if not vals:
              print("")
              raise SystemExit(0)

          n = len(vals)
          mean = statistics.fmean(vals)
          median = statistics.median(vals)
          stdev = statistics.stdev(vals) if n > 1 else 0.0
          print(
              f"{median:.3f} {mean:.3f} {stdev:.3f} {min(vals):.3f} {max(vals):.3f} {n}"
          )
          PY
          }

          calc_stats_kb() {
            python - <<'PY' "$@"
          import statistics
          import sys

          vals = []
          for x in sys.argv[1:]:
              try:
                  vals.append(int(x))
              except ValueError:
                  pass

          if not vals:
              print("")
              raise SystemExit(0)

          n = len(vals)
          mean = statistics.fmean(vals)
          median = statistics.median_low(vals)
          stdev = statistics.stdev(vals) if n > 1 else 0.0
          print(
              f"{median} {int(round(mean))} {int(round(stdev))} {min(vals)} {max(vals)} {n}"
          )
          PY
          }

          print_stats_ms_first_all() {
            local prefix="$1"
            shift
            local indent
            indent="$(printf '%*s' ${#prefix} '')"
            printf "%s%-5s median=%10.3f mean=%10.3f stdev=%10.3f min=%10.3f max=%10.3f\n" \
              "$prefix" "first" "$1" "$2" "$3" "$4" "$5"
            printf "%s%-5s median=%10.3f mean=%10.3f stdev=%10.3f min=%10.3f max=%10.3f\n" \
              "$indent" "all" "$6" "$7" "$8" "$9" "${10}"
          }

          print_stats_kb_first_all() {
            local prefix="$1"
            shift
            local indent
            indent="$(printf '%*s' ${#prefix} '')"
            printf "%s%-5s median=%10d mean=%10d stdev=%10d min=%10d max=%10d\n" \
              "$prefix" "first" "$1" "$2" "$3" "$4" "$5"
            printf "%s%-5s median=%10d mean=%10d stdev=%10d min=%10d max=%10d\n" \
              "$indent" "all" "$6" "$7" "$8" "$9" "${10}"
          }

          EXIT_CODE=0

          case "$ALGORITHM" in
            dijkstra)
              dijkstra_baseline_out=""
              dijkstra_baseline_ms_runs=""
              dijkstra_baseline_rss_runs=""
              dijkstra_llm_out=""
              dijkstra_llm_ms_runs=""
              dijkstra_llm_rss_runs=""

              # Phase 1: setup + warmup (web UI fills the progress bar once here)
              PROGRESS_STAGE="setup"
              progress_set_phase "Setting up Testing Environment"
              if [ "${WARMUP_REQUESTED:-0}" -gt 0 ]; then
                if ! warmup_only "Dijkstra baseline" ./baselines/dijkstra "${FILES[0]}"; then
                  EXIT_CODE=1
                fi
                if ! warmup_only "Dijkstra llm" ./src/dijkstra_llm "${FILES[0]}"; then
                  EXIT_CODE=1
                fi
              else
                progress_setup_tick
              fi
              PROGRESS_SETUP_DONE="$PROGRESS_SETUP_TOTAL"
              progress_update_check_run "in_progress" || true

              # Phase 2: measured iterations (web UI resets the bar and fills again here)
              PROGRESS_STAGE="tests"
              PROGRESS_PHASE=""
              PROGRESS_DONE_TICKS=0
              progress_update_check_run "in_progress" || true
              WARMUP=0

              progress_set_phase "Dijkstra baseline"
              if ! bench_capture_rss_n dijkstra_baseline_out dijkstra_baseline_ms_runs dijkstra_baseline_rss_runs "$ITERATIONS" ./baselines/dijkstra "${FILES[0]}"; then
                EXIT_CODE=1
                echo "[Dijkstra Baseline] failed to run." >> outputs/result.txt
              else
                read dijkstra_baseline_ms_median dijkstra_baseline_ms_mean dijkstra_baseline_ms_stdev dijkstra_baseline_ms_min dijkstra_baseline_ms_max dijkstra_baseline_ms_n <<< "$(calc_stats_ms $dijkstra_baseline_ms_runs)"
                dijkstra_baseline_ms="$dijkstra_baseline_ms_median"
                if [ -n "${dijkstra_baseline_rss_runs:-}" ]; then
                  read dijkstra_baseline_rss_median dijkstra_baseline_rss_mean dijkstra_baseline_rss_stdev dijkstra_baseline_rss_min dijkstra_baseline_rss_max dijkstra_baseline_rss_n <<< "$(calc_stats_kb $dijkstra_baseline_rss_runs)"
                  dijkstra_baseline_rss_kb="$dijkstra_baseline_rss_median"
                fi
                {
                  echo "[Dijkstra Baseline]"
                  echo "$dijkstra_baseline_out"
                  echo "Warmup: $WARMUP_REQUESTED"
                  echo "Iterations: $ITERATIONS"
                  if [ -n "${dijkstra_baseline_ms_median:-}" ]; then
                    echo "Runtime (ms): median=$dijkstra_baseline_ms_median mean=$dijkstra_baseline_ms_mean stdev=$dijkstra_baseline_ms_stdev min=$dijkstra_baseline_ms_min max=$dijkstra_baseline_ms_max"
                  fi
                  if [ -n "${dijkstra_baseline_rss_median:-}" ]; then
                    echo "Max RSS (kB): median=$dijkstra_baseline_rss_median mean=$dijkstra_baseline_rss_mean stdev=$dijkstra_baseline_rss_stdev min=$dijkstra_baseline_rss_min max=$dijkstra_baseline_rss_max"
                  fi
                  echo
                } >> outputs/result.txt
              fi
              progress_set_phase "Dijkstra llm"
              if ! bench_capture_rss_n dijkstra_llm_out dijkstra_llm_ms_runs dijkstra_llm_rss_runs "$ITERATIONS" ./src/dijkstra_llm "${FILES[0]}"; then
                EXIT_CODE=1
                echo "[Dijkstra LLM] failed to run." >> outputs/result.txt
              else
                read dijkstra_llm_ms_median dijkstra_llm_ms_mean dijkstra_llm_ms_stdev dijkstra_llm_ms_min dijkstra_llm_ms_max dijkstra_llm_ms_n <<< "$(calc_stats_ms $dijkstra_llm_ms_runs)"
                dijkstra_llm_ms="$dijkstra_llm_ms_median"
                if [ -n "${dijkstra_llm_rss_runs:-}" ]; then
                  read dijkstra_llm_rss_median dijkstra_llm_rss_mean dijkstra_llm_rss_stdev dijkstra_llm_rss_min dijkstra_llm_rss_max dijkstra_llm_rss_n <<< "$(calc_stats_kb $dijkstra_llm_rss_runs)"
                  dijkstra_llm_rss_kb="$dijkstra_llm_rss_median"
                fi
                {
                  echo "[Dijkstra LLM]"
                  echo "$dijkstra_llm_out"
                  echo "Warmup: $WARMUP_REQUESTED"
                  echo "Iterations: $ITERATIONS"
                  if [ -n "${dijkstra_llm_ms_median:-}" ]; then
                    echo "Runtime (ms): median=$dijkstra_llm_ms_median mean=$dijkstra_llm_ms_mean stdev=$dijkstra_llm_ms_stdev min=$dijkstra_llm_ms_min max=$dijkstra_llm_ms_max"
                  fi
                  if [ -n "${dijkstra_llm_rss_median:-}" ]; then
                    echo "Max RSS (kB): median=$dijkstra_llm_rss_median mean=$dijkstra_llm_rss_mean stdev=$dijkstra_llm_rss_stdev min=$dijkstra_llm_rss_min max=$dijkstra_llm_rss_max"
                  fi
                  echo
                } >> outputs/result.txt
              fi
              ;;
            glasgow)
              glasgow_first_out=""
              glasgow_first_ms_runs=""
              glasgow_first_rss_runs=""
              glasgow_all_out=""
              glasgow_all_ms_runs=""
              glasgow_all_rss_runs=""

              glasgow_gemini_first_out=""
              glasgow_gemini_first_ms_runs=""
              glasgow_gemini_first_rss_runs=""
              glasgow_gemini_all_out=""
              glasgow_gemini_all_ms_runs=""
              glasgow_gemini_all_rss_runs=""

              glasgow_chatgpt_first_out=""
              glasgow_chatgpt_first_ms_runs=""
              glasgow_chatgpt_first_rss_runs=""
              glasgow_chatgpt_all_out=""
              glasgow_chatgpt_all_ms_runs=""
              glasgow_chatgpt_all_rss_runs=""

              # Phase 1: setup + warmup (web UI fills the progress bar once here)
              PROGRESS_STAGE="setup"
              progress_set_phase "Setting up Testing Environment"
              if [ "${WARMUP_REQUESTED:-0}" -gt 0 ]; then
                if ! warmup_only "Glasgow first" ./baselines/glasgow-subgraph-solver/build/glasgow_subgraph_solver --format lad "${FILES[0]}" "${FILES[1]}"; then
                  EXIT_CODE=1
                fi
                if ! warmup_only "Glasgow all" ./baselines/glasgow-subgraph-solver/build/glasgow_subgraph_solver --count-solutions --format lad "${FILES[0]}" "${FILES[1]}"; then
                  EXIT_CODE=1
                fi
                if ! warmup_only "Glasgow Gemini first" ./src/vf3 --first-only "${FILES[0]}" "${FILES[1]}"; then
                  EXIT_CODE=1
                fi
                if ! warmup_only "Glasgow Gemini all" ./src/vf3 "${FILES[0]}" "${FILES[1]}"; then
                  EXIT_CODE=1
                fi
                if ! warmup_only "Glasgow ChatGPT first" ./src/chatvf3 --first-only "${FILES[0]}" "${FILES[1]}"; then
                  EXIT_CODE=1
                fi
                if ! warmup_only "Glasgow ChatGPT all" ./src/chatvf3 "${FILES[0]}" "${FILES[1]}"; then
                  EXIT_CODE=1
                fi
              else
                progress_setup_tick
              fi
              PROGRESS_SETUP_DONE="$PROGRESS_SETUP_TOTAL"
              progress_update_check_run "in_progress" || true

              # Phase 2: measured iterations (web UI resets the bar and fills again here)
              PROGRESS_STAGE="tests"
              PROGRESS_PHASE=""
              PROGRESS_DONE_TICKS=0
              progress_update_check_run "in_progress" || true
              WARMUP=0

              progress_set_phase "Glasgow baseline"
              if ! bench_capture_rss_n glasgow_first_out glasgow_first_ms_runs glasgow_first_rss_runs "$ITERATIONS" ./baselines/glasgow-subgraph-solver/build/glasgow_subgraph_solver --format lad "${FILES[0]}" "${FILES[1]}"; then
                EXIT_CODE=1
                echo "[Glasgow Subgraph Solver] first-solution run failed." >> outputs/result.txt
              fi
              progress_set_phase "Glasgow baseline"
              if ! bench_capture_rss_n glasgow_all_out glasgow_all_ms_runs glasgow_all_rss_runs "$ITERATIONS" ./baselines/glasgow-subgraph-solver/build/glasgow_subgraph_solver --count-solutions --format lad "${FILES[0]}" "${FILES[1]}"; then
                EXIT_CODE=1
                echo "[Glasgow Subgraph Solver] all-solutions run failed." >> outputs/result.txt
              fi

              progress_set_phase "Glasgow Gemini"
              if ! bench_capture_rss_n glasgow_gemini_first_out glasgow_gemini_first_ms_runs glasgow_gemini_first_rss_runs "$ITERATIONS" ./src/vf3 --first-only "${FILES[0]}" "${FILES[1]}"; then
                EXIT_CODE=1
                echo "[Glasgow Gemini] first-solution run failed." >> outputs/result.txt
              fi
              progress_set_phase "Glasgow Gemini"
              if ! bench_capture_rss_n glasgow_gemini_all_out glasgow_gemini_all_ms_runs glasgow_gemini_all_rss_runs "$ITERATIONS" ./src/vf3 "${FILES[0]}" "${FILES[1]}"; then
                EXIT_CODE=1
                echo "[Glasgow Gemini] all-solutions run failed." >> outputs/result.txt
              fi

              progress_set_phase "Glasgow ChatGPT"
              if ! bench_capture_rss_n glasgow_chatgpt_first_out glasgow_chatgpt_first_ms_runs glasgow_chatgpt_first_rss_runs "$ITERATIONS" ./src/chatvf3 --first-only "${FILES[0]}" "${FILES[1]}"; then
                EXIT_CODE=1
                echo "[Glasgow ChatGPT] first-solution run failed." >> outputs/result.txt
              fi
              progress_set_phase "Glasgow ChatGPT"
              if ! bench_capture_rss_n glasgow_chatgpt_all_out glasgow_chatgpt_all_ms_runs glasgow_chatgpt_all_rss_runs "$ITERATIONS" ./src/chatvf3 "${FILES[0]}" "${FILES[1]}"; then
                EXIT_CODE=1
                echo "[Glasgow ChatGPT] all-solutions run failed." >> outputs/result.txt
              fi

              if [ -n "${glasgow_first_ms_runs:-}" ]; then
                read glasgow_first_ms_median glasgow_first_ms_mean glasgow_first_ms_stdev glasgow_first_ms_min glasgow_first_ms_max glasgow_first_ms_n <<< "$(calc_stats_ms $glasgow_first_ms_runs)"
                glasgow_first_ms="$glasgow_first_ms_median"
              fi
              if [ -n "${glasgow_all_ms_runs:-}" ]; then
                read glasgow_all_ms_median glasgow_all_ms_mean glasgow_all_ms_stdev glasgow_all_ms_min glasgow_all_ms_max glasgow_all_ms_n <<< "$(calc_stats_ms $glasgow_all_ms_runs)"
                glasgow_all_ms="$glasgow_all_ms_median"
              fi
              if [ -n "${glasgow_first_rss_runs:-}" ]; then
                read glasgow_first_rss_median glasgow_first_rss_mean glasgow_first_rss_stdev glasgow_first_rss_min glasgow_first_rss_max glasgow_first_rss_n <<< "$(calc_stats_kb $glasgow_first_rss_runs)"
                glasgow_first_rss_kb="$glasgow_first_rss_median"
              fi
              if [ -n "${glasgow_all_rss_runs:-}" ]; then
                read glasgow_all_rss_median glasgow_all_rss_mean glasgow_all_rss_stdev glasgow_all_rss_min glasgow_all_rss_max glasgow_all_rss_n <<< "$(calc_stats_kb $glasgow_all_rss_runs)"
                glasgow_all_rss_kb="$glasgow_all_rss_median"
              fi
              if [ -n "${glasgow_all_out:-}" ]; then
                glasgow_result_line="$(echo "$glasgow_all_out" | tr -d '\r' | awk '/^[[:space:]]*solution_count[[:space:]]*=/ {line=$0} END {print line}')"
                if [ -z "${glasgow_result_line:-}" ]; then
                  glasgow_result_line="$(echo "$glasgow_all_out" | tr -d '\r' | head -n1)"
                fi
                {
                  echo "[Glasgow Subgraph Solver]"
                  echo "${glasgow_result_line:-(No output)}"
                  echo "Warmup: $WARMUP_REQUESTED"
                  echo "Iterations: $ITERATIONS"
                  if [ -n "${glasgow_first_ms_median:-}" ] && [ -n "${glasgow_all_ms_median:-}" ]; then
                    print_stats_ms_first_all "Runtime (ms): " \
                      "$glasgow_first_ms_median" "$glasgow_first_ms_mean" "$glasgow_first_ms_stdev" "$glasgow_first_ms_min" "$glasgow_first_ms_max" \
                      "$glasgow_all_ms_median" "$glasgow_all_ms_mean" "$glasgow_all_ms_stdev" "$glasgow_all_ms_min" "$glasgow_all_ms_max"
                  fi
                  if [ -n "${glasgow_first_rss_median:-}" ] && [ -n "${glasgow_all_rss_median:-}" ]; then
                    print_stats_kb_first_all "Max RSS (kB): " \
                      "$glasgow_first_rss_median" "$glasgow_first_rss_mean" "$glasgow_first_rss_stdev" "$glasgow_first_rss_min" "$glasgow_first_rss_max" \
                      "$glasgow_all_rss_median" "$glasgow_all_rss_mean" "$glasgow_all_rss_stdev" "$glasgow_all_rss_min" "$glasgow_all_rss_max"
                  fi
                  echo
                } >> outputs/result.txt
              fi

              if [ -n "${glasgow_gemini_first_ms_runs:-}" ]; then
                read glasgow_gemini_first_ms_median glasgow_gemini_first_ms_mean glasgow_gemini_first_ms_stdev glasgow_gemini_first_ms_min glasgow_gemini_first_ms_max glasgow_gemini_first_ms_n <<< "$(calc_stats_ms $glasgow_gemini_first_ms_runs)"
                glasgow_gemini_first_ms="$glasgow_gemini_first_ms_median"
              fi
              if [ -n "${glasgow_gemini_all_ms_runs:-}" ]; then
                read glasgow_gemini_all_ms_median glasgow_gemini_all_ms_mean glasgow_gemini_all_ms_stdev glasgow_gemini_all_ms_min glasgow_gemini_all_ms_max glasgow_gemini_all_ms_n <<< "$(calc_stats_ms $glasgow_gemini_all_ms_runs)"
                glasgow_gemini_all_ms="$glasgow_gemini_all_ms_median"
              fi
              if [ -n "${glasgow_gemini_first_rss_runs:-}" ]; then
                read glasgow_gemini_first_rss_median glasgow_gemini_first_rss_mean glasgow_gemini_first_rss_stdev glasgow_gemini_first_rss_min glasgow_gemini_first_rss_max glasgow_gemini_first_rss_n <<< "$(calc_stats_kb $glasgow_gemini_first_rss_runs)"
                glasgow_gemini_first_rss_kb="$glasgow_gemini_first_rss_median"
              fi
              if [ -n "${glasgow_gemini_all_rss_runs:-}" ]; then
                read glasgow_gemini_all_rss_median glasgow_gemini_all_rss_mean glasgow_gemini_all_rss_stdev glasgow_gemini_all_rss_min glasgow_gemini_all_rss_max glasgow_gemini_all_rss_n <<< "$(calc_stats_kb $glasgow_gemini_all_rss_runs)"
                glasgow_gemini_all_rss_kb="$glasgow_gemini_all_rss_median"
              fi
              if [ -n "${glasgow_gemini_all_out:-}" ]; then
                glasgow_gemini_result="$(echo "$glasgow_gemini_all_out" | tr -d '\r' | head -n1)"
                {
                  echo "[Glasgow Gemini]"
                  echo "${glasgow_gemini_result:-(No output)}"
                  echo "Warmup: $WARMUP_REQUESTED"
                  echo "Iterations: $ITERATIONS"
                  if [ -n "${glasgow_gemini_first_ms_median:-}" ] && [ -n "${glasgow_gemini_all_ms_median:-}" ]; then
                    print_stats_ms_first_all "Runtime (ms): " \
                      "$glasgow_gemini_first_ms_median" "$glasgow_gemini_first_ms_mean" "$glasgow_gemini_first_ms_stdev" "$glasgow_gemini_first_ms_min" "$glasgow_gemini_first_ms_max" \
                      "$glasgow_gemini_all_ms_median" "$glasgow_gemini_all_ms_mean" "$glasgow_gemini_all_ms_stdev" "$glasgow_gemini_all_ms_min" "$glasgow_gemini_all_ms_max"
                  fi
                  if [ -n "${glasgow_gemini_first_rss_median:-}" ] && [ -n "${glasgow_gemini_all_rss_median:-}" ]; then
                    print_stats_kb_first_all "Max RSS (kB): " \
                      "$glasgow_gemini_first_rss_median" "$glasgow_gemini_first_rss_mean" "$glasgow_gemini_first_rss_stdev" "$glasgow_gemini_first_rss_min" "$glasgow_gemini_first_rss_max" \
                      "$glasgow_gemini_all_rss_median" "$glasgow_gemini_all_rss_mean" "$glasgow_gemini_all_rss_stdev" "$glasgow_gemini_all_rss_min" "$glasgow_gemini_all_rss_max"
                  fi
                  echo
                } >> outputs/result.txt
              fi

              if [ -n "${glasgow_chatgpt_first_ms_runs:-}" ]; then
                read glasgow_chatgpt_first_ms_median glasgow_chatgpt_first_ms_mean glasgow_chatgpt_first_ms_stdev glasgow_chatgpt_first_ms_min glasgow_chatgpt_first_ms_max glasgow_chatgpt_first_ms_n <<< "$(calc_stats_ms $glasgow_chatgpt_first_ms_runs)"
                glasgow_chatgpt_first_ms="$glasgow_chatgpt_first_ms_median"
              fi
              if [ -n "${glasgow_chatgpt_all_ms_runs:-}" ]; then
                read glasgow_chatgpt_all_ms_median glasgow_chatgpt_all_ms_mean glasgow_chatgpt_all_ms_stdev glasgow_chatgpt_all_ms_min glasgow_chatgpt_all_ms_max glasgow_chatgpt_all_ms_n <<< "$(calc_stats_ms $glasgow_chatgpt_all_ms_runs)"
                glasgow_chatgpt_all_ms="$glasgow_chatgpt_all_ms_median"
              fi
              if [ -n "${glasgow_chatgpt_first_rss_runs:-}" ]; then
                read glasgow_chatgpt_first_rss_median glasgow_chatgpt_first_rss_mean glasgow_chatgpt_first_rss_stdev glasgow_chatgpt_first_rss_min glasgow_chatgpt_first_rss_max glasgow_chatgpt_first_rss_n <<< "$(calc_stats_kb $glasgow_chatgpt_first_rss_runs)"
                glasgow_chatgpt_first_rss_kb="$glasgow_chatgpt_first_rss_median"
              fi
              if [ -n "${glasgow_chatgpt_all_rss_runs:-}" ]; then
                read glasgow_chatgpt_all_rss_median glasgow_chatgpt_all_rss_mean glasgow_chatgpt_all_rss_stdev glasgow_chatgpt_all_rss_min glasgow_chatgpt_all_rss_max glasgow_chatgpt_all_rss_n <<< "$(calc_stats_kb $glasgow_chatgpt_all_rss_runs)"
                glasgow_chatgpt_all_rss_kb="$glasgow_chatgpt_all_rss_median"
              fi
              if [ -n "${glasgow_chatgpt_all_out:-}" ]; then
                glasgow_chatgpt_result="$(echo "$glasgow_chatgpt_all_out" | tr -d '\r' | head -n1)"
                {
                  echo "[Glasgow ChatGPT]"
                  echo "${glasgow_chatgpt_result:-(No output)}"
                  echo "Warmup: $WARMUP_REQUESTED"
                  echo "Iterations: $ITERATIONS"
                  if [ -n "${glasgow_chatgpt_first_ms_median:-}" ] && [ -n "${glasgow_chatgpt_all_ms_median:-}" ]; then
                    print_stats_ms_first_all "Runtime (ms): " \
                      "$glasgow_chatgpt_first_ms_median" "$glasgow_chatgpt_first_ms_mean" "$glasgow_chatgpt_first_ms_stdev" "$glasgow_chatgpt_first_ms_min" "$glasgow_chatgpt_first_ms_max" \
                      "$glasgow_chatgpt_all_ms_median" "$glasgow_chatgpt_all_ms_mean" "$glasgow_chatgpt_all_ms_stdev" "$glasgow_chatgpt_all_ms_min" "$glasgow_chatgpt_all_ms_max"
                  fi
                  if [ -n "${glasgow_chatgpt_first_rss_median:-}" ] && [ -n "${glasgow_chatgpt_all_rss_median:-}" ]; then
                    print_stats_kb_first_all "Max RSS (kB): " \
                      "$glasgow_chatgpt_first_rss_median" "$glasgow_chatgpt_first_rss_mean" "$glasgow_chatgpt_first_rss_stdev" "$glasgow_chatgpt_first_rss_min" "$glasgow_chatgpt_first_rss_max" \
                      "$glasgow_chatgpt_all_rss_median" "$glasgow_chatgpt_all_rss_mean" "$glasgow_chatgpt_all_rss_stdev" "$glasgow_chatgpt_all_rss_min" "$glasgow_chatgpt_all_rss_max"
                  fi
                  echo
                } >> outputs/result.txt
              fi
              ;;
            vf3)
              vf3_base_first_out=""
              vf3_base_first_ms_runs=""
              vf3_base_first_rss_runs=""
              vf3_base_all_out=""
              vf3_base_all_ms_runs=""
              vf3_base_all_rss_runs=""

              vf3_first_out=""
              vf3_first_ms_runs=""
              vf3_first_rss_runs=""
              vf3_all_out=""
              vf3_all_ms_runs=""
              vf3_all_rss_runs=""

              chatvf3_first_out=""
              chatvf3_first_ms_runs=""
              chatvf3_first_rss_runs=""
              chatvf3_all_out=""
              chatvf3_all_ms_runs=""
              chatvf3_all_rss_runs=""

              # Phase 1: setup + warmup (web UI fills the progress bar once here)
              PROGRESS_STAGE="setup"
              progress_set_phase "Setting up Testing Environment"
              if [ "${WARMUP_REQUESTED:-0}" -gt 0 ]; then
                if ! warmup_only "VF3 baseline first" ./baselines/vf3lib/bin/vf3 -r 0 -F "${FILES[0]}" "${FILES[1]}"; then
                  EXIT_CODE=1
                fi
                if ! warmup_only "VF3 baseline all" ./baselines/vf3lib/bin/vf3 -r 0 "${FILES[0]}" "${FILES[1]}"; then
                  EXIT_CODE=1
                fi
                if ! warmup_only "VF3 Gemini first" ./src/vf3 --first-only "${FILES[0]}" "${FILES[1]}"; then
                  EXIT_CODE=1
                fi
                if ! warmup_only "VF3 Gemini all" ./src/vf3 "${FILES[0]}" "${FILES[1]}"; then
                  EXIT_CODE=1
                fi
                if ! warmup_only "VF3 ChatGPT first" ./src/chatvf3 --first-only "${FILES[0]}" "${FILES[1]}"; then
                  EXIT_CODE=1
                fi
                if ! warmup_only "VF3 ChatGPT all" ./src/chatvf3 "${FILES[0]}" "${FILES[1]}"; then
                  EXIT_CODE=1
                fi
              else
                progress_setup_tick
              fi
              PROGRESS_SETUP_DONE="$PROGRESS_SETUP_TOTAL"
              progress_update_check_run "in_progress" || true

              # Phase 2: measured iterations (web UI resets the bar and fills again here)
              PROGRESS_STAGE="tests"
              PROGRESS_PHASE=""
              PROGRESS_DONE_TICKS=0
              progress_update_check_run "in_progress" || true
              WARMUP=0

              progress_set_phase "VF3 baseline"
              if ! bench_capture_rss_n vf3_base_first_out vf3_base_first_ms_runs vf3_base_first_rss_runs "$ITERATIONS" ./baselines/vf3lib/bin/vf3 -r 0 -F "${FILES[0]}" "${FILES[1]}"; then
                EXIT_CODE=1
                echo "[VF3 baseline] first-solution run failed." >> outputs/result.txt
              fi
              progress_set_phase "VF3 baseline"
              if ! bench_capture_rss_n vf3_base_all_out vf3_base_all_ms_runs vf3_base_all_rss_runs "$ITERATIONS" ./baselines/vf3lib/bin/vf3 -r 0 "${FILES[0]}" "${FILES[1]}"; then
                EXIT_CODE=1
                echo "[VF3 baseline] all-solutions run failed." >> outputs/result.txt
              fi

              if [ -n "${vf3_base_first_ms_runs:-}" ]; then
                read vf3_base_first_ms_median vf3_base_first_ms_mean vf3_base_first_ms_stdev vf3_base_first_ms_min vf3_base_first_ms_max vf3_base_first_ms_n <<< "$(calc_stats_ms $vf3_base_first_ms_runs)"
                vf3_base_first_ms="$vf3_base_first_ms_median"
              fi
              if [ -n "${vf3_base_all_ms_runs:-}" ]; then
                read vf3_base_all_ms_median vf3_base_all_ms_mean vf3_base_all_ms_stdev vf3_base_all_ms_min vf3_base_all_ms_max vf3_base_all_ms_n <<< "$(calc_stats_ms $vf3_base_all_ms_runs)"
                vf3_base_all_ms="$vf3_base_all_ms_median"
              fi
              if [ -n "${vf3_base_first_rss_runs:-}" ]; then
                read vf3_base_first_rss_median vf3_base_first_rss_mean vf3_base_first_rss_stdev vf3_base_first_rss_min vf3_base_first_rss_max vf3_base_first_rss_n <<< "$(calc_stats_kb $vf3_base_first_rss_runs)"
                vf3_base_first_rss_kb="$vf3_base_first_rss_median"
              fi
              if [ -n "${vf3_base_all_rss_runs:-}" ]; then
                read vf3_base_all_rss_median vf3_base_all_rss_mean vf3_base_all_rss_stdev vf3_base_all_rss_min vf3_base_all_rss_max vf3_base_all_rss_n <<< "$(calc_stats_kb $vf3_base_all_rss_runs)"
                vf3_base_all_rss_kb="$vf3_base_all_rss_median"
              fi
              if [ -n "${vf3_base_all_out:-}" ]; then
                vf3_base_result_line=$(echo "$vf3_base_all_out" | head -n1)
                vf3_base_result=$(echo "$vf3_base_result_line" | awk '{print $1}')
                if [ -z "$vf3_base_result" ]; then
                  vf3_base_result="$vf3_base_result_line"
                fi
                {
                  echo "[VF3 baseline]"
                  echo "$vf3_base_result"
                  echo "Warmup: $WARMUP_REQUESTED"
                  echo "Iterations: $ITERATIONS"
                  if [ -n "${vf3_base_first_ms_median:-}" ] && [ -n "${vf3_base_all_ms_median:-}" ]; then
                    print_stats_ms_first_all "Runtime (ms): " \
                      "$vf3_base_first_ms_median" "$vf3_base_first_ms_mean" "$vf3_base_first_ms_stdev" "$vf3_base_first_ms_min" "$vf3_base_first_ms_max" \
                      "$vf3_base_all_ms_median" "$vf3_base_all_ms_mean" "$vf3_base_all_ms_stdev" "$vf3_base_all_ms_min" "$vf3_base_all_ms_max"
                  fi
                  if [ -n "${vf3_base_first_rss_median:-}" ] && [ -n "${vf3_base_all_rss_median:-}" ]; then
                    print_stats_kb_first_all "Max RSS (kB): " \
                      "$vf3_base_first_rss_median" "$vf3_base_first_rss_mean" "$vf3_base_first_rss_stdev" "$vf3_base_first_rss_min" "$vf3_base_first_rss_max" \
                      "$vf3_base_all_rss_median" "$vf3_base_all_rss_mean" "$vf3_base_all_rss_stdev" "$vf3_base_all_rss_min" "$vf3_base_all_rss_max"
                  fi
                  echo
                } >> outputs/result.txt
              fi

              progress_set_phase "VF3 Gemini"
              if ! bench_capture_rss_n vf3_first_out vf3_first_ms_runs vf3_first_rss_runs "$ITERATIONS" ./src/vf3 --first-only "${FILES[0]}" "${FILES[1]}"; then
                EXIT_CODE=1
                echo "[VF3 Gemini] first-solution run failed." >> outputs/result.txt
              fi
              progress_set_phase "VF3 Gemini"
              if ! bench_capture_rss_n vf3_all_out vf3_all_ms_runs vf3_all_rss_runs "$ITERATIONS" ./src/vf3 "${FILES[0]}" "${FILES[1]}"; then
                EXIT_CODE=1
                echo "[VF3 Gemini] all-solutions run failed." >> outputs/result.txt
              fi

              if [ -n "${vf3_first_ms_runs:-}" ]; then
                read vf3_first_ms_median vf3_first_ms_mean vf3_first_ms_stdev vf3_first_ms_min vf3_first_ms_max vf3_first_ms_n <<< "$(calc_stats_ms $vf3_first_ms_runs)"
                vf3_first_ms="$vf3_first_ms_median"
              fi
              if [ -n "${vf3_all_ms_runs:-}" ]; then
                read vf3_all_ms_median vf3_all_ms_mean vf3_all_ms_stdev vf3_all_ms_min vf3_all_ms_max vf3_all_ms_n <<< "$(calc_stats_ms $vf3_all_ms_runs)"
                vf3_all_ms="$vf3_all_ms_median"
              fi
              if [ -n "${vf3_first_rss_runs:-}" ]; then
                read vf3_first_rss_median vf3_first_rss_mean vf3_first_rss_stdev vf3_first_rss_min vf3_first_rss_max vf3_first_rss_n <<< "$(calc_stats_kb $vf3_first_rss_runs)"
                vf3_first_rss_kb="$vf3_first_rss_median"
              fi
              if [ -n "${vf3_all_rss_runs:-}" ]; then
                read vf3_all_rss_median vf3_all_rss_mean vf3_all_rss_stdev vf3_all_rss_min vf3_all_rss_max vf3_all_rss_n <<< "$(calc_stats_kb $vf3_all_rss_runs)"
                vf3_all_rss_kb="$vf3_all_rss_median"
              fi
              if [ -n "${vf3_all_out:-}" ]; then
                vf3_gemini_result="$(echo "$vf3_all_out" | head -n1)"
                {
                  echo "[VF3 Gemini]"
                  echo "$vf3_gemini_result"
                  echo "Warmup: $WARMUP_REQUESTED"
                  echo "Iterations: $ITERATIONS"
                  if [ -n "${vf3_first_ms_median:-}" ] && [ -n "${vf3_all_ms_median:-}" ]; then
                    print_stats_ms_first_all "Runtime (ms): " \
                      "$vf3_first_ms_median" "$vf3_first_ms_mean" "$vf3_first_ms_stdev" "$vf3_first_ms_min" "$vf3_first_ms_max" \
                      "$vf3_all_ms_median" "$vf3_all_ms_mean" "$vf3_all_ms_stdev" "$vf3_all_ms_min" "$vf3_all_ms_max"
                  fi
                  if [ -n "${vf3_first_rss_median:-}" ] && [ -n "${vf3_all_rss_median:-}" ]; then
                    print_stats_kb_first_all "Max RSS (kB): " \
                      "$vf3_first_rss_median" "$vf3_first_rss_mean" "$vf3_first_rss_stdev" "$vf3_first_rss_min" "$vf3_first_rss_max" \
                      "$vf3_all_rss_median" "$vf3_all_rss_mean" "$vf3_all_rss_stdev" "$vf3_all_rss_min" "$vf3_all_rss_max"
                  fi
                  echo
                } >> outputs/result.txt
              fi

              progress_set_phase "VF3 ChatGPT"
              if ! bench_capture_rss_n chatvf3_first_out chatvf3_first_ms_runs chatvf3_first_rss_runs "$ITERATIONS" ./src/chatvf3 --first-only "${FILES[0]}" "${FILES[1]}"; then
                EXIT_CODE=1
                echo "[VF3 ChatGPT] first-solution run failed." >> outputs/result.txt
              fi
              progress_set_phase "VF3 ChatGPT"
              if ! bench_capture_rss_n chatvf3_all_out chatvf3_all_ms_runs chatvf3_all_rss_runs "$ITERATIONS" ./src/chatvf3 "${FILES[0]}" "${FILES[1]}"; then
                EXIT_CODE=1
                echo "[VF3 ChatGPT] all-solutions run failed." >> outputs/result.txt
              fi

              if [ -n "${chatvf3_first_ms_runs:-}" ]; then
                read chatvf3_first_ms_median chatvf3_first_ms_mean chatvf3_first_ms_stdev chatvf3_first_ms_min chatvf3_first_ms_max chatvf3_first_ms_n <<< "$(calc_stats_ms $chatvf3_first_ms_runs)"
                chatvf3_first_ms="$chatvf3_first_ms_median"
              fi
              if [ -n "${chatvf3_all_ms_runs:-}" ]; then
                read chatvf3_all_ms_median chatvf3_all_ms_mean chatvf3_all_ms_stdev chatvf3_all_ms_min chatvf3_all_ms_max chatvf3_all_ms_n <<< "$(calc_stats_ms $chatvf3_all_ms_runs)"
                chatvf3_all_ms="$chatvf3_all_ms_median"
              fi
              if [ -n "${chatvf3_first_rss_runs:-}" ]; then
                read chatvf3_first_rss_median chatvf3_first_rss_mean chatvf3_first_rss_stdev chatvf3_first_rss_min chatvf3_first_rss_max chatvf3_first_rss_n <<< "$(calc_stats_kb $chatvf3_first_rss_runs)"
                chatvf3_first_rss_kb="$chatvf3_first_rss_median"
              fi
              if [ -n "${chatvf3_all_rss_runs:-}" ]; then
                read chatvf3_all_rss_median chatvf3_all_rss_mean chatvf3_all_rss_stdev chatvf3_all_rss_min chatvf3_all_rss_max chatvf3_all_rss_n <<< "$(calc_stats_kb $chatvf3_all_rss_runs)"
                chatvf3_all_rss_kb="$chatvf3_all_rss_median"
              fi
              if [ -n "${chatvf3_all_out:-}" ]; then
                chatvf3_result="$(echo "$chatvf3_all_out" | head -n1)"
                {
                  echo "[VF3 ChatGPT]"
                  echo "$chatvf3_result"
                  echo "Warmup: $WARMUP_REQUESTED"
                  echo "Iterations: $ITERATIONS"
                  if [ -n "${chatvf3_first_ms_median:-}" ] && [ -n "${chatvf3_all_ms_median:-}" ]; then
                    print_stats_ms_first_all "Runtime (ms): " \
                      "$chatvf3_first_ms_median" "$chatvf3_first_ms_mean" "$chatvf3_first_ms_stdev" "$chatvf3_first_ms_min" "$chatvf3_first_ms_max" \
                      "$chatvf3_all_ms_median" "$chatvf3_all_ms_mean" "$chatvf3_all_ms_stdev" "$chatvf3_all_ms_min" "$chatvf3_all_ms_max"
                  fi
                  if [ -n "${chatvf3_first_rss_median:-}" ] && [ -n "${chatvf3_all_rss_median:-}" ]; then
                    print_stats_kb_first_all "Max RSS (kB): " \
                      "$chatvf3_first_rss_median" "$chatvf3_first_rss_mean" "$chatvf3_first_rss_stdev" "$chatvf3_first_rss_min" "$chatvf3_first_rss_max" \
                      "$chatvf3_all_rss_median" "$chatvf3_all_rss_mean" "$chatvf3_all_rss_stdev" "$chatvf3_all_rss_min" "$chatvf3_all_rss_max"
                  fi
                  echo
                } >> outputs/result.txt
              fi
              ;;
            *)
              echo "Unknown algorithm: $ALGORITHM" >> outputs/result.txt
              EXIT_CODE=1
              ;;
          esac
          
          finish_run
          echo "EXIT_CODE=$EXIT_CODE" >> "$GITHUB_OUTPUT"
          echo "REQUEST_ID=${REQUEST_ID}" >> "$GITHUB_OUTPUT"
          echo "ITERATIONS=${ITERATIONS}" >> "$GITHUB_OUTPUT"
          echo "WARMUP=${WARMUP_REQUESTED}" >> "$GITHUB_OUTPUT"
          echo "DIJKSTRA_BASELINE_MS=${dijkstra_baseline_ms:-}" >> "$GITHUB_OUTPUT"
          echo "DIJKSTRA_LLM_MS=${dijkstra_llm_ms:-}" >> "$GITHUB_OUTPUT"
          echo "DIJKSTRA_BASELINE_RSS_KB=${dijkstra_baseline_rss_kb:-}" >> "$GITHUB_OUTPUT"
          echo "DIJKSTRA_LLM_RSS_KB=${dijkstra_llm_rss_kb:-}" >> "$GITHUB_OUTPUT"
          echo "GLASGOW_FIRST_MS=${glasgow_first_ms:-}" >> "$GITHUB_OUTPUT"
          echo "GLASGOW_ALL_MS=${glasgow_all_ms:-}" >> "$GITHUB_OUTPUT"
          echo "GLASGOW_FIRST_RSS_KB=${glasgow_first_rss_kb:-}" >> "$GITHUB_OUTPUT"
          echo "GLASGOW_ALL_RSS_KB=${glasgow_all_rss_kb:-}" >> "$GITHUB_OUTPUT"
          echo "GLASGOW_GEMINI_FIRST_MS=${glasgow_gemini_first_ms:-}" >> "$GITHUB_OUTPUT"
          echo "GLASGOW_GEMINI_ALL_MS=${glasgow_gemini_all_ms:-}" >> "$GITHUB_OUTPUT"
          echo "GLASGOW_GEMINI_FIRST_RSS_KB=${glasgow_gemini_first_rss_kb:-}" >> "$GITHUB_OUTPUT"
          echo "GLASGOW_GEMINI_ALL_RSS_KB=${glasgow_gemini_all_rss_kb:-}" >> "$GITHUB_OUTPUT"
          echo "GLASGOW_CHATGPT_FIRST_MS=${glasgow_chatgpt_first_ms:-}" >> "$GITHUB_OUTPUT"
          echo "GLASGOW_CHATGPT_ALL_MS=${glasgow_chatgpt_all_ms:-}" >> "$GITHUB_OUTPUT"
          echo "GLASGOW_CHATGPT_FIRST_RSS_KB=${glasgow_chatgpt_first_rss_kb:-}" >> "$GITHUB_OUTPUT"
          echo "GLASGOW_CHATGPT_ALL_RSS_KB=${glasgow_chatgpt_all_rss_kb:-}" >> "$GITHUB_OUTPUT"
          echo "VF3_BASE_FIRST_MS=${vf3_base_first_ms:-}" >> "$GITHUB_OUTPUT"
          echo "VF3_BASE_ALL_MS=${vf3_base_all_ms:-}" >> "$GITHUB_OUTPUT"
          echo "VF3_BASE_FIRST_RSS_KB=${vf3_base_first_rss_kb:-}" >> "$GITHUB_OUTPUT"
          echo "VF3_BASE_ALL_RSS_KB=${vf3_base_all_rss_kb:-}" >> "$GITHUB_OUTPUT"
          echo "VF3_GEMINI_FIRST_MS=${vf3_first_ms:-}" >> "$GITHUB_OUTPUT"
          echo "VF3_GEMINI_ALL_MS=${vf3_all_ms:-}" >> "$GITHUB_OUTPUT"
          echo "VF3_GEMINI_FIRST_RSS_KB=${vf3_first_rss_kb:-}" >> "$GITHUB_OUTPUT"
          echo "VF3_GEMINI_ALL_RSS_KB=${vf3_all_rss_kb:-}" >> "$GITHUB_OUTPUT"
          echo "VF3_CHATGPT_FIRST_MS=${chatvf3_first_ms:-}" >> "$GITHUB_OUTPUT"
          echo "VF3_CHATGPT_ALL_MS=${chatvf3_all_ms:-}" >> "$GITHUB_OUTPUT"
          echo "VF3_CHATGPT_FIRST_RSS_KB=${chatvf3_first_rss_kb:-}" >> "$GITHUB_OUTPUT"
          echo "VF3_CHATGPT_ALL_RSS_KB=${chatvf3_all_rss_kb:-}" >> "$GITHUB_OUTPUT"
          # Always exit 0 so later steps run and results are committed
          exit 0
      
      - name: Create result JSON
        if: always()
        env:
          EXIT_CODE: ${{ steps.run.outputs.EXIT_CODE }}
          ITERATIONS: ${{ steps.run.outputs.ITERATIONS }}
          WARMUP: ${{ steps.run.outputs.WARMUP }}
          RUN_DURATION_MS: ${{ steps.run.outputs.RUN_DURATION_MS }}
          DIJKSTRA_BASELINE_MS: ${{ steps.run.outputs.DIJKSTRA_BASELINE_MS }}
          DIJKSTRA_LLM_MS: ${{ steps.run.outputs.DIJKSTRA_LLM_MS }}
          DIJKSTRA_BASELINE_RSS_KB: ${{ steps.run.outputs.DIJKSTRA_BASELINE_RSS_KB }}
          DIJKSTRA_LLM_RSS_KB: ${{ steps.run.outputs.DIJKSTRA_LLM_RSS_KB }}
          GLASGOW_FIRST_MS: ${{ steps.run.outputs.GLASGOW_FIRST_MS }}
          GLASGOW_ALL_MS: ${{ steps.run.outputs.GLASGOW_ALL_MS }}
          GLASGOW_FIRST_RSS_KB: ${{ steps.run.outputs.GLASGOW_FIRST_RSS_KB }}
          GLASGOW_ALL_RSS_KB: ${{ steps.run.outputs.GLASGOW_ALL_RSS_KB }}
          GLASGOW_GEMINI_FIRST_MS: ${{ steps.run.outputs.GLASGOW_GEMINI_FIRST_MS }}
          GLASGOW_GEMINI_ALL_MS: ${{ steps.run.outputs.GLASGOW_GEMINI_ALL_MS }}
          GLASGOW_GEMINI_FIRST_RSS_KB: ${{ steps.run.outputs.GLASGOW_GEMINI_FIRST_RSS_KB }}
          GLASGOW_GEMINI_ALL_RSS_KB: ${{ steps.run.outputs.GLASGOW_GEMINI_ALL_RSS_KB }}
          GLASGOW_CHATGPT_FIRST_MS: ${{ steps.run.outputs.GLASGOW_CHATGPT_FIRST_MS }}
          GLASGOW_CHATGPT_ALL_MS: ${{ steps.run.outputs.GLASGOW_CHATGPT_ALL_MS }}
          GLASGOW_CHATGPT_FIRST_RSS_KB: ${{ steps.run.outputs.GLASGOW_CHATGPT_FIRST_RSS_KB }}
          GLASGOW_CHATGPT_ALL_RSS_KB: ${{ steps.run.outputs.GLASGOW_CHATGPT_ALL_RSS_KB }}
          VF3_BASE_FIRST_MS: ${{ steps.run.outputs.VF3_BASE_FIRST_MS }}
          VF3_BASE_ALL_MS: ${{ steps.run.outputs.VF3_BASE_ALL_MS }}
          VF3_BASE_FIRST_RSS_KB: ${{ steps.run.outputs.VF3_BASE_FIRST_RSS_KB }}
          VF3_BASE_ALL_RSS_KB: ${{ steps.run.outputs.VF3_BASE_ALL_RSS_KB }}
          VF3_GEMINI_FIRST_MS: ${{ steps.run.outputs.VF3_GEMINI_FIRST_MS }}
          VF3_GEMINI_ALL_MS: ${{ steps.run.outputs.VF3_GEMINI_ALL_MS }}
          VF3_GEMINI_FIRST_RSS_KB: ${{ steps.run.outputs.VF3_GEMINI_FIRST_RSS_KB }}
          VF3_GEMINI_ALL_RSS_KB: ${{ steps.run.outputs.VF3_GEMINI_ALL_RSS_KB }}
          VF3_CHATGPT_FIRST_MS: ${{ steps.run.outputs.VF3_CHATGPT_FIRST_MS }}
          VF3_CHATGPT_ALL_MS: ${{ steps.run.outputs.VF3_CHATGPT_ALL_MS }}
          VF3_CHATGPT_FIRST_RSS_KB: ${{ steps.run.outputs.VF3_CHATGPT_FIRST_RSS_KB }}
          VF3_CHATGPT_ALL_RSS_KB: ${{ steps.run.outputs.VF3_CHATGPT_ALL_RSS_KB }}
        run: |
          python - <<'PY'
          import datetime
          import json
          import os
          from pathlib import Path

          algorithm = os.environ.get("ALGORITHM_INPUT", "")
          exit_code = os.environ.get("EXIT_CODE", "")
          request_id = os.environ.get("REQUEST_ID_INPUT", "")
          timestamp = datetime.datetime.now(datetime.timezone.utc).strftime("%Y-%m-%d %H:%M:%S UTC")
          input_mode = os.environ.get("INPUT_MODE_INPUT", "")
          input_files = os.environ.get("INPUT_FILES_INPUT", "")
          gen_n = os.environ.get("GENERATOR_N_INPUT", "")
          gen_k = os.environ.get("GENERATOR_K_INPUT", "")
          gen_density = os.environ.get("GENERATOR_DENSITY_INPUT", "")

          result_txt = Path("outputs/result.txt")
          text = ""
          if result_txt.exists():
              text = result_txt.read_text(encoding="utf-8", errors="replace")

          if exit_code == "0":
              status = "success"
              output = text or "No output"
              error = ""
          else:
              status = "error"
              output = ""
              error = text or "Unknown error"

          Path("outputs").mkdir(parents=True, exist_ok=True)
          data = {
              "algorithm": algorithm,
              "timestamp": timestamp,
              "status": status,
              "output": output,
              "error": error,
              "request_id": request_id,
          }
          inputs = {"input_mode": input_mode, "input_files": input_files}
          if gen_n:
              try:
                  inputs["n"] = int(gen_n)
              except ValueError:
                  inputs["n"] = gen_n
          if gen_k:
              try:
                  inputs["k"] = int(gen_k)
              except ValueError:
                  inputs["k"] = gen_k
          if gen_density:
              try:
                  inputs["density"] = float(gen_density)
              except ValueError:
                  inputs["density"] = gen_density
          if inputs:
              data["inputs"] = inputs
          iterations = os.environ.get("ITERATIONS", "").strip()
          if iterations:
              try:
                  data["iterations"] = int(iterations)
              except ValueError:
                  pass
          warmup = os.environ.get("WARMUP", "").strip()
          if warmup:
              try:
                  data["warmup"] = int(warmup)
              except ValueError:
                  pass
          duration_ms = os.environ.get("RUN_DURATION_MS", "").strip()
          if duration_ms:
              try:
                  data["run_duration_ms"] = float(duration_ms)
              except ValueError:
                  pass
          timings_ms = {}
          if algorithm == "dijkstra":
              baseline = os.environ.get("DIJKSTRA_BASELINE_MS", "")
              llm = os.environ.get("DIJKSTRA_LLM_MS", "")
              if baseline:
                  timings_ms["baseline"] = float(baseline)
              if llm:
                  timings_ms["llm"] = float(llm)
          elif algorithm == "glasgow":
              first = os.environ.get("GLASGOW_FIRST_MS", "")
              all_ms = os.environ.get("GLASGOW_ALL_MS", "")
              if first:
                  timings_ms["first"] = float(first)
              if all_ms:
                  timings_ms["all"] = float(all_ms)
              gemini_first = os.environ.get("GLASGOW_GEMINI_FIRST_MS", "")
              gemini_all = os.environ.get("GLASGOW_GEMINI_ALL_MS", "")
              chatgpt_first = os.environ.get("GLASGOW_CHATGPT_FIRST_MS", "")
              chatgpt_all = os.environ.get("GLASGOW_CHATGPT_ALL_MS", "")
              if gemini_first:
                  timings_ms["gemini_first"] = float(gemini_first)
              if gemini_all:
                  timings_ms["gemini_all"] = float(gemini_all)
              if chatgpt_first:
                  timings_ms["chatgpt_first"] = float(chatgpt_first)
              if chatgpt_all:
                  timings_ms["chatgpt_all"] = float(chatgpt_all)
          elif algorithm == "vf3":
              def maybe_add(name: str, key: str) -> None:
                  value = os.environ.get(key, "")
                  if value:
                      timings_ms[name] = float(value)

              maybe_add("baseline_first", "VF3_BASE_FIRST_MS")
              maybe_add("baseline_all", "VF3_BASE_ALL_MS")
              maybe_add("gemini_first", "VF3_GEMINI_FIRST_MS")
              maybe_add("gemini_all", "VF3_GEMINI_ALL_MS")
              maybe_add("chatgpt_first", "VF3_CHATGPT_FIRST_MS")
              maybe_add("chatgpt_all", "VF3_CHATGPT_ALL_MS")
          if timings_ms:
              data["timings_ms"] = timings_ms

          memory_kb = {}
          if algorithm == "dijkstra":
              baseline = os.environ.get("DIJKSTRA_BASELINE_RSS_KB", "")
              llm = os.environ.get("DIJKSTRA_LLM_RSS_KB", "")
              if baseline:
                  try:
                      memory_kb["baseline"] = int(baseline)
                  except ValueError:
                      pass
              if llm:
                  try:
                      memory_kb["llm"] = int(llm)
                  except ValueError:
                      pass
          elif algorithm == "glasgow":
              first = os.environ.get("GLASGOW_FIRST_RSS_KB", "")
              all_kb = os.environ.get("GLASGOW_ALL_RSS_KB", "")
              if first:
                  try:
                      memory_kb["first"] = int(first)
                  except ValueError:
                      pass
              if all_kb:
                  try:
                      memory_kb["all"] = int(all_kb)
                  except ValueError:
                      pass
              gemini_first = os.environ.get("GLASGOW_GEMINI_FIRST_RSS_KB", "")
              gemini_all = os.environ.get("GLASGOW_GEMINI_ALL_RSS_KB", "")
              chatgpt_first = os.environ.get("GLASGOW_CHATGPT_FIRST_RSS_KB", "")
              chatgpt_all = os.environ.get("GLASGOW_CHATGPT_ALL_RSS_KB", "")
              for key, value in (
                  ("gemini_first", gemini_first),
                  ("gemini_all", gemini_all),
                  ("chatgpt_first", chatgpt_first),
                  ("chatgpt_all", chatgpt_all),
              ):
                  if value:
                      try:
                          memory_kb[key] = int(value)
                      except ValueError:
                          pass
          elif algorithm == "vf3":
              def maybe_add_int(name: str, key: str) -> None:
                  value = os.environ.get(key, "")
                  if not value:
                      return
                  try:
                      memory_kb[name] = int(value)
                  except ValueError:
                      return

              maybe_add_int("baseline_first", "VF3_BASE_FIRST_RSS_KB")
              maybe_add_int("baseline_all", "VF3_BASE_ALL_RSS_KB")
              maybe_add_int("gemini_first", "VF3_GEMINI_FIRST_RSS_KB")
              maybe_add_int("gemini_all", "VF3_GEMINI_ALL_RSS_KB")
              maybe_add_int("chatgpt_first", "VF3_CHATGPT_FIRST_RSS_KB")
              maybe_add_int("chatgpt_all", "VF3_CHATGPT_ALL_RSS_KB")

          if memory_kb:
              data["memory_kb"] = memory_kb
          Path("outputs/result.json").write_text(
              json.dumps(data, indent=2) + "\n", encoding="utf-8"
          )
          PY

      - name: Upload generated graphs
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: generated-graphs-${{ steps.run.outputs.REQUEST_ID || github.run_id }}
          path: outputs/generated
          if-no-files-found: ignore
          retention-days: 30

      - name: Upload results artifact
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: algorithm-result
          path: outputs/result.json
          if-no-files-found: error
          retention-days: 14
